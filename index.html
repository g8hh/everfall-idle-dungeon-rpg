<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Auto-Battler RPG</title>
    <style>
        @import url('css2.css');


        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #151935 100%);
            color: #fff;
            overflow: hidden;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center, rgba(99, 102, 241, 0.1) 0%, transparent 70%);
        }

        #main-content {
            flex: 1;
            display: flex;
            min-height: 0;
        }

        #main-view {
    flex: 1;
    position: relative;
    background: linear-gradient(180deg, rgba(6, 9, 23, 0.9) 0%, rgba(15, 23, 42, 0.95) 100%);
    box-shadow: inset 0 0 100px rgba(99, 102, 241, 0.1);
    background-size: cover !important;
    background-position: center !important;
    background-repeat: no-repeat !important;
}

        #dungeon-canvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            background: transparent;
        }

        #bottom-ui {
            height: 400px;
            background: linear-gradient(180deg, rgba(15, 23, 42, 0.5) 0%, rgba(6, 9, 23, 0.5) 100%), url('behind%20character%20cards.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            border-top: 2px solid;
            border-image: linear-gradient(90deg, #71717a, #52525b, #a1a1aa) 1;
            display: flex;
            gap: 20px;
            padding: 20px;
            overflow-x: auto;
            overflow-y: hidden;
            backdrop-filter: blur(10px);
            position: relative;
        }

        #bottom-ui::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, #71717a, transparent);
            animation: glow-line 3s ease-in-out infinite;
        }

        @keyframes glow-line {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        #party-container {
            display: flex;
            gap: 20px;
            flex: 1;
            justify-content: center;
            align-items: stretch;
        }

.party-member {
    background: linear-gradient(135deg, rgba(30, 41, 59, 0.9) 0%, rgba(15, 23, 42, 0.9) 100%);
    border: 1px solid rgba(99, 102, 241, 0.3);
    border-radius: 12px;
    padding: 15px;
    min-width: 300px;
    max-width: 350px;
    flex: 1;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    position: relative;
    overflow-y: auto;
    overflow-x: hidden;
    transition: none;
    display: flex;
    flex-direction: column;
}

.party-member::-webkit-scrollbar {
    width: 6px;
}

.party-member::-webkit-scrollbar-track {
    background: rgba(15, 23, 42, 0.4);
    border-radius: 3px;
}

.party-member::-webkit-scrollbar-thumb {
    background: rgba(99, 102, 241, 0.5);
    border-radius: 3px;
}

.party-member::-webkit-scrollbar-thumb:hover {
    background: rgba(99, 102, 241, 0.7);
}

        #top-ui-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            z-index: 200;
        }

        #room-label {
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.95) 0%, rgba(30, 41, 59, 0.95) 100%);
            padding: 14px 35px;
            border: 2px solid rgba(99, 102, 241, 0.6);
            border-radius: 50px;
            font-size: 20px;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 2px 15px rgba(99, 102, 241, 0.6);
            backdrop-filter: blur(15px);
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.15);
            letter-spacing: 1.5px;
            position: relative;
            overflow: hidden;
        }

        #room-label::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(99, 102, 241, 0.3), transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        @keyframes endlessBlessingsPulse {
            0%, 100% {
                filter: brightness(0.95) saturate(1);
            }
            50% {
                filter: brightness(1.05) saturate(1.1);
            }
        }

        @keyframes blessingCardPulse {
            0%, 100% {
                box-shadow: 0 0 25px rgba(200, 160, 50, 0.5), inset 0 0 15px rgba(218, 165, 32, 0.25);
            }
            50% {
                box-shadow: 0 0 30px rgba(200, 160, 50, 0.65), inset 0 0 20px rgba(218, 165, 32, 0.35);
            }
        }

        #gold-display-top {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.25) 0%, rgba(251, 191, 36, 0.15) 100%);
            padding: 10px 28px;
            border: 2px solid rgba(245, 158, 11, 0.6);
            border-radius: 50px;
            font-size: 18px;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
            color: #fbbf24;
            text-shadow: 0 2px 12px rgba(245, 158, 11, 0.8);
            backdrop-filter: blur(15px);
            box-shadow: 0 6px 25px rgba(245, 158, 11, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.15);
            display: flex;
            align-items: center;
            gap: 8px;
            letter-spacing: 1px;
        }

        #gold-display-top::before {
            content: 'üí∞';
            font-size: 22px;
            filter: drop-shadow(0 2px 8px rgba(245, 158, 11, 0.6));
        }

        #blessing-display-top {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.25) 0%, rgba(139, 92, 246, 0.15) 100%);
            padding: 10px 28px;
            border: 2px solid rgba(168, 85, 247, 0.6);
            border-radius: 50px;
            font-size: 18px;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
            color: #e9d5ff;
            text-shadow: 0 2px 12px rgba(168, 85, 247, 0.8);
            backdrop-filter: blur(15px);
            box-shadow: 0 6px 25px rgba(168, 85, 247, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.15);
            display: flex;
            align-items: center;
            gap: 8px;
            letter-spacing: 1px;
        }

        #kill-counter {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.25) 0%, rgba(220, 38, 38, 0.15) 100%);
            padding: 10px 28px;
            border: 2px solid rgba(239, 68, 68, 0.6);
            border-radius: 50px;
            font-size: 18px;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
            color: #fca5a5;
            text-shadow: 0 2px 12px rgba(239, 68, 68, 0.8);
            backdrop-filter: blur(15px);
            box-shadow: 0 6px 25px rgba(239, 68, 68, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.15);
            display: flex;
            align-items: center;
            gap: 8px;
            letter-spacing: 1px;
        }

        #kill-counter::before {
            content: '‚öîÔ∏è';
            font-size: 22px;
            filter: drop-shadow(0 2px 8px rgba(239, 68, 68, 0.6));
        }

        #damage-stats-display {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.25) 0%, rgba(37, 99, 235, 0.15) 100%);
            padding: 10px 28px;
            border: 2px solid rgba(59, 130, 246, 0.6);
            border-radius: 50px;
            font-size: 18px;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
            color: #93c5fd;
            text-shadow: 0 2px 12px rgba(59, 130, 246, 0.8);
            backdrop-filter: blur(15px);
            box-shadow: 0 6px 25px rgba(59, 130, 246, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.15);
            display: flex;
            align-items: center;
            gap: 8px;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            cursor: grab;
        }

        #damage-stats-display:active {
            cursor: grabbing;
        }

        #damage-stats-display:hover {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.35) 0%, rgba(37, 99, 235, 0.25) 100%);
            border-color: rgba(59, 130, 246, 0.8);
            box-shadow: 0 8px 30px rgba(59, 130, 246, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        #combat-stats-container.dragging #damage-stats-display {
            cursor: grabbing;
            transform: scale(1.02);
        }

        #character-stats-panel {
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.95) 0%, rgba(30, 41, 59, 0.95) 100%);
            border: 2px solid rgba(59, 130, 246, 0.6);
            border-radius: 12px;
            padding: 12px 20px;
            backdrop-filter: blur(15px);
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.6);
            min-width: 300px;
            max-width: 350px;
            max-height: 300px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(59, 130, 246, 0.5) rgba(15, 23, 42, 0.4);
        }

        #character-stats-panel::-webkit-scrollbar {
            width: 6px;
        }

        #character-stats-panel::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.4);
            border-radius: 3px;
        }

        #character-stats-panel::-webkit-scrollbar-thumb {
            background: rgba(59, 130, 246, 0.5);
            border-radius: 3px;
        }

        #character-stats-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(59, 130, 246, 0.7);
        }

        #dungeon-selector {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(6, 9, 23, 0.98) 100%);
            padding: 40px;
            border: 2px solid rgba(99, 102, 241, 0.5);
            border-radius: 20px;
            display: none;
            z-index: 1000;
            backdrop-filter: blur(20px);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        #dungeon-selector h2 {
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(135deg, #71717a, #52525b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
            margin-bottom: 30px;
            font-size: 28px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .dungeon-option {
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.9) 0%, rgba(15, 23, 42, 0.9) 100%);
            border: 2px solid rgba(99, 102, 241, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 400px;
            position: relative;
            overflow: hidden;
        }

        .dungeon-option::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(99, 102, 241, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .dungeon-option:hover {
            background: linear-gradient(135deg, rgba(51, 65, 85, 0.9) 0%, rgba(30, 41, 59, 0.9) 100%);
            border-color: rgba(99, 102, 241, 0.6);
            transform: translateX(10px);
            box-shadow: 0 4px 20px rgba(99, 102, 241, 0.3);
        }

        .dungeon-option:hover::after {
            left: 100%;
        }

.dungeon-option.umbral { border-left: 4px solid #a855f7; }
        .dungeon-option.everfall { border-left: 4px solid #10b981; }
        .dungeon-option.stoneforge { border-left: 4px solid #ef4444; }
        .dungeon-option.vault { border-left: 4px solid #f59e0b; }
.dungeon-option.runetrial { border-left: 4px solid #3b82f6; }
        .dungeon-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
        }

        .dungeon-loot {
            font-size: 14px;
            color: #94a3b8;
            font-weight: 500;
        }

        #dungeon-map {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.85) 0%, rgba(30, 41, 59, 0.85) 100%);
            border: 1px solid rgba(99, 102, 241, 0.2);
            border-radius: 12px;
            padding: 2px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        #map-canvas {
            width: 350px;
            height: 350px;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            border-radius: 10px;
            cursor: pointer;
        }

        #map-canvas {
            width: 200px;
            height: 200px;
            image-rendering: pixelated;
            border-radius: 8px;
        }

        #side-panel {
            width: 380px;
            background: linear-gradient(180deg, rgba(15, 23, 42, 0.98) 0%, rgba(6, 9, 23, 0.98) 100%);
            border-left: 2px solid;
            border-image: linear-gradient(180deg, #71717a, #52525b) 1;
            display: flex;
            overflow: hidden;
            max-height: 100%;
            backdrop-filter: blur(10px);
        }

        #tab-navigation {
            width: 70px;
            background: linear-gradient(180deg, rgba(6, 9, 23, 0.95) 0%, rgba(15, 23, 42, 0.95) 100%);
            border-right: 1px solid rgba(99, 102, 241, 0.2);
            display: flex;
            flex-direction: column;
            padding: 20px 0;
            gap: 8px;
        }

        .tab-button {
            width: 70px;
            height: 60px;
            background: transparent;
            border: none;
            border-radius: 0;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            margin: 0;
        }
		.loot-sub-tab.active {
            background: rgba(99, 102, 241, 0.2) !important;
            color: #e2e8f0 !important;
        }

        .loot-sub-tab:hover {
            background: rgba(99, 102, 241, 0.1) !important;
        }
        .loot-filter-btn.active,
        .inventory-filter-btn.active {
            background: rgba(99, 102, 241, 0.4) !important;
            border-color: rgba(99, 102, 241, 0.6) !important;
            color: #e2e8f0 !important;
        }

        .loot-filter-btn:hover,
        .inventory-filter-btn:hover {
            background: rgba(99, 102, 241, 0.3) !important;
        }
        .tab-button img {
    width: 48px !important;
    height: 48px !important;
    object-fit: contain;
    display: block;
    margin: 0 auto;
}




        .tab-button:hover {
            background: rgba(99, 102, 241, 0.1);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.2);
        }

        .tab-button.active {
            background: rgba(99, 102, 241, 0.15);
            border: 2px solid rgba(99, 102, 241, 0.6);
            border-radius: 12px;
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.3), inset 0 0 10px rgba(99, 102, 241, 0.1);
        }
/* Sub-tab active highlighting - matches main tab style */
button.loot-sub-tab.active,
button.cache-sub-tab.active,
button.keystone-sub-tab.active,
button.rune-char-tab.active {
    background: rgba(99, 102, 241, 0.15) !important;
    border: 2px solid rgba(99, 102, 241, 0.6) !important;
    border-radius: 12px !important;
    transform: scale(1.05) !important;
    box-shadow: 0 0 20px rgba(99, 102, 241, 0.3), inset 0 0 10px rgba(99, 102, 241, 0.1) !important;
    color: #e2e8f0 !important;
}

button.loot-sub-tab:hover,
button.cache-sub-tab:hover,
button.keystone-sub-tab:hover,
button.rune-char-tab:hover {
    background: rgba(99, 102, 241, 0.1) !important;
}
        #tab-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px;
        }

        #tab-content::-webkit-scrollbar {
            width: 8px;
        }

        #tab-content::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.5);
            border-radius: 4px;
        }

        #tab-content::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #71717a, #52525b);
            border-radius: 4px;
        }

        .tab-panel {
            display: none;
            height: 100%;
        }

        .tab-panel.active {
            display: block;
            height: 100%;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .section-title {
            font-size: 12px;
            color: #f4f4f5;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
            position: relative;
            padding-left: 15px;
        }

        .section-title::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            background: #71717a;
            border-radius: 2px;
        }

        .collapsible-section .collapsible-content {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 1;
        }

        .collapsible-section.collapsed .collapsible-content {
            max-height: 0;
            opacity: 0;
        }

        .collapse-arrow {
            display: inline-block;
            transition: transform 0.3s ease;
            font-size: 10px;
        }

        .collapsible-section.collapsed .collapse-arrow {
            transform: rotate(-90deg);
        }

        .member-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(99, 102, 241, 0.2);
        }

        .member-name {
            font-weight: 700;
            color: #e2e8f0;
            font-size: 16px;
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .member-level {
            color: #71717a;
            font-size: 14px;
            font-weight: 600;
            background: rgba(99, 102, 241, 0.1);
            padding: 2px 10px;
            border-radius: 12px;
            border: 1px solid rgba(99, 102, 241, 0.3);
        }

        .stat-bars {
            margin-bottom: 12px;
        }

        .stat-bar {
            height: 18px;
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(99, 102, 241, 0.2);
            margin-bottom: 6px;
            position: relative;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .hp-bar .bar-fill {
            background: linear-gradient(90deg, #dc2626, #ef4444, #f87171);
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
        }
        .mana-bar .bar-fill {
            background: linear-gradient(90deg, #2563eb, #3b82f6, #60a5fa);
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }
        .xp-bar .bar-fill {
            background: linear-gradient(90deg, #7c3aed, #52525b, #a78bfa);
            box-shadow: 0 0 10px rgba(139, 92, 246, 0.5);
        }

        .bar-fill {
            height: 100%;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        .bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.2), transparent);
            border-radius: 8px 8px 0 0;
        }

        .bar-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 11px;
    font-weight: 600;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
    z-index: 1;
    letter-spacing: 0.5px;
}

.ability-status {
    display: flex;
    gap: 6px;
    align-items: center;
}

.ability-indicator {
    position: relative;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.ability-icon {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.2));
    border: 2px solid rgba(99, 102, 241, 0.4);
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Orbitron', sans-serif;
    font-size: 13px;
    font-weight: 700;
    color: #6366f1;
    transition: all 0.3s ease;
    z-index: 2;
}

.ability-indicator.no-mana .ability-icon {
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(37, 99, 235, 0.15));
    border-color: rgba(59, 130, 246, 0.3);
    color: #3b82f6;
    opacity: 0.5;
}

.ability-indicator.no-rune .ability-icon {
    background: linear-gradient(135deg, rgba(71, 85, 105, 0.15), rgba(51, 65, 85, 0.15));
    border-color: rgba(71, 85, 105, 0.3);
    color: #64748b;
    opacity: 0.4;
}

.ability-indicator.ready .ability-icon {
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.3), rgba(52, 211, 153, 0.3));
    border-color: #10b981;
    color: #10b981;
    box-shadow: 0 0 15px rgba(16, 185, 129, 0.4);
}

.ability-indicator.active .ability-icon {
    background: linear-gradient(135deg, rgba(245, 158, 11, 0.4), rgba(251, 191, 36, 0.4));
    border-color: #f59e0b;
    color: #f59e0b;
    animation: ability-pulse 0.5s ease;
    box-shadow: 0 0 20px rgba(245, 158, 11, 0.6);
}

.ability-indicator.on-cooldown .ability-icon {
    background: linear-gradient(135deg, rgba(71, 85, 105, 0.2), rgba(51, 65, 85, 0.2));
    border-color: rgba(71, 85, 105, 0.4);
    color: #64748b;
}

@keyframes ability-pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.15); }
}

.ability-cooldown-ring {
    position: absolute;
    top: 0;
    left: 0;
    width: 32px;
    height: 32px;
    transform: rotate(-90deg);
    z-index: 1;
}

.ability-cooldown-bg {
    fill: none;
    stroke: rgba(30, 41, 59, 0.6);
    stroke-width: 2;
}

.ability-cooldown-fill {
    fill: none;
    stroke: #6366f1;
    stroke-width: 2;
    stroke-linecap: round;
    transition: stroke-dasharray 0.1s linear;
}

.ability-indicator.on-cooldown .ability-cooldown-fill {
    stroke: #ef4444;
}

.ability-indicator.ready .ability-cooldown-fill {
    stroke: #10b981;
}



        .member-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 13px;
            margin-top: 10px;
            padding: 10px;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 8px;
            border: 1px solid rgba(99, 102, 241, 0.1);
        }

        .stat {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            transition: all 0.2s ease;
        }

        .stat:hover {
            transform: translateX(2px);
        }

        .stat-label {
            color: #64748b;
            font-weight: 500;
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 0.5px;
        }

        .stat-value {
            color: #e2e8f0;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
        }

        .stat-value.attack { color: #ef4444; }
        .stat-value.defense { color: #3b82f6; }
        .stat-value.speed { color: #10b981; }

        .equipment {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(99, 102, 241, 0.2);
            font-size: 12px;
        }

        .equipment-slot {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            padding: 4px 8px;
            background: rgba(15, 23, 42, 0.3);
            border-radius: 6px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .equipment-slot:hover {
            background: rgba(99, 102, 241, 0.2);
            transform: translateX(2px);
        }

        .view-toggle {
            display: flex;
            gap: 5px;
            margin-bottom: 12px;
            background: rgba(15, 23, 42, 0.5);
            padding: 4px;
            border-radius: 8px;
        }

        .view-btn {
            flex: 1;
            padding: 6px 10px;
            background: transparent;
            color: #64748b;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            font-weight: 600;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            pointer-events: auto;
            position: relative;
            z-index: 10;
        }

        .view-btn:hover {
            background: rgba(99, 102, 241, 0.1);
            color: #94a3b8;
        }

        .view-btn.active {
            background: linear-gradient(135deg, #71717a, #52525b);
            color: #fff;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
        }

        .view-content {
            position: relative;
            min-height: 180px;
        }

.member-stats-view,
.abilities-view,
.equipment-view,
.pet-view {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease;
}

.member-stats-view.active,
.abilities-view.active,
.equipment-view.active,
.pet-view.active {
    opacity: 1;
    visibility: visible;
}

        .equipment-view .equipment {
            margin-top: 0;
            padding-top: 0;
            border-top: none;
        }

        .equipment-name {
            color: #94a3b8;
            font-weight: 600;
        }

        .equipment-name.common { color: #94a3b8; }
        .equipment-name.uncommon { color: #10b981; }
        .equipment-name.rare { color: #3b82f6; }
        .equipment-name.epic { color: #a855f7; }
        .equipment-name.legendary {
            color: #f59e0b;
            text-shadow: 0 0 5px rgba(245, 158, 11, 0.5);
        }

        .equipment-tooltip {
            position: absolute;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(6, 9, 23, 0.98) 100%);
            border: 2px solid;
            border-image: linear-gradient(135deg, #71717a, #52525b) 1;
            border-radius: 12px;
            padding: 16px;
            font-size: 13px;
            z-index: 25000;
            pointer-events: none;
            min-width: 250px;
            display: none;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .equipment-tooltip.show {
            display: block;
            animation: tooltipFadeIn 0.2s ease;
        }

        @keyframes tooltipFadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

.loot-tooltip {
    position: absolute;
    background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(6, 9, 23, 0.98) 100%);
    border: 2px solid;
    border-image: linear-gradient(135deg, #f59e0b, #a1a1aa) 1;
    border-radius: 12px;
    padding: 20px;
    font-size: 13px;
    z-index: 25000;
    pointer-events: none;
    min-width: 500px;
    display: none;
    box-shadow: 0 15px 50px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(15px);
}

        .loot-tooltip.show {
            display: block;
            animation: tooltipFadeIn 0.2s ease;
        }

        /* Gear Context Menu */
        .gear-context-menu {
            position: fixed;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.98) 100%);
            border: 2px solid rgba(99, 102, 241, 0.6);
            border-radius: 12px;
            padding: 8px;
            z-index: 20000;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(15px);
            display: none;
        }

        .gear-context-menu.show {
            display: block;
            animation: contextMenuFadeIn 0.15s ease;
        }

        .gear-context-menu-item {
            padding: 12px 20px;
            cursor: pointer;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            white-space: nowrap;
        }

        .gear-context-menu-item:hover {
            background: rgba(99, 102, 241, 0.2);
            transform: translateX(4px);
        }

        .gear-context-menu-item.unequip {
            color: #ef4444;
        }

        .gear-context-menu-item.bless {
            color: #a855f7;
        }

        @keyframes contextMenuFadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        .comparison-container {
            display: flex;
            gap: 25px;
        }

        .comparison-side {
            flex: 1;
        }

        .comparison-divider {
            width: 2px;
            background: linear-gradient(to bottom, transparent, #71717a, transparent);
            animation: pulse-divider 2s ease-in-out infinite;
        }

        @keyframes pulse-divider {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .tooltip-header {
            font-weight: 700;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(99, 102, 241, 0.3);
            text-align: center;
            font-size: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'Orbitron', sans-serif;
        }

        .tooltip-header.common { color: #94a3b8; }
        .tooltip-header.uncommon {
            color: #10b981;
            text-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
        }
        .tooltip-header.rare {
            color: #3b82f6;
            text-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }
        .tooltip-header.epic {
            color: #a855f7;
            text-shadow: 0 0 15px rgba(139, 92, 246, 0.5);
        }
        .tooltip-header.legendary {
    color: #f59e0b;
    animation: legendary-pulse 2s ease-in-out infinite;
    text-shadow: 0 0 20px rgba(245, 158, 11, 0.8);
}

.tooltip-header.mythic {
    color: #c910a7;
    animation: mythic-pulse 2s ease-in-out infinite;
    text-shadow: 0 0 25px rgba(201, 16, 167, 0.9);
}

@keyframes mythic-pulse {
    0%, 100% {
        text-shadow: 0 0 25px rgba(201, 16, 167, 0.9);
        transform: scale(1);
    }
    50% {
        text-shadow: 0 0 35px rgba(201, 16, 167, 1), 0 0 45px rgba(201, 16, 167, 0.6);
        transform: scale(1.06);
    }
}

@keyframes legendary-pulse {
            0%, 100% {
                text-shadow: 0 0 20px rgba(245, 158, 11, 0.8);
                transform: scale(1);
            }
            50% {
                text-shadow: 0 0 30px rgba(245, 158, 11, 1), 0 0 40px rgba(245, 158, 11, 0.5);
                transform: scale(1.05);
            }
        }
@keyframes chest-shake {
    0%, 100% { transform: rotate(0deg) scale(1); }
    25% { transform: rotate(-5deg) scale(1.05); }
    50% { transform: rotate(5deg) scale(1.1); }
    75% { transform: rotate(-5deg) scale(1.05); }
}

@keyframes chest-open {
    0% {
        transform: scale(1) rotate(0deg);
        opacity: 1;
    }
    50% {
        transform: scale(1.3) rotate(10deg);
        opacity: 0.8;
    }
    100% {
        transform: scale(0) rotate(90deg);
        opacity: 0;
    }
}

@keyframes blessing-burst {
    0% {
        transform: scale(0.8);
        opacity: 0;
    }
    50% {
        transform: scale(1.3) rotate(180deg);
        opacity: 1;
        filter: brightness(2) drop-shadow(0 0 30px rgba(168, 85, 247, 1));
    }
    100% {
        transform: scale(1) rotate(360deg);
        opacity: 1;
        filter: brightness(1) drop-shadow(0 0 10px rgba(168, 85, 247, 0.6));
    }
}

@keyframes blessing-particles {
    0% {
        transform: translateY(0) scale(1);
        opacity: 1;
    }
    100% {
        transform: translateY(-100px) scale(0);
        opacity: 0;
    }
}

@keyframes blessing-glow-pulse {
    0%, 100% {
        box-shadow: 0 0 20px rgba(168, 85, 247, 0.4), 0 0 40px rgba(168, 85, 247, 0.2);
    }
    50% {
        box-shadow: 0 0 40px rgba(168, 85, 247, 0.8), 0 0 80px rgba(168, 85, 247, 0.4);
    }
}

.blessing-animation {
    animation: blessing-burst 0.8s ease-out;
}

.blessing-glow {
    animation: blessing-glow-pulse 0.6s ease-in-out;
}

        .tooltip-stats {
            margin-top: 10px;
        }

        .tooltip-stat {
            margin: 6px 0;
            color: #e2e8f0;
            padding: 4px 8px;
            background: rgba(99, 102, 241, 0.05);
            border-radius: 6px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .tooltip-stat:hover {
            background: rgba(99, 102, 241, 0.1);
            transform: translateX(2px);
        }

        .enemy-tooltip {
            position: absolute;
            background: linear-gradient(135deg, rgba(220, 38, 38, 0.1) 0%, rgba(15, 23, 42, 0.98) 100%);
            border: 2px solid rgba(239, 68, 68, 0.5);
            border-radius: 12px;
            padding: 16px;
            font-size: 13px;
            z-index: 25000;
            pointer-events: none;
            min-width: 220px;
            display: none;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .enemy-tooltip.show {
            display: block;
            animation: tooltipFadeIn 0.2s ease;
        }

        #summary-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.95) 0%, rgba(0, 0, 0, 0.98) 100%);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(20px);
        }

        #summary-overlay.show {
            display: flex;
            animation: fadeIn 0.3s ease;
        }

        #summary-panel {
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(6, 9, 23, 0.98) 100%);
            border: 3px solid;
            border-image: linear-gradient(135deg, #71717a, #52525b) 1;
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            animation: slideUp 0.4s ease;
        }

        @keyframes slideUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        #summary-panel.victory {
            border-image: linear-gradient(135deg, #10b981, #34d399) 1;
        }

        #summary-panel.defeat {
            border-image: linear-gradient(135deg, #ef4444, #dc2626) 1;
        }

        .summary-title {
            font-size: 42px;
            font-weight: 800;
            text-align: center;
            margin-bottom: 30px;
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            letter-spacing: 4px;
        }

        .summary-title.victory {
            background: linear-gradient(135deg, #10b981, #34d399);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 40px rgba(16, 185, 129, 0.5);
        }

        .summary-title.defeat {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 40px rgba(239, 68, 68, 0.5);
        }

        .summary-stats {
            background: rgba(15, 23, 42, 0.5);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid rgba(99, 102, 241, 0.2);
        }

        .summary-stat-row {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid rgba(99, 102, 241, 0.1);
            font-size: 16px;
            transition: all 0.2s ease;
        }

        .summary-stat-row:hover {
            background: rgba(99, 102, 241, 0.05);
            padding-left: 10px;
            margin: 0 -10px;
        }

        .summary-stat-row:last-child {
            border-bottom: none;
        }

        .summary-stat-label {
            color: #94a3b8;
            font-weight: 500;
        }

        .summary-stat-value {
            color: #e2e8f0;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
        }

        .summary-button {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, #71717a, #52525b);
            color: #fff;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(99, 102, 241, 0.4);
            position: relative;
            overflow: hidden;
        }

        .summary-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .summary-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 30px rgba(99, 102, 241, 0.6);
        }

        .summary-button:hover::before {
            left: 100%;
        }

        .summary-button.victory {
            background: linear-gradient(135deg, #10b981, #34d399);
            box-shadow: 0 4px 20px rgba(16, 185, 129, 0.4);
        }

        .summary-button.victory:hover {
            box-shadow: 0 6px 30px rgba(16, 185, 129, 0.6);
        }

        button {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.9) 0%, rgba(15, 23, 42, 0.9) 100%);
            color: #e2e8f0;
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        button::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(99, 102, 241, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.3s ease, height 0.3s ease;
        }

        button:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(51, 65, 85, 0.9) 0%, rgba(30, 41, 59, 0.9) 100%);
            border-color: rgba(99, 102, 241, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.2);
        }

        button:hover:not(:disabled)::after {
            width: 100%;
            height: 100%;
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        #reset-account-controls-btn:hover {
            background: linear-gradient(135deg, #dc2626, #b91c1c) !important;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.5) !important;
        }

        button.active {
            background: linear-gradient(135deg, #10b981, #34d399);
            border-color: #10b981;
            color: #fff;
        }



        .loot-item {
    border: 2px solid rgba(99, 102, 241, 0.3);
    border-radius: 10px;
    padding: 8px;
    margin-bottom: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 13px;
    position: relative;
    overflow: hidden;
    line-height: 1.3;
}

.loot-item:hover {
    transform: translateX(5px);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

.loot-item.common {
    background: rgba(148, 163, 184, 0.25);
    border-color: #94a3b8;
}
.loot-item.uncommon {
    background: rgba(16, 185, 129, 0.25);
    border-color: #10b981;
}
.loot-item.rare {
    background: rgba(59, 130, 246, 0.25);
    border-color: #3b82f6;
}
.loot-item.epic {
    background: rgba(168, 85, 247, 0.25);
    border-color: #a855f7;
}
.loot-item.legendary {
    background: rgba(245, 158, 11, 0.3);
    border-color: #f59e0b;
}
.loot-item.mythic {
    background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(220, 38, 38, 0.1));
    border-color: #c910a7;
    box-shadow: 0 0 25px rgba(239, 68, 68, 0.6);
    border-width: 3px;
}

.equipment-name.mythic {
    color: #c910a7;
    font-weight: 700;
}

@keyframes mythic-glow {
    0%, 100% { box-shadow: 0 0 20px rgba(239, 68, 68, 0.5); }
    50% { box-shadow: 0 0 30px rgba(239, 68, 68, 0.8); }
}

        /* === KEYSTONE VISUAL STYLES === */

        .keystone-icon {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 8px;
            transition: transform 0.2s;
        }

        .keystone-icon:hover {
            transform: scale(1.05);
        }

        .keystone-icon::before {
            font-size: 28px;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }

        /* Tank Keystones */
        .keystone-icon.wardens-aegis {
            background: radial-gradient(circle at 30% 30%, #bae6fd, #0ea5e9, #0369a1);
            border: 3px solid #7dd3fc;
            box-shadow: 0 0 15px rgba(125, 211, 252, 0.4);
        }
        .keystone-icon.wardens-aegis::before { content: 'üõ°Ô∏è'; }

        .keystone-icon.berserkers-pact {
            background: radial-gradient(circle at 30% 30%, #ef4444, #991b1b, #450a0a);
            border: 3px solid #dc2626;
            box-shadow: 0 0 15px rgba(220, 38, 38, 0.4);
        }
        .keystone-icon.berserkers-pact::before { content: '‚öîÔ∏è'; }

        .keystone-icon.earthshakers-resolve {
            background: radial-gradient(circle at 30% 30%, #a8a29e, #57534e, #292524);
            border: 3px solid #78716c;
            box-shadow: 0 0 15px rgba(251, 146, 60, 0.3);
        }
        .keystone-icon.earthshakers-resolve::before {
            content: '‚úä';
            filter: drop-shadow(0 2px 4px rgba(251, 146, 60, 0.6));
        }

        /* Healer Keystones */
        .keystone-icon.arcanists-conduit {
            background: radial-gradient(circle at 30% 30%, #67e8f9, #06b6d4, #0e7490);
            border: 3px solid #22d3ee;
            box-shadow: 0 0 15px rgba(6, 182, 212, 0.4);
        }
        .keystone-icon.arcanists-conduit::before { content: 'üíé'; }

        .keystone-icon.martyrs-blessing {
            background: radial-gradient(circle at 30% 30%, #fde68a, #f59e0b, #b45309);
            border: 3px solid #fbbf24;
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.4);
        }
        .keystone-icon.martyrs-blessing::before { content: '‚ú®'; }

        .keystone-icon.phoenix-heart {
            background: radial-gradient(circle at 30% 30%, #fed7aa, #f97316, #c2410c);
            border: 3px solid #fb923c;
            box-shadow: 0 0 15px rgba(249, 115, 22, 0.5);
        }
        .keystone-icon.phoenix-heart::before { content: 'üî•'; }

        /* Mage Keystones */
        .keystone-icon.winters-wrath {
            background: radial-gradient(circle at 30% 30%, #f0f9ff, #7dd3fc, #0369a1);
            border: 3px solid #bae6fd;
            box-shadow: 0 0 15px rgba(186, 230, 253, 0.5);
        }
        .keystone-icon.winters-wrath::before { content: '‚ùÑÔ∏è'; }

        .keystone-icon.voidwalkers-gift {
            background: radial-gradient(circle at 30% 30%, #8b5cf6, #6d28d9, #1e1b4b);
            border: 3px solid #7c3aed;
            box-shadow: 0 0 15px rgba(124, 58, 237, 0.5);
        }
        .keystone-icon.voidwalkers-gift::before { content: 'üåå'; }

        .keystone-icon.timeweavers-paradox {
            background: radial-gradient(circle at 30% 30%, #fcd34d, #f59e0b, #78350f);
            border: 3px solid #fbbf24;
            box-shadow: 0 0 15px rgba(245, 158, 11, 0.4);
        }
        .keystone-icon.timeweavers-paradox::before { content: '‚è∞'; }

        /* Rogue Keystones */
        .keystone-icon.assassins-mark {
            background: radial-gradient(circle at 30% 30%, #a855f7, #7e22ce, #3b0764);
            border: 3px solid #9333ea;
            box-shadow: 0 0 15px rgba(147, 51, 234, 0.4);
        }
        .keystone-icon.assassins-mark::before { content: 'üéØ'; }

        .keystone-icon.shadow-dancer {
            background: radial-gradient(circle at 30% 30%, #52525b, #27272a, #09090b);
            border: 3px solid #3f3f46;
            box-shadow: 0 0 15px rgba(124, 58, 237, 0.3);
        }
        .keystone-icon.shadow-dancer::before {
            content: 'üë§';
            filter: drop-shadow(0 2px 4px rgba(168, 85, 247, 0.6));
        }

        .keystone-icon.serpents-venom {
            background: radial-gradient(circle at 30% 30%, #6ee7b7, #10b981, #065f46);
            border: 3px solid #34d399;
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.4);
        }
        .keystone-icon.serpents-venom::before { content: 'üêç'; }

        /* Archer Keystones */
        .keystone-icon.hawkeyes-precision {
            background: radial-gradient(circle at 30% 30%, #fde68a, #f59e0b, #92400e);
            border: 3px solid #fbbf24;
            box-shadow: 0 0 15px rgba(245, 158, 11, 0.5);
        }
        .keystone-icon.hawkeyes-precision::before { content: 'üéØ'; }

        .keystone-icon.rapid-quiver {
            background: radial-gradient(circle at 30% 30%, #86efac, #22c55e, #14532d);
            border: 3px solid #4ade80;
            box-shadow: 0 0 15px rgba(34, 197, 94, 0.4);
        }
        .keystone-icon.rapid-quiver::before { content: 'üí®'; }

        .keystone-icon.hunters-focus {
            background: radial-gradient(circle at 30% 30%, #fca5a5, #dc2626, #7f1d1d);
            border: 3px solid #f87171;
            box-shadow: 0 0 15px rgba(220, 38, 38, 0.4);
        }
        .keystone-icon.hunters-focus::before { content: 'üîç'; }

        /* Paladin Keystones */
        .keystone-icon.holy-avenger {
            background: radial-gradient(circle at 30% 30%, #fef3c7, #fbbf24, #78350f);
            border: 3px solid #fcd34d;
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.6);
        }
        .keystone-icon.holy-avenger::before { content: '‚ú®'; }

        .keystone-icon.divine-guardian {
            background: radial-gradient(circle at 30% 30%, #ddd6fe, #8b5cf6, #4c1d95);
            border: 3px solid #a78bfa;
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.5);
        }
        .keystone-icon.divine-guardian::before { content: 'üõ°Ô∏è'; }

        .keystone-icon.righteous-fury {
            background: radial-gradient(circle at 30% 30%, #fed7aa, #ea580c, #7c2d12);
            border: 3px solid #fb923c;
            box-shadow: 0 0 15px rgba(234, 88, 12, 0.5);
        }
        .keystone-icon.righteous-fury::before { content: '‚ö°'; }

        /* Empty keystone slot */
        .keystone-icon.empty {
            background: rgba(30, 41, 59, 0.6);
            border: 2px dashed rgba(100, 116, 139, 0.3);
        }
        .keystone-icon.empty::before {
            content: '?';
            font-size: 28px;
            color: #475569;
        }

        /* Rarity border overrides */
        .keystone-icon.rarity-common {
            border: 3px solid #94a3b8;
            box-shadow: 0 0 15px rgba(148, 163, 184, 0.4);
        }

        .keystone-icon.rarity-uncommon {
            border: 3px solid #10b981;
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.5);
        }

        .keystone-icon.rarity-rare {
            border: 3px solid #3b82f6;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
        }

        .keystone-icon.rarity-epic {
            border: 3px solid #a855f7;
            box-shadow: 0 0 15px rgba(168, 85, 247, 0.5);
        }

        .keystone-icon.rarity-legendary {
            border: 3px solid #f59e0b;
            box-shadow: 0 0 15px rgba(245, 158, 11, 0.6);
        }

        @keyframes legendary-shine {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .loot-item-actions {
    display: flex;
    gap: 6px;
    margin-top: 8px;
}

.loot-item-btn {
    flex: 1;
    padding: 4px 8px;
    font-size: 10px;
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.9) 0%, rgba(15, 23, 42, 0.9) 100%);
            color: #e2e8f0;
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 600;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .loot-item-btn:hover {
            transform: translateY(-1px);
        }

        .loot-item-btn.equip-btn {
            background: linear-gradient(135deg, #10b981, #059669);
            border-color: #10b981;
        }

        .loot-item-btn.equip-btn:hover {
            box-shadow: 0 2px 10px rgba(16, 185, 129, 0.4);
        }

        .loot-item-btn.sell-btn {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            border-color: #ef4444;
        }

        .loot-item-btn.sell-btn:hover {
            box-shadow: 0 2px 10px rgba(239, 68, 68, 0.4);
        }

#log-container {
    background: rgba(15, 23, 42, 0.3);
    border-radius: 8px;
    padding: 15px;
height: 97.2%;
    overflow: hidden;
    font-size: 15px;
    font-family: 'Rajdhani', sans-serif;
    display: flex;
    flex-direction: column;
    color: #f4f4f5; /* Change from #e4e4e7 to brighter white */
}

        #log-container::-webkit-scrollbar {
            width: 6px;
        }

        #log-container::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.5);
            border-radius: 3px;
        }

        #log-container::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #71717a, #52525b);
            border-radius: 3px;
        }

		.log-entry {
    margin-bottom: 8px;
    padding: 6px 10px;
    background: rgba(15, 23, 42, 0.2);
    border-radius: 4px;
    border-left: 2px solid transparent;
    transition: all 0.2s ease;
    line-height: 1.4;
    color: #f4f4f5 !important;
    opacity: 1;
}


        .log-entry:hover {
            background: rgba(99, 102, 241, 0.05);
        }

        .log-entry.damage {
            color: #ef4444;
            border-left-color: #ef4444;
        }
        .log-entry.heal {
            color: #10b981;
            border-left-color: #10b981;
        }
        .log-entry.loot {
            color: #f59e0b;
            border-left-color: #f59e0b;
        }
        .log-entry.room {
            color: #52525b;
            border-left-color: #52525b;
        }

        .floating-text {
            position: absolute;
            font-weight: 700;
            font-size: 18px;
            pointer-events: none;
            animation: float-up 1s ease-out forwards;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
            z-index: 100;
            font-family: 'Orbitron', sans-serif;
        }

        @keyframes float-up {
            0% {
                opacity: 1;
                transform: translate(-50%, 0) scale(1);
            }
            50% {
                transform: translate(-50%, -20px) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -40px) scale(0.8);
            }
        }

        .damage-text {
            color: #ef4444;
            text-shadow: 0 0 10px rgba(239, 68, 68, 0.8);
        }
        .heal-text {
            color: #10b981;
            text-shadow: 0 0 10px rgba(16, 185, 129, 0.8);
        }
        .gold-text {
            color: #f59e0b;
            text-shadow: 0 0 10px rgba(245, 158, 11, 0.8);
        }

        /* Banner Dungeon Selector */
        #dungeon-banner-selector {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #0a0a0a url('darkervaultbackground.png') center/100% 100% no-repeat;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(20px);
        }

        #dungeon-banner-container {
            display: flex;
            gap: 15px;
            height: 600px;
            position: relative;
            padding: 0 50px;
        }

        .dungeon-banner {
            width: 325px;
            height: 100%;
            position: relative;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.3s ease;
            border: none;
        }

        .dungeon-banner:hover {
            transform: scale(1.05);
            z-index: 10;
        }

        .dungeon-banner img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: all 0.3s ease;
        }

        .dungeon-banner:hover img {
            transform: scale(1.05);
            filter: brightness(1.2);
        }

        .dungeon-banner-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, transparent 100%);
            padding: 20px 10px;
            transition: all 0.3s ease;
        }

        .dungeon-banner:hover .dungeon-banner-overlay {
            padding-bottom: 30px;
        }

        .dungeon-banner-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: 700;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 8px;
            text-align: center;
        }

        .dungeon-banner-desc {
            font-size: 11px;
            color: #94a3b8;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .dungeon-banner:hover .dungeon-banner-desc {
            opacity: 1;
        }

        #select-dungeon-title {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Orbitron', sans-serif;
            font-size: 32px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 4px;
            color: #94a3b8;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.8);
        }

        /* Custom scrollbar for all scrollable elements */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.5);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #71717a, #52525b);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #52525b, #71717a);
        }

        /* Cache sub-tab styling */
        .cache-sub-tab:hover,
        .keystone-sub-tab:hover,
        .rune-char-tab:hover {
            background: rgba(99, 102, 241, 0.1);
            color: #e2e8f0;
        }

        .cache-sub-tab.active,
        .keystone-sub-tab.active,
        .rune-char-tab.active {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: #fff;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
        }

        /* Compact vault key card */
        .vault-key-card {
    background: linear-gradient(135deg, rgba(245, 158, 11, 0.15), rgba(251, 191, 36, 0.1));
    border: 2px solid #f59e0b;
    border-radius: 8px;
    padding: 6px;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
    text-align: center;
}

        .vault-key-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(245, 158, 11, 0.4);
            border-color: #fbbf24;
        }

        .vault-key-card::before {
    content: 'üîë';
    font-size: 20px;
    display: block;
    margin-bottom: 3px;
    filter: drop-shadow(0 2px 4px rgba(245, 158, 11, 0.5));
}

.vault-key-card[style*="border-color: rgb(59, 130, 246)"]::before,
.vault-key-card[style*="border-color: #3b82f6"]::before {
    filter: drop-shadow(0 2px 4px rgba(59, 130, 246, 0.5));
}



        .key-level {
            font-size: 20px;
            font-weight: 800;
            color: #fbbf24;
            font-family: 'Orbitron', sans-serif;
            margin-bottom: 4px;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }

        .key-warning {
            font-size: 9px;
            color: #ef4444;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .key-reward {
            font-size: 8px;
            color: #10b981;
            font-weight: 500;
            margin-bottom: 8px;
        }

        .key-button {
            width: 100%;
            padding: 6px;
            background: linear-gradient(135deg, #f59e0b, #fbbf24);
            color: #000;
            border: none;
            border-radius: 6px;
            font-size: 9px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Orbitron', sans-serif;
        }

        .key-button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.6);
        }

        /* Compact chest card */
.chest-card {
    background: linear-gradient(135deg, rgba(245, 158, 11, 0.15), rgba(251, 191, 36, 0.1));
    border: 2px solid #f59e0b;
    border-radius: 8px;
    padding: 10px;
    transition: all 0.2s ease;
    position: relative;
    overflow: hidden;
    text-align: center;
    min-width: 95px;
}

		.chest-card.mythic-chest {
    background: linear-gradient(135deg, rgba(201, 16, 167, 0.25), rgba(168, 85, 247, 0.15));
    border: 2px solid #c910a7;
    box-shadow: 0 0 15px rgba(201, 16, 167, 0.4);
}

.chest-card.mythic-chest::before {
    display: none;
}

.chest-card.mythic-chest .chest-level {
    color: #e879f9;
    text-shadow: 0 0 10px rgba(201, 16, 167, 0.8);
}



        .chest-card:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 10px rgba(245, 158, 11, 0.3);
}


        .chest-card::before {
    display: none;
}


        .chest-level {
    font-size: 14px;
    font-weight: 800;
    color: #fbbf24;
    font-family: 'Orbitron', sans-serif;
    margin-bottom: 6px;
    text-shadow: 0 0 10px rgba(251, 191, 36, 0.6);
}
        .chest-odds {
    font-size: 12px;
    font-weight: 800;
    margin-bottom: 8px;
    line-height: 1.5;
    letter-spacing: 0.8px;
    text-shadow: 0 1px 4px rgba(0, 0, 0, 0.9);
}

.chest-actions {
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.chest-btn {
    width: 100%;
    padding: 6px;
    font-size: 10px;
    font-weight: 800;
    font-family: 'Orbitron', sans-serif;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.15s ease;
    line-height: 1.4;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
}

.chest-btn.open {
    background: linear-gradient(135deg, #10b981, #059669);
    color: #fff;
}

.chest-btn.open:hover:not(:disabled) {
    background: linear-gradient(135deg, #059669, #047857);
    box-shadow: 0 0 8px rgba(16, 185, 129, 0.5);
}

.chest-btn.open:disabled {
    opacity: 0.3;
    cursor: not-allowed;
}

.chest-btn.sell {
    background: linear-gradient(135deg, #ef4444, #dc2626);
    color: #fff;
}

.chest-btn.sell:hover {
    background: linear-gradient(135deg, #dc2626, #b91c1c);
    box-shadow: 0 0 8px rgba(239, 68, 68, 0.5);
}

        /* Dungeon card updates */
        .dungeon-card {
    background: linear-gradient(135deg, rgba(30, 41, 59, 0.6) 0%, rgba(15, 23, 42, 0.6) 100%);
    border: 2px solid rgba(99, 102, 241, 0.3);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

        .dungeon-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(99, 102, 241, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .dungeon-card:hover {
            background: linear-gradient(135deg, rgba(51, 65, 85, 0.7) 0%, rgba(30, 41, 59, 0.7) 100%);
            border-color: rgba(99, 102, 241, 0.5);
            transform: translateX(5px);
            box-shadow: 0 4px 20px rgba(99, 102, 241, 0.2);
        }

        .dungeon-card:hover::after {
            left: 100%;
        }
.dungeon-card-title {
            font-weight: 700;
            margin-bottom: 6px;
            font-size: 15px;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 0.5px;
        }

        .dungeon-card-loot {
            font-size: 12px;
            color: #94a3b8;
            font-weight: 500;
        }
.dungeon-card.umbral { border-left: 4px solid #a855f7; }
.dungeon-card.everfall { border-left: 4px solid #10b981; }
.dungeon-card.stoneforge { border-left: 4px solid #ef4444; }
.dungeon-card.vault { border-left: 4px solid #f59e0b; }
.dungeon-card.runetrial { border-left: 4px solid #3b82f6; }

/* === CHARACTER SELECT SCREEN === */
#character-select-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: linear-gradient(135deg, rgba(10, 14, 39, 0.85) 0%, rgba(21, 25, 53, 0.85) 100%),
                url('everfall.png');
    background-size: cover;
    background-position: center;
    background-attachment: fixed;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 100000;
    overflow-y: auto;
    padding: 20px 15px;
}

#character-select-overlay.hidden {
    display: none !important;
}

#character-select-overlay h1 {
    font-family: 'Orbitron', sans-serif;
    font-size: 36px;
    font-weight: 800;
    background: linear-gradient(135deg, #6366f1, #a855f7, #ec4899);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-align: center;
    margin-bottom: 10px;
    letter-spacing: 3px;
    text-shadow: 0 0 40px rgba(99, 102, 241, 0.5);
}

#character-select-overlay .subtitle {
    font-size: 14px;
    color: #a1a1aa;
    text-align: center;
    margin-bottom: 20px;
    font-weight: 500;
}

.character-select-grid {
    display: grid;
    grid-template-columns: repeat(3, minmax(220px, 1fr));
    gap: 15px;
    max-width: 1200px;
    width: 100%;
    margin-bottom: 20px;
}

.char-select-card {
    background: linear-gradient(135deg, rgba(30, 41, 59, 0.9) 0%, rgba(15, 23, 42, 0.9) 100%);
    border: 2px solid rgba(99, 102, 241, 0.3);
    border-radius: 16px;
    padding: 15px;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.char-select-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(99, 102, 241, 0.2), transparent);
    transition: left 0.5s;
}

.char-select-card:hover::before {
    left: 100%;
}

.char-select-card:hover {
    border-color: rgba(99, 102, 241, 0.8);
    box-shadow: 0 10px 40px rgba(99, 102, 241, 0.4);
    transform: translateY(-10px);
}

.char-select-card.selected {
    border: 3px solid #6366f1;
    box-shadow: 0 0 30px rgba(99, 102, 241, 0.6);
    background: linear-gradient(135deg, rgba(99, 102, 241, 0.2) 0%, rgba(30, 41, 59, 0.9) 100%);
}

.char-select-icon {
    width: 55px;
    height: 55px;
    margin: 0;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 35px;
    background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(168, 85, 247, 0.2));
    border-radius: 50%;
    border: 2px solid rgba(99, 102, 241, 0.3);
    transition: transform 0.3s;
    overflow: hidden;
}

.char-select-icon img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.char-select-card:hover .char-select-icon {
    transform: scale(1.15);
}

.char-select-name {
    font-family: 'Orbitron', sans-serif;
    font-size: 20px;
    font-weight: 700;
    text-align: left;
    margin-bottom: 2px;
    color: #f1f5f9;
}

.char-select-role {
    text-align: left;
    font-size: 10px;
    color: #6366f1;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    margin-bottom: 0;
}

.char-select-desc {
    font-size: 11px;
    color: #cbd5e1;
    line-height: 1.4;
    text-align: left;
    margin-bottom: 10px;
}

.char-select-stats {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 6px;
}

.char-stat-item {
    background: rgba(99, 102, 241, 0.1);
    padding: 4px 8px;
    border-radius: 6px;
    font-size: 11px;
    display: flex;
    justify-content: space-between;
}

.char-stat-label {
    color: #94a3b8;
}

.char-stat-value {
    color: #f1f5f9;
    font-weight: 700;
}

.start-adventure-btn {
    padding: 15px 45px;
    font-size: 18px;
    font-weight: 700;
    font-family: 'Orbitron', sans-serif;
    background: linear-gradient(135deg, #6366f1, #a855f7);
    color: white;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    letter-spacing: 2px;
    text-transform: uppercase;
    box-shadow: 0 10px 30px rgba(99, 102, 241, 0.4);
    transition: all 0.3s;
    margin-top: 15px;
}

.start-adventure-btn:hover:not(:disabled) {
    transform: translateY(-5px);
    box-shadow: 0 15px 40px rgba(99, 102, 241, 0.6);
}

.start-adventure-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Party Slot Indicators */
.party-slot {
    background: linear-gradient(135deg, rgba(30, 41, 59, 0.8) 0%, rgba(15, 23, 42, 0.8) 100%);
    border: 2px solid rgba(99, 102, 241, 0.3);
    border-radius: 10px;
    padding: 10px 15px;
    min-width: 110px;
    text-align: center;
    transition: all 0.3s;
}

.party-slot.filled {
    border-color: #10b981;
    box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
}

.party-slot .slot-number {
    font-size: 10px;
    color: #94a3b8;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 6px;
}

.party-slot .slot-icon {
    font-size: 28px;
    margin-bottom: 4px;
    width: 60px;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding-left: 15px;
}

.party-slot .slot-icon img {
    width: 45px;
    height: 45px;
    object-fit: contain;
}

.party-slot .slot-name {
    font-size: 11px;
    font-weight: 700;
    color: #cbd5e1;
    font-family: 'Orbitron', sans-serif;
}

.party-slot.filled .slot-name {
    color: #10b981;
}

.char-select-card.used {
    opacity: 0.5;
    pointer-events: none;
    position: relative;
}

.char-select-card.used::after {
    content: '‚úì Âú®Èòü‰ºç‰∏≠';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(16, 185, 129, 0.9);
    color: white;
    padding: 8px 16px;
    border-radius: 8px;
    font-weight: 700;
    font-size: 14px;
    letter-spacing: 1px;
}

/* === DRAG REGION (for Electron window movement) === */
#drag-region {
    -webkit-app-region: drag;
    position: fixed;
    top: 0;
    left: 0;
    height: 40px;          /* draggable height */
    width: 100%;
    z-index: 99999;
    pointer-events: auto;
}

.no-drag {
    -webkit-app-region: no-drag;
}

/* Exit Menu Styles */

#exit-dialog {
    display: flex;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85) url('darkervaultbackground.png') center/cover no-repeat;
    background-blend-mode: darken;
    backdrop-filter: blur(12px);
    z-index: 10000;
    justify-content: center;
    align-items: center;
}

#exit-dialog .dialog-content {
    background: url('menu.png') center/cover no-repeat;
    padding: 50px 60px;
    border-radius: 20px;
    text-align: center;
    box-shadow: 0 30px 80px rgba(0, 0, 0, 0.9);
    max-width: 500px;
    width: 90%;
    position: relative;
    overflow: visible;
    border: none;
}

#exit-dialog .icon-container {
    width: 80px;
    height: 80px;
    margin: 0 auto 25px;
    background: linear-gradient(135deg, #2dd4bf 0%, #0d9488 100%);
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 10px 30px rgba(45, 212, 191, 0.4);
}

#exit-dialog .icon-container svg {
    width: 40px;
    height: 40px;
    stroke: white;
    stroke-width: 2;
    fill: none;
}

#exit-dialog h2 {
    color: #ffffff;
    margin-bottom: 15px;
    font-size: 32px;
    font-weight: 700;
    letter-spacing: -0.5px;
}

#exit-dialog .subtitle {
    color: #a0a0b8;
    font-size: 16px;
    margin-bottom: 35px;
    line-height: 1.5;
}

#exit-dialog .option-container {
    background: transparent;
    border: none;
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 30px;
    box-shadow: none;
}

#exit-dialog .fullscreen-toggle {
    display: flex;
    align-items: center;
    justify-content: space-between;
    cursor: pointer;
    user-select: none;
}

#exit-dialog .toggle-label {
    color: #ffffff;
    font-size: 16px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 10px;
}

#exit-dialog .toggle-label svg {
    width: 20px;
    height: 20px;
    stroke: #2dd4bf;
    fill: none;
    stroke-width: 2;
}

#exit-dialog .switch {
    position: relative;
    width: 60px;
    height: 32px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 32px;
    cursor: pointer;
    border: 1px solid rgba(255, 255, 255, 0.2);
    transition: all 0.3s ease;
}

#exit-dialog .switch.active {
    background: linear-gradient(135deg, #2dd4bf 0%, #0d9488 100%);
    border-color: transparent;
}

#exit-dialog .switch-handle {
    position: absolute;
    top: 3px;
    left: 3px;
    width: 24px;
    height: 24px;
    background: white;
    border-radius: 50%;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    transition: transform 0.3s ease;
}

#exit-dialog .switch.active .switch-handle {
    transform: translateX(28px);
}

#exit-dialog .button-container {
    display: flex;
    gap: 15px;
    margin-top: 30px;
}

#exit-dialog .button-container button {
    flex: 1;
    background: none;
    border: none;
    padding: 0;
    cursor: pointer;
    transition: opacity 0.2s;
}

#exit-dialog .button-container button:hover {
    opacity: 0.8;
}

#exit-dialog .button-container button img {
    width: 100%;
    height: auto;
    display: block;
}

#exit-dialog .community-buttons {
    display: flex;
    gap: 15px;
    margin-top: 25px;
    justify-content: center;
    align-items: center;
}

#exit-dialog .community-btn {
    background: none;
    border: none;
    padding: 0;
    cursor: pointer;
    transition: opacity 0.2s;
}

#exit-dialog .community-btn:hover {
    opacity: 0.8;
}

#exit-dialog .community-btn img {
    width: 64px;
    height: 64px;
    object-fit: contain;
    display: block;
}

#reset-account-btn:hover {
    background: linear-gradient(135deg, #ef4444, #b91c1c) !important;
    border-color: #fca5a5 !important;
    transform: scale(1.02);
    box-shadow: 0 6px 20px rgba(239, 68, 68, 0.5);
}

#mirror-toggle-container {
    position: absolute;
    top: 20px;
    left: 20px;
    z-index: 10;
    display: flex;
    align-items: center;
    gap: 10px;
    background: linear-gradient(135deg, rgba(30, 41, 59, 0.95) 0%, rgba(15, 23, 42, 0.95) 100%);
    padding: 10px 16px;
    border-radius: 8px;
    border: 1px solid rgba(99, 102, 241, 0.4);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    cursor: pointer;
    user-select: none;
    transition: all 0.2s ease;
}

#mirror-toggle-container:hover {
    border-color: rgba(99, 102, 241, 0.6);
    background: linear-gradient(135deg, rgba(30, 41, 59, 1) 0%, rgba(15, 23, 42, 1) 100%);
}

#mirror-toggle-container input[type="checkbox"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
    accent-color: #6366f1;
}

#mirror-toggle-container label {
    color: #e2e8f0;
    font-size: 14px;
    font-weight: 600;
    font-family: 'Orbitron', sans-serif;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

#resize-handle {
    position: absolute;
    top: -8px;
    left: 50%;
    transform: translateX(-50%);
    width: 200px;
    height: 16px;
    cursor: ns-resize;
    z-index: 100;
    background: linear-gradient(135deg, rgba(99, 102, 241, 0.4) 0%, rgba(139, 92, 246, 0.4) 100%);
    border-radius: 8px 8px 0 0;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid rgba(99, 102, 241, 0.5);
    border-bottom: none;
    box-shadow: 0 -2px 8px rgba(99, 102, 241, 0.3);
    transition: all 0.2s ease;
}

#resize-handle::before {
    content: '‚ãÆ‚ãÆ‚ãÆ';
    color: rgba(255, 255, 255, 0.6);
    font-size: 16px;
    letter-spacing: 4px;
    font-weight: bold;
    line-height: 1;
}

#resize-handle:hover {
    background: linear-gradient(135deg, rgba(99, 102, 241, 0.7) 0%, rgba(139, 92, 246, 0.7) 100%);
    height: 20px;
    top: -10px;
    box-shadow: 0 -4px 16px rgba(99, 102, 241, 0.5);
}

#resize-handle:hover::before {
    color: rgba(255, 255, 255, 0.9);
}

#resize-handle.dragging {
    background: linear-gradient(135deg, rgba(99, 102, 241, 0.9) 0%, rgba(139, 92, 246, 0.9) 100%);
    height: 24px;
    top: -12px;
    width: 300px;
}

#resize-handle.dragging::before {
    color: rgba(255, 255, 255, 1);
}

    </style>
<script src="firebase-app-compat.js"></script>
<script src="firebase-firestore-compat.js"></script>
</head>
<body>
<script src="chs.js"></script>
<script src="core.js"></script>
    <!-- CHARACTER SELECT SCREEN -->
    <div id="character-select-overlay">
        <h1>BUILD YOUR PARTY</h1>

        <!-- Party Slots Display -->
        <div style="display: flex; gap: 12px; justify-content: center; margin-bottom: 15px; flex-wrap: wrap;">
            <div class="party-slot" data-slot="0">
                <div class="slot-number">Slot 1 - Front</div>
                <div class="slot-icon">?</div>
                <div class="slot-name">Empty</div>
            </div>
            <div class="party-slot" data-slot="1">
                <div class="slot-number">Slot 2 - Front</div>
                <div class="slot-icon">?</div>
                <div class="slot-name">Empty</div>
            </div>
            <div class="party-slot" data-slot="2">
                <div class="slot-number">Slot 3 - Back</div>
                <div class="slot-icon">?</div>
                <div class="slot-name">Empty</div>
            </div>
            <div class="party-slot" data-slot="3">
                <div class="slot-number">Slot 4 - Back</div>
                <div class="slot-icon">?</div>
                <div class="slot-name">Empty</div>
            </div>
        </div>

        <div class="character-select-grid">
            <!-- TANK -->
            <div class="char-select-card" data-char-class="tank">
                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 10px;">
                    <div class="char-select-icon"><img src="tank.png" alt="Tank"></div>
                    <div>
                        <div class="char-select-name">Tank</div>
                        <div class="char-select-role">Tank ‚Ä¢ Frontline</div>
                    </div>
                </div>
                <div class="char-select-desc">
                    A stalwart defender who protects allies with unbreakable resolve and powerful taunts.
                </div>
                <div class="char-select-stats">
                    <div class="char-stat-item">
                        <span class="char-stat-label">HP</span>
                        <span class="char-stat-value">100</span>
                    </div>
                    <div class="char-stat-item">
                        <span class="char-stat-label">Mana</span>
                        <span class="char-stat-value">50</span>
                    </div>
                    <div class="char-stat-item">
                        <span class="char-stat-label">Attack</span>
                        <span class="char-stat-value">5</span>
                    </div>
                    <div class="char-stat-item">
                        <span class="char-stat-label">Defense</span>
                        <span class="char-stat-value">10</span>
                    </div>
                </div>
            </div>

            <!-- PALADIN -->
            <div class="char-select-card" data-char-class="paladin">
                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 10px;">
                    <div class="char-select-icon"><img src="paladin.png" alt="Paladin"></div>
                    <div>
                        <div class="char-select-name">Paladin</div>
                        <div class="char-select-role">Off-Tank ‚Ä¢ Support</div>
                    </div>
                </div>
                <div class="char-select-desc">
                    A holy warrior who shields allies with divine blessings and smites enemies with righteous fury.
                </div>
                <div class="char-select-stats">
                    <div class="char-stat-item">
                        <span class="char-stat-label">HP</span>
                        <span class="char-stat-value">90</span>
                    </div>
                    <div class="char-stat-item">
                        <span class="char-stat-label">Mana</span>
                        <span class="char-stat-value">65</span>
                    </div>
                    <div class="char-stat-item">
                        <span class="char-stat-label">Attack</span>
                        <span class="char-stat-value">6</span>
                    </div>
                    <div class="char-stat-item">
                        <span class="char-stat-label">Defense</span>
                        <span class="char-stat-value">8</span>
                    </div>
                </div>
            </div>

            <!-- HEALER -->
            <div class="char-select-card" data-char-class="healer">
                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 10px;">
                    <div class="char-select-icon"><img src="healer.png" alt="Healer"></div>
                    <div>
                        <div class="char-select-name">Healer</div>
                        <div class="char-select-role">Support ‚Ä¢ Healer</div>
                    </div>
                </div>
                <div class="char-select-desc">
                    A divine caster who keeps allies alive with powerful restoration magic and blessings.
                </div>
                <div class="char-select-stats">
                    <div class="char-stat-item">
                        <span class="char-stat-label">HP</span>
                        <span class="char-stat-value">75</span>
                    </div>
                    <div class="char-stat-item">
                        <span class="char-stat-label">Mana</span>
                        <span class="char-stat-value">80</span>
                    </div>
                    <div class="char-stat-item">
                        <span class="char-stat-label">Attack</span>
                        <span class="char-stat-value">4</span>
                    </div>
                    <div class="char-stat-item">
                        <span class="char-stat-label">Defense</span>
                        <span class="char-stat-value">5</span>
                    </div>
                </div>
            </div>

            <!-- MAGE -->
            <div class="char-select-card" data-char-class="mage">
                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 10px;">
                    <div class="char-select-icon"><img src="mage.png" alt="Mage"></div>
                    <div>
                        <div class="char-select-name">Mage</div>
                        <div class="char-select-role">DPS ‚Ä¢ Caster</div>
                    </div>
                </div>
                <div class="char-select-desc">
                    A master of arcane arts who unleashes devastating spells from afar with explosive power.
                </div>
                <div class="char-select-stats">
                    <div class="char-stat-item">
                        <span class="char-stat-label">HP</span>
                        <span class="char-stat-value">70</span>
                    </div>
                    <div class="char-stat-item">
                        <span class="char-stat-label">Mana</span>
                        <span class="char-stat-value">100</span>
                    </div>
                    <div class="char-stat-item">
                        <span class="char-stat-label">Attack</span>
                        <span class="char-stat-value">10</span>
                    </div>
                    <div class="char-stat-item">
                        <span class="char-stat-label">Defense</span>
                        <span class="char-stat-value">3</span>
                    </div>
                </div>
            </div>

            <!-- ARCHER -->
            <div class="char-select-card" data-char-class="archer">
                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 10px;">
                    <div class="char-select-icon"><img src="archer.png" alt="Archer"></div>
                    <div>
                        <div class="char-select-name">Archer</div>
                        <div class="char-select-role">DPS ‚Ä¢ Ranged</div>
                    </div>
                </div>
                <div class="char-select-desc">
                    A nimble marksman who rains arrows on enemies with deadly accuracy and rapid fire.
                </div>
                <div class="char-select-stats">
                    <div class="char-stat-item">
                        <span class="char-stat-label">HP</span>
                        <span class="char-stat-value">85</span>
                    </div>
                    <div class="char-stat-item">
                        <span class="char-stat-label">Mana</span>
                        <span class="char-stat-value">70</span>
                    </div>
                    <div class="char-stat-item">
                        <span class="char-stat-label">Attack</span>
                        <span class="char-stat-value">9</span>
                    </div>
                    <div class="char-stat-item">
                        <span class="char-stat-label">Defense</span>
                        <span class="char-stat-value">4</span>
                    </div>
                </div>
            </div>

            <!-- ROGUE -->
            <div class="char-select-card" data-char-class="rogue">
                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 10px;">
                    <div class="char-select-icon"><img src="rogue.png" alt="Rogue" style="transform: translateX(-3px);"></div>
                    <div>
                        <div class="char-select-name">Rogue</div>
                        <div class="char-select-role">DPS ‚Ä¢ Assassin</div>
                    </div>
                </div>
                <div class="char-select-desc">
                    A deadly assassin who strikes with precision, dealing massive burst damage from the shadows.
                </div>
                <div class="char-select-stats">
                    <div class="char-stat-item">
                        <span class="char-stat-label">HP</span>
                        <span class="char-stat-value">80</span>
                    </div>
                    <div class="char-stat-item">
                        <span class="char-stat-label">Mana</span>
                        <span class="char-stat-value">60</span>
                    </div>
                    <div class="char-stat-item">
                        <span class="char-stat-label">Attack</span>
                        <span class="char-stat-value">8</span>
                    </div>
                    <div class="char-stat-item">
                        <span class="char-stat-label">Defense</span>
                        <span class="char-stat-value">5</span>
                    </div>
                </div>
            </div>
        </div>

        <button class="start-adventure-btn" id="start-adventure-btn" disabled>SELECT 4 HEROES</button>
    </div>

    <!-- Invisible drag bar for window movement -->
    <div id="drag-region"></div>

    <div id="game-container">
        <div id="main-content">
            <div id="main-view">
                <canvas id="dungeon-canvas"></canvas>
<div id="top-ui-container">
    <div id="room-label" style="display: none;">Dungeon Name - Floor 1</div>
    <div id="currency-container" style="display: flex; gap: 12px; align-items: center;">
        <div id="gold-display-top">0g</div>
        <div id="blessing-display-top" style="display: none;">0 ‚ú®</div>
        <div id="kill-counter" style="display: none;">0 Kills</div>
        <button id="end-run-btn" style="display: none; padding: 8px 16px; background: linear-gradient(135deg, #ef4444, #dc2626); color: white; border: none; border-radius: 8px; font-family: 'Orbitron', sans-serif; font-size: 14px; font-weight: 700; cursor: pointer; box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4); transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 1px;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(239, 68, 68, 0.6)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(239, 68, 68, 0.4)';" onclick="window.game.endDivineArenaRun()">üõë End Run</button>
    </div>
</div>                <div id="enemy-health-bars" style="position: absolute; top: 80px; left: 20px; display: flex; flex-direction: column; gap: 8px; z-index: 100;"></div>

<!-- Bottom-right damage/healing stats container -->
<div id="combat-stats-container" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 150; display: none; flex-direction: column; align-items: center; gap: 8px; pointer-events: auto; user-select: none;">
    <div id="damage-stats-display" style="pointer-events: auto;" title="Click: Toggle Damage/Healing | Drag: Move | Double-Click: Reset Position">
        <span style="opacity: 0.5; margin-right: 4px;">‚ãÆ‚ãÆ</span>üìä Stats
    </div>
    <div id="character-stats-panel" style="pointer-events: auto;"></div>
</div>

<div id="dungeon-selector">
                    <h2 style="text-align: center; margin-bottom: 20px; font-size: 24px;">Select Your Dungeon</h2>
                    <div class="dungeon-option everfall" data-dungeon="everfall">
                        <div class="dungeon-title">‚öîÔ∏è Everfall</div>
                        <div class="dungeon-loot">Drops: Chests, Helmets, Gloves, Belts, Boots</div>
                    </div>
                    <div class="dungeon-option stoneforge" data-dungeon="stoneforge">
                        <div class="dungeon-title">üî• Stoneforge</div>
                        <div class="dungeon-loot">Drops: Weapons</div>
                    </div>
                    <div class="dungeon-option umbral" data-dungeon="umbral">
                        <div class="dungeon-title">üåë Umbral Depths</div>
                        <div class="dungeon-loot">Drops: Amulets, Rings</div>
                    </div>
                    <div class="dungeon-option vault" data-dungeon="vault">
                        <div class="dungeon-title">üîí Vault</div>
                        <div class="dungeon-loot">Elite Boss - Hard (Requires Vault Key) - Earn Keystones</div>
                    </div>
                    <div class="dungeon-option runetrial" data-dungeon="runetrial">
                        <div class="dungeon-title">üîÆ Rune Trial</div>
                        <div class="dungeon-loot">Elite Boss - Hard (Requires Rune Trial Key) - Earn Runes</div>
                    </div>
                </div>
                <div id="dungeon-map">
                    <canvas id="map-canvas"></canvas>
                    <div id="map-tooltip" style="position: absolute; background: rgba(15, 23, 42, 0.98); border: 1px solid rgba(99, 102, 241, 0.5); border-radius: 8px; padding: 8px 12px; font-size: 11px; color: #e2e8f0; pointer-events: none; display: none; z-index: 1000; font-family: 'Rajdhani', sans-serif;"></div>
                </div>
            </div>

            <div id="side-panel">
                <div id="tab-navigation">
                    <button class="tab-button active" data-tab="log" title="Combat Log"><img src="combat%20log2.png"></button>
                    <div style="height: 1px; background: rgba(99, 102, 241, 0.2); margin: 10px 5px;"></div>
                    <button class="tab-button" data-tab="loot" title="Loot"><img src="Lootbad3.png"></button>
                    <button class="tab-button" data-tab="chests" title="Cache"><img src="cache%20tab.png"></button>
                    <button class="tab-button" data-tab="keystones" title="Keystones"><img src="keystone%20tabs.png"></button>
                    <button class="tab-button" data-tab="bless" title="Bless"><div style="font-size: 48px;">‚ú®</div></button>
                    <div style="height: 1px; background: rgba(99, 102, 241, 0.2); margin: 10px 5px;"></div>
                    <button class="tab-button" data-tab="dungeons" title="Dungeons"><img src="dungeon%20tab.png" style="width: 64px; height: 64px;"></button>
                    <button class="tab-button" data-tab="controls" title="Controls"><img src="settings%20tab.png"></button>
                    <button class="tab-button" data-tab="stats" title="Stats"><img src="stats.png" style="width: 64px; height: 64px;"></button>
                    <button class="tab-button" data-tab="pets" title="Pets"><div style="font-size: 48px;">üêæ</div></button>
                    <button class="tab-button" data-tab="leaderboard" title="Leaderboard"><div style="font-size: 48px;">üèÜ</div></button>
                </div>
                <div id="tab-content">
                    <div id="log-tab" class="tab-panel active">
                        <div class="section-title">Combat Log</div>
                        <div id="log-container"></div>
                    </div>
                    <div id="leaderboard-tab" class="tab-panel">
                        <div class="section-title">Leaderboard</div>
                        <div style="text-align: center; padding: 10px; margin-bottom: 10px; background: linear-gradient(135deg, rgba(168, 85, 247, 0.2), rgba(139, 92, 246, 0.1)); border: 2px solid rgba(168, 85, 247, 0.3); border-radius: 10px;">
                            <div style="color: #a855f7; font-family: 'Orbitron', sans-serif; font-size: 16px; font-weight: 700; text-shadow: 0 0 10px rgba(168, 85, 247, 0.5);">
                                üéÆ Game Version: <span style="color: #fbbf24;">v3</span>
                            </div>
                        </div>
                        <div style="padding: 20px;">
                            <button onclick="viewLeaderboard('gearScore')" style="width: 100%; padding: 15px; background: #a855f7; border: none; border-radius: 5px; color: white; font-weight: bold; cursor: pointer; font-size: 16px; margin-bottom: 15px;">üèÜ VIEW LEADERBOARD</button>
                            <div style="padding: 15px; background: rgba(99, 102, 241, 0.1); border-radius: 5px; font-size: 14px; line-height: 1.6;">
                                <strong style="color: #f59e0b;">Auto-Submit Timer</strong><br>
                                ‚Ä¢ First submission: 2 minutes after game start<br>
                                ‚Ä¢ Then every 30 minutes automatically<br><br>
                                <strong style="color: #a855f7;">Tracking Categories:</strong><br>
                                ‚Ä¢ Highest Gear Score<br>
                                ‚Ä¢ Highest Floor Reached<br>
                                ‚Ä¢ Most Pets Found<br>
                                ‚Ä¢ Most Mythics Found<br>
                                ‚Ä¢ Rune Trial Boss Kills<br>
                                ‚Ä¢ Vault Boss Kills<br>
                                ‚Ä¢ Divine Arena Kills
                            </div>
                        </div>
                    </div>
                    <div id="loot-tab" class="tab-panel">
                        <div class="section-title">Items</div>

                        <!-- Sub-tabs for Loot/Inventory -->
                        <div style="display: flex; gap: 5px; margin-bottom: 15px; background: rgba(15, 23, 42, 0.5); padding: 4px; border-radius: 8px;">
                            <button class="loot-sub-tab active" data-loot-tab="loot" style="flex: 1; padding: 8px; background: transparent; color: #94a3b8; border: none; border-radius: 6px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px; font-weight: 600; transition: all 0.2s ease;">
                                 LOOT
                            </button>
                            <button class="loot-sub-tab" data-loot-tab="inventory" style="flex: 1; padding: 8px; background: transparent; color: #94a3b8; border: none; border-radius: 6px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px; font-weight: 600; transition: all 0.2s ease;">
                                 INVENTORY
                            </button>
                        </div>

                        <!-- Loot Section -->
                        <div id="loot-loot-section" class="loot-section active">
                            <div style="display: flex; gap: 5px; margin-bottom: 10px; flex-wrap: wrap;">
                                <button class="loot-filter-btn" data-filter="rarity" style="flex: 1; padding: 6px 12px; background: rgba(99, 102, 241, 0.2); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; color: #94a3b8; cursor: pointer; font-size: 10px; font-weight: 600; font-family: 'Orbitron', sans-serif; transition: all 0.2s;">
                                    SORT: RARITY
                                </button>
                                <button class="loot-filter-btn" data-filter="level" style="flex: 1; padding: 6px 12px; background: rgba(99, 102, 241, 0.2); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; color: #94a3b8; cursor: pointer; font-size: 10px; font-weight: 600; font-family: 'Orbitron', sans-serif; transition: all 0.2s;">
                                    SORT: LEVEL
                                </button>
                            </div>
                            <div id="loot-container"></div>
                        </div>

                        <!-- Inventory Section -->
                        <div id="loot-inventory-section" class="loot-section" style="display: none;">
                            <div style="display: flex; gap: 5px; margin-bottom: 10px; flex-wrap: wrap;">
                                <button class="inventory-filter-btn" data-filter="rarity" style="flex: 1; padding: 6px 12px; background: rgba(99, 102, 241, 0.2); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; color: #94a3b8; cursor: pointer; font-size: 10px; font-weight: 600; font-family: 'Orbitron', sans-serif; transition: all 0.2s;">
                                    SORT: RARITY
                                </button>
                                <button class="inventory-filter-btn" data-filter="level" style="flex: 1; padding: 6px 12px; background: rgba(99, 102, 241, 0.2); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; color: #94a3b8; cursor: pointer; font-size: 10px; font-weight: 600; font-family: 'Orbitron', sans-serif; transition: all 0.2s;">
                                    SORT: LEVEL
                                </button>
                            </div>
                            <div id="inventory-container"></div>
                        </div>
                    </div>

<div id="chests-tab" class="tab-panel">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
        <div class="section-title" style="margin-bottom: 0;">Cache</div>
        <div style="padding: 8px 16px; background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(251, 191, 36, 0.2)); border: 1px solid rgba(245, 158, 11, 0.4); border-radius: 8px; font-size: 16px; font-weight: 700; color: #f59e0b; font-family: 'Orbitron', sans-serif;">
            üí∞ <span id="gold-display">0</span>g
        </div>
    </div>

    <!-- Sub-tabs for Cache -->
	<button class="cache-sub-tab" data-cache-tab="chests" style="flex: 1; padding: 8px; background: transparent; color: #94a3b8; border: none; border-radius: 6px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px; font-weight: 600; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; gap: 6px;">
        <img src="chest.png" style="width: 18px; height: 18px;"> CHESTS
    </button>
    <div style="display: flex; gap: 5px; margin-bottom: 15px; background: rgba(15, 23, 42, 0.5); padding: 4px; border-radius: 8px;">
	<button class="cache-sub-tab" data-cache-tab="keys" style="flex: 1; padding: 8px; background: transparent; color: #94a3b8; border: none; border-radius: 6px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px; font-weight: 600; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; gap: 6px;">
        <img src="gold_key_64_transparent.png" style="width: 18px; height: 18px;"> VAULT
    </button>
    <button class="cache-sub-tab active" data-cache-tab="rune-keys" style="flex: 1; padding: 8px; background: transparent; color: #94a3b8; border: none; border-radius: 6px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px; font-weight: 600; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; gap: 6px;">
        <img src="blue_key_64_transparent.png" style="width: 18px; height: 18px;"> RUNE
    </button>
</div>

    <!-- Rune Trial Keys Section -->
    <div id="cache-rune-keys-section" class="cache-section active">
        <div id="rune-trial-keys-grid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;"></div>
        <div id="no-rune-keys" style="display: none; color: #64748b; text-align: center; padding: 30px; font-size: 12px; font-style: italic;">
            No Rune Trial Keys<br>
            <span style="font-size: 10px;">Keys drop from floor 45+ (2% chance)</span>
        </div>
    </div>

    <!-- Vault Keys Section -->
    <div id="cache-keys-section" class="cache-section" style="display: none;">
        <div id="vault-keys-grid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;"></div>
        <div id="no-keys" style="display: none; color: #64748b; text-align: center; padding: 30px; font-size: 12px; font-style: italic;">
            No Vault Keys<br>
            <span style="font-size: 10px;">10% drop chance per floor cleared</span>
        </div>
    </div>

    <!-- Chests Section -->
    <div id="cache-chests-section" class="cache-section" style="display: none;">
        <div id="chests-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 10px;"></div>
        <div id="no-chests" style="display: none; color: #64748b; text-align: center; padding: 30px; font-size: 12px; font-style: italic;">
            No Chests<br>
            <span style="font-size: 10px;">10% drop chance per floor (10% are Mythic)</span>
        </div>
    </div>
</div>
                    <div id="keystones-tab" class="tab-panel">
                        <!-- Sub-tabs for Keystones/Runes -->
<div style="display: flex; gap: 5px; margin-bottom: 15px; background: rgba(15, 23, 42, 0.5); padding: 4px; border-radius: 8px;">
    <button class="keystone-sub-tab active" data-keystone-tab="keystones" style="flex: 1; padding: 8px; background: transparent; color: #94a3b8; border: none; border-radius: 6px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px; font-weight: 600; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; gap: 6px;">
        <img src="keystone%20emoji.png" style="width: 24px; height: 24px;"> KEYSTONES
    </button>
    <button class="keystone-sub-tab" data-keystone-tab="runes" style="flex: 1; padding: 8px; background: transparent; color: #94a3b8; border: none; border-radius: 6px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px; font-weight: 600; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; gap: 6px;">
        <img src="rune%20emoji.png" style="width: 24px; height: 24px;"> RUNES
    </button>
</div>

                        <!-- Keystones Section -->
                        <div id="keystone-keystones-section" class="keystone-section active">
                            <div id="keystone-slots-container" style="margin-bottom: 20px;">
                                <div style="background: rgba(15, 23, 42, 0.5); padding: 15px; border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.2);">
                                    <div style="font-size: 11px; color: #94a3b8; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px;">Equipped Keystones</div>
                                    <div id="keystone-slots-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;"></div>
                                </div>
                            </div>
                            <div style="font-size: 11px; color: #94a3b8; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px;">Keystone Inventory</div>
                            <div id="keystone-list"></div>
                        </div>

                        <!-- Runes Section -->
                        <div id="keystone-runes-section" class="keystone-section" style="display: none;">
                            <!-- Character Sub-tabs for Runes -->
                            <style>
                                .rune-char-tab {
                                    flex: 1;
                                    padding: 8px;
                                    background: transparent;
                                    border: none;
                                    border-radius: 6px;
                                    cursor: pointer;
                                    transition: all 0.2s ease;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                }

                                .rune-char-tab img {
                                    width: 32px;
                                    height: 32px;
                                    object-fit: contain;
                                    filter: grayscale(50%) brightness(0.8);
                                    transition: all 0.2s ease;
                                }

                                .rune-char-tab.active {
                                    background: rgba(99, 102, 241, 0.2);
                                }

                                .rune-char-tab.active img {
                                    filter: grayscale(0%) brightness(1);
                                }

                                .rune-char-tab:hover img {
                                    filter: grayscale(0%) brightness(1.1);
                                    transform: scale(1.1);
                                }
                            </style>
                            <div id="rune-char-tabs-container" style="display: flex; gap: 5px; margin-bottom: 15px; background: rgba(15, 23, 42, 0.5); padding: 4px; border-radius: 8px;">
                                <!-- Character tabs will be dynamically generated here -->
                            </div>

                            <div id="rune-slots-container" style="margin-bottom: 20px;">
                                <div style="background: rgba(15, 23, 42, 0.5); padding: 15px; border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.2);">
                                    <div style="font-size: 11px; color: #94a3b8; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px;">Equipped Runes (5 Slots)</div>
                                    <div id="rune-slots-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                        <!-- Populated by showRunesForCharacter() -->
                                    </div>
                                </div>
                            </div>
                            <div style="font-size: 11px; color: #94a3b8; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px;">Rune Inventory</div>
                            <div id="rune-list">
                                <!-- Populated by showRunesForCharacter() -->
                            </div>
                        </div>
                    </div>
                    <div id="keystones-tab" class="tab-panel">
                        <div class="section-title">Keystones</div>
                        <div id="keystone-slots-container" style="margin-bottom: 20px;">
                            <div style="background: rgba(15, 23, 42, 0.5); padding: 15px; border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.2);">
                                <div style="font-size: 11px; color: #94a3b8; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px;">Equipped Keystones</div>
                                <div id="keystone-slots-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;"></div>
                            </div>
                        </div>
                        <div style="font-size: 11px; color: #94a3b8; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px;">Keystone Inventory</div>
                        <div id="keystone-list"></div>
                    </div>
                    <div id="bless-tab" class="tab-panel">
                        <div class="section-title">Bless Items</div>
                        <div style="background: rgba(168, 85, 247, 0.1); padding: 20px; border-radius: 12px; border: 2px solid rgba(168, 85, 247, 0.3); margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                                <div style="font-size: 18px; font-weight: 700; color: #e9d5ff; font-family: 'Orbitron', sans-serif;">‚ú® Blessing Currency</div>
                                <div id="blessing-currency-display" style="font-size: 24px; font-weight: 800; color: #a855f7; font-family: 'Orbitron', sans-serif; text-shadow: 0 0 15px rgba(168, 85, 247, 0.6);">0</div>
                            </div>
                            <div style="font-size: 12px; color: #c4b5fd; line-height: 1.6;">
                                Earned from the <span style="color: #a855f7; font-weight: 700;">Divine Arena</span> dungeon. Each blessing costs <span style="color: #fbbf24; font-weight: 700;">Blessing Currency equal to the item's level</span> and permanently enhances an item with powerful bonuses.<br><br>
                                <span style="color: #c910a7; font-weight: 700;">‚ö° BLESSING POWER:</span> Increases <span style="color: #a855f7; font-weight: 700;">ONE random stat</span> on your item by <span style="color: #22c55e; font-weight: 700;">50%</span>! Works on all rarities, including <span style="color: #c910a7; font-weight: 700;">MYTHIC</span> items!
                            </div>
                        </div>

                        <div id="bless-item-selected" style="display: none; background: rgba(15, 23, 42, 0.8); padding: 20px; border-radius: 12px; border: 2px solid rgba(168, 85, 247, 0.5); margin-bottom: 20px;">
                            <!-- Selected item details will be shown here -->
                        </div>

                        <div style="text-align: center; padding: 60px 20px; color: #64748b;">
                            <div style="font-size: 72px; margin-bottom: 20px; opacity: 0.5;">‚ú®</div>
                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 10px; color: #94a3b8;">Select an Item to Bless</div>
                            <div style="font-size: 13px; color: #64748b; line-height: 1.6;">
                                Click on any equipped item on your characters<br>
                                and choose "Bless Item" to enhance it here
                            </div>
                        </div>
                    </div>
                    <div id="dungeons-tab" class="tab-panel">
                        <div class="section-title">Select Dungeon</div>
<div id="dungeon-selection-grid">
                            <div class="dungeon-card everfall" data-dungeon="everfall" style="background-image: url('everfall%20button.jpg'); background-size: cover; background-position: center;">
                                <div class="dungeon-card-title" style="text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);">Everfall</div>
                                <div class="dungeon-card-loot" style="color: #fff; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.9);">Drops: Chests, Helmets, Gloves, Belts, Boots</div>
                            </div>
                            <div class="dungeon-card stoneforge" data-dungeon="stoneforge" style="background-image: url('stoneforge.jpg'); background-size: cover; background-position: center;">
                                <div class="dungeon-card-title" style="text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);">Stoneforge</div>
                                <div class="dungeon-card-loot" style="color: #fff; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.9);">Drops: Weapons</div>
                            </div>
                            <div class="dungeon-card umbral" data-dungeon="umbral" style="background-image: url('umbraldepths.jpg'); background-size: cover; background-position: center;">
                                <div class="dungeon-card-title" style="text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);">Umbral Depths</div>
                                <div class="dungeon-card-loot" style="color: #fff; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.9);">Drops: Amulets, Rings</div>
                            </div>

                            <div style="grid-column: 1 / -1; height: 1px; background: rgba(99, 102, 241, 0.2); margin: 10px 0;"></div>

                            <div class="dungeon-card vault" data-dungeon="vault" style="background-image: url('vault.jpg'); background-size: cover; background-position: center; ${this.vaultKeys.length === 0 ? 'filter: grayscale(100%) brightness(0.5); opacity: 0.6;' : ''}">
                                <div class="dungeon-card-title" style="text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);">Vault</div>
                                <div class="dungeon-card-loot" style="color: #fff; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.9);">Elite Boss - Hard (Requires Vault Key) - Earn Keystones</div>
                            </div>
                            <div class="dungeon-card runetrial" data-dungeon="runetrial" style="background-image: url('runetrials.jpg'); background-size: cover; background-position: center; ${this.runeTrialKeys.length === 0 ? 'filter: grayscale(100%) brightness(0.5); opacity: 0.6;' : ''}">
                                <div class="dungeon-card-title" style="text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);">Rune Trial</div>
                                <div class="dungeon-card-loot" style="color: #fff; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.9);">Elite Boss - Hard (Requires Rune Trial Key) - Earn Runes</div>
                            </div>

                            <div style="grid-column: 1 / -1; height: 1px; background: linear-gradient(90deg, transparent, rgba(168, 85, 247, 0.5), transparent); margin: 10px 0;"></div>

                            <div class="dungeon-card endless-blessings" data-dungeon="endlessblessings" style="background: rgba(184, 134, 11, 0.3); background-size: cover; background-position: center; border: 2px solid #d4a747; box-shadow: 0 0 25px rgba(200, 160, 50, 0.5), inset 0 0 15px rgba(218, 165, 32, 0.25);">
                                <div class="dungeon-card-title" style="text-shadow: 0 0 6px rgba(200, 160, 50, 0.7), 2px 2px 4px rgba(0, 0, 0, 0.9); color: #f5deb3; font-weight: 800;">‚ú® Divine Arena ‚ú®</div>
                                <div class="dungeon-card-loot" style="color: #e8d5a8; text-shadow: 0 0 4px rgba(200, 160, 50, 0.5), 1px 1px 3px rgba(0, 0, 0, 0.9); font-weight: 600;">‚ö° Ultra Endgame - Infinite Floors - Earn Blessing Currency ‚ö°</div>
                                <button onclick="showDropTable()" style="margin-top: 10px; padding: 8px 16px; background: linear-gradient(135deg, rgba(184, 134, 11, 0.5), rgba(160, 130, 50, 0.4)); border: 2px solid #d4a747; border-radius: 8px; color: #f5deb3; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 700; cursor: pointer; box-shadow: 0 4px 12px rgba(200, 160, 50, 0.3); transition: all 0.3s ease;">
                                    üìä View Drop Table
                                </button>
                            </div>

                        </div>
                    </div>
<div id="controls-tab" class="tab-panel">
                        <div class="section-title">Controls</div>
<button id="pause-btn">‚∏∏Ô∏è Pause</button>
<button id="collapse-all-btn" style="margin-top: 5px;">Collapse All</button>
<button id="reset-account-controls-btn" style="margin-top: 15px; width: 100%; padding: 12px; background: linear-gradient(135deg, #ef4444, #dc2626); color: white; border: none; border-radius: 10px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 14px; font-weight: 700; box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3); transition: all 0.3s ease;">
    üîÑ RESET ACCOUNT
</button>
<div style="margin-top: 15px;" class="collapsible-section collapsed">
    <div class="section-title" style="cursor: pointer; user-select: none;" onclick="this.parentElement.classList.toggle('collapsed')">
        <span class="collapse-arrow">‚ñº</span> Party Names
    </div>
    <div class="collapsible-content" style="background: rgba(15, 23, 42, 0.5); padding: 10px; border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.2);">
        <div style="margin-bottom: 8px;">
            <label style="color: #94a3b8; font-size: 11px; display: block; margin-bottom: 4px;">Tank:</label>
            <input type="text" id="name-tank" value="Tank" maxlength="12" style="width: 100%; padding: 6px; background: rgba(30, 41, 59, 0.9); color: #e2e8f0; border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; font-family: 'Rajdhani', sans-serif; font-size: 12px;">
        </div>
        <div style="margin-bottom: 8px;">
            <label style="color: #94a3b8; font-size: 11px; display: block; margin-bottom: 4px;">Healer:</label>
            <input type="text" id="name-healer" value="Healer" maxlength="12" style="width: 100%; padding: 6px; background: rgba(30, 41, 59, 0.9); color: #e2e8f0; border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; font-family: 'Rajdhani', sans-serif; font-size: 12px;">
        </div>
        <div style="margin-bottom: 8px;">
            <label style="color: #94a3b8; font-size: 11px; display: block; margin-bottom: 4px;">Mage:</label>
            <input type="text" id="name-mage" value="Mage" maxlength="12" style="width: 100%; padding: 6px; background: rgba(30, 41, 59, 0.9); color: #e2e8f0; border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; font-family: 'Rajdhani', sans-serif; font-size: 12px;">
        </div>
        <div style="margin-bottom: 8px;">
            <label style="color: #94a3b8; font-size: 11px; display: block; margin-bottom: 4px;">Rogue:</label>
            <input type="text" id="name-rogue" value="Rogue" maxlength="12" style="width: 100%; padding: 6px; background: rgba(30, 41, 59, 0.9); color: #e2e8f0; border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; font-family: 'Rajdhani', sans-serif; font-size: 12px;">
        </div>
        <div style="margin-bottom: 8px;">
            <label style="color: #94a3b8; font-size: 11px; display: block; margin-bottom: 4px;">Archer:</label>
            <input type="text" id="name-archer" value="Archer" maxlength="12" style="width: 100%; padding: 6px; background: rgba(30, 41, 59, 0.9); color: #e2e8f0; border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; font-family: 'Rajdhani', sans-serif; font-size: 12px;">
        </div>
        <div style="margin-bottom: 8px;">
            <label style="color: #94a3b8; font-size: 11px; display: block; margin-bottom: 4px;">Paladin:</label>
            <input type="text" id="name-paladin" value="Paladin" maxlength="12" style="width: 100%; padding: 6px; background: rgba(30, 41, 59, 0.9); color: #e2e8f0; border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; font-family: 'Rajdhani', sans-serif; font-size: 12px;">
        </div>
    </div>
</div>
<div style="margin-top: 15px;" class="collapsible-section collapsed">
                            <div class="section-title" style="cursor: pointer; user-select: none;" onclick="this.parentElement.classList.toggle('collapsed')">
                                <span class="collapse-arrow">‚ñº</span> Popups
                            </div>
                            <div class="collapsible-content" style="background: rgba(15, 23, 42, 0.5); padding: 10px; border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.2);">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                    <input type="checkbox" id="show-fountain-popup" checked style="width: 16px; height: 16px;">
                                    <span style="color: #94a3b8; font-size: 12px; font-weight: 600;">Show Fountain of Youth Popup</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <input type="checkbox" id="show-treasure-popup" checked style="width: 16px; height: 16px;">
                                    <span style="color: #94a3b8; font-size: 12px; font-weight: 600;">Show Treasure Room Popup</span>
                                </div>
                            </div>
                        </div>
                        <div style="margin-top: 15px;" class="collapsible-section">
                            <div class="section-title" style="cursor: pointer; user-select: none;" onclick="this.parentElement.classList.toggle('collapsed')">
                                <span class="collapse-arrow">‚ñº</span> Summary Duration
                            </div>
                            <div class="collapsible-content" style="background: rgba(15, 23, 42, 0.5); padding: 10px; border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.2);">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <input type="range" id="summary-duration-slider" min="1" max="10" value="4" style="flex: 1; cursor: pointer;">
                                    <span id="summary-duration-value" style="color: #f59e0b; font-weight: 600; min-width: 40px;">4s</span>
                                </div>
                                <div style="font-size: 10px; color: #64748b; margin-top: 8px; text-align: center;">
                                    Victory/Defeat screen duration
                                </div>
                            </div>
                        </div>
                        <div style="margin-top: 15px;" class="collapsible-section">
                            <div class="section-title" style="cursor: pointer; user-select: none;" onclick="this.parentElement.classList.toggle('collapsed')">
                                <span class="collapse-arrow">‚ñº</span> Loot Filter - Rarity
                            </div>
                            <div class="collapsible-content" style="background: rgba(15, 23, 42, 0.5); padding: 10px; border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.2);">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                    <input type="checkbox" class="filter-checkbox" data-rarity="common" checked style="width: 16px; height: 16px;">
                                    <span style="color: #94a3b8; font-size: 12px; font-weight: 600;">Common</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                    <input type="checkbox" class="filter-checkbox" data-rarity="uncommon" checked style="width: 16px; height: 16px;">
                                    <span style="color: #10b981; font-size: 12px; font-weight: 600;">Uncommon</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                    <input type="checkbox" class="filter-checkbox" data-rarity="rare" checked style="width: 16px; height: 16px;">
                                    <span style="color: #3b82f6; font-size: 12px; font-weight: 600;">Rare</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                    <input type="checkbox" class="filter-checkbox" data-rarity="epic" checked style="width: 16px; height: 16px;">
                                    <span style="color: #a855f7; font-size: 12px; font-weight: 600;">Epic</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                    <input type="checkbox" class="filter-checkbox" data-rarity="legendary" checked style="width: 16px; height: 16px;">
                                    <span style="color: #f59e0b; font-size: 12px; font-weight: 600;">Legendary</span>
                                </div>
                                <div style="font-size: 9px; color: #64748b; margin-top: 8px; text-align: center; font-style: italic;">
                                    Unchecked rarities will auto-sell
                                </div>
                            </div>
                        </div>
                        <div style="margin-top: 15px;" class="collapsible-section">
                            <div class="section-title" style="cursor: pointer; user-select: none;" onclick="this.parentElement.classList.toggle('collapsed')">
                                <span class="collapse-arrow">‚ñº</span> Loot Filter - Level
                            </div>
                            <div class="collapsible-content" style="background: rgba(15, 23, 42, 0.5); padding: 10px; border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.2);">
                                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                    <label style="color: #94a3b8; font-size: 12px; flex: 1;">Min Item Level:</label>
                                    <input type="number" id="min-level-filter" min="1" max="999" value="1" style="width: 80px; padding: 4px 8px; background: rgba(30, 41, 59, 0.9); color: #e2e8f0; border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; font-family: 'Rajdhani', sans-serif; font-size: 12px;">
                                </div>
                                <div style="font-size: 9px; color: #64748b; text-align: center; font-style: italic;">
                                    Items below this level will auto-sell
                                </div>
                            </div>
                        </div>
                    </div>
 <div id="pets-tab" class="tab-panel">
    <div class="section-title">Pet Collection</div>

    <!-- Pet Collection Grid -->
    <div id="pet-collection-container" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px;"></div>
</div>

 <div id="stats-tab" class="tab-panel">
    <div class="section-title">Current Run</div>
    <div style="background: rgba(15, 23, 42, 0.5); padding: 15px; border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.2); margin-bottom: 15px;">
        <div style="margin-bottom: 10px;">
            <span style="color: #94a3b8; font-size: 12px; text-transform: uppercase; letter-spacing: 1px;">Dungeon:</span>
            <span id="current-dungeon-display" style="color: #f59e0b; float: right; font-weight: 600;">None</span>
        </div>
        <div>
            <span style="color: #94a3b8; font-size: 12px; text-transform: uppercase; letter-spacing: 1px;">Floor:</span>
            <span id="current-floor-display" style="color: #f59e0b; float: right; font-weight: 600;">1</span>
        </div>
    </div>

    <div class="section-title">Dungeon Progress</div>
    <div style="background: rgba(15, 23, 42, 0.5); padding: 15px; border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.2); margin-bottom: 15px;">
        <div style="font-size: 11px; color: #cbd5e1; margin-bottom: 12px; padding: 8px; background: rgba(99, 102, 241, 0.05); border-radius: 6px; border-left: 3px solid #6366f1; line-height: 1.4;">
    <strong>üéØ Floor Selection:</strong> Choose any starting floor from 1-50 for each dungeon. Pick your preferred challenge level and jump right into the action! Your best floor reached is tracked for each dungeon.
</div><div style="margin-bottom: 10px;">
            <span style="color: #10b981; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; font-weight: 600;">Everfall:</span>
            <span id="everfall-progress-display" style="color: #10b981; float: right; font-weight: 600;">Start: 1 | Best: 1</span>
        </div>
        <div style="margin-bottom: 10px;">
            <span style="color: #ef4444; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; font-weight: 600;">Stoneforge:</span>
            <span id="stoneforge-progress-display" style="color: #ef4444; float: right; font-weight: 600;">Start: 1 | Best: 1</span>
        </div>
        <div>
            <span style="color: #a855f7; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; font-weight: 600;">Umbral:</span>
            <span id="umbral-progress-display" style="color: #a855f7; float: right; font-weight: 600;">Start: 1 | Best: 1</span>
        </div>
    </div>

    <div class="section-title">Stats</div>
    <div style="background: rgba(15, 23, 42, 0.5); padding: 15px; border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.2);">
        <div style="margin-bottom: 10px;">
            <span style="color: #94a3b8; font-size: 12px; text-transform: uppercase; letter-spacing: 1px;">Farthest Floor:</span>
            <span id="farthest-floor-display" style="color: #52525b; float: right; font-weight: 600;">1</span>
        </div>
        <div style="margin-bottom: 10px;">
            <span style="color: #94a3b8; font-size: 12px; text-transform: uppercase; letter-spacing: 1px;">Fastest Floor:</span>
            <span id="fastest-floor-display" style="color: #10b981; float: right; font-weight: 600;">--</span>
        </div>
        <div style="margin-bottom: 10px;">
            <span style="color: #94a3b8; font-size: 12px; text-transform: uppercase; letter-spacing: 1px;">Legendaries Found:</span>
            <span id="legendaries-display" style="color: #f59e0b; float: right; font-weight: 600;">0</span>
        </div>
        <div style="margin-bottom: 10px;">
            <span style="color: #94a3b8; font-size: 12px; text-transform: uppercase; letter-spacing: 1px;">Chests Found:</span>
            <span id="chests-display" style="color: #a1a1aa; float: right; font-weight: 600;">0</span>
        </div>
        <div style="margin-bottom: 10px;">
            <span style="color: #94a3b8; font-size: 12px; text-transform: uppercase; letter-spacing: 1px;">Floors Cleared:</span>
            <span id="floors-cleared-display" style="color: #3b82f6; float: right; font-weight: 600;">0</span>
        </div>
        <div style="margin-bottom: 10px;">
            <span style="color: #94a3b8; font-size: 12px; text-transform: uppercase; letter-spacing: 1px;">Total Gold:</span>
            <span id="total-gold-display" style="color: #f59e0b; float: right; font-weight: 600;">0g</span>
        </div>
        <div>
            <span style="color: #94a3b8; font-size: 12px; text-transform: uppercase; letter-spacing: 1px;">Deaths:</span>
            <span id="deaths-display" style="color: #ef4444; float: right; font-weight: 600;">0</span>
        </div>
    </div>
</div>
                </div>
            </div>
        </div>

        <div id="bottom-ui">
            <div id="resize-handle"></div>
            <div id="mirror-toggle-container">
                <input type="checkbox" id="mirror-toggle" checked>
                <label for="mirror-toggle">Mirror</label>
            </div>
            <div id="party-container"></div>
        </div>
    </div>

    <div class="equipment-tooltip" id="equipment-tooltip"></div>
    <div class="loot-tooltip" id="loot-tooltip"></div>
    <div class="enemy-tooltip" id="enemy-tooltip"></div>
    <div class="stat-tooltip" id="stat-tooltip"></div>
    <div class="gear-context-menu" id="gear-context-menu"></div>

    <div id="summary-overlay">
        <div id="summary-panel">
            <div class="summary-title" id="summary-title">VICTORY</div>
            <div class="summary-stats">
                <div class="summary-stat-row">
                    <span class="summary-stat-label">Floor Completed:</span>
                    <span class="summary-stat-value" id="summary-floor">1</span>
                </div>
                <div class="summary-stat-row">
                    <span class="summary-stat-label">Time Taken:</span>
                    <span class="summary-stat-value" id="summary-time">0:00</span>
                </div>
                <div class="summary-stat-row">
                    <span class="summary-stat-label">Total Damage Dealt:</span>
                    <span class="summary-stat-value" id="summary-damage">0</span>
                </div>
                <div class="summary-stat-row">
                    <span class="summary-stat-label">Enemies Defeated:</span>
                    <span class="summary-stat-value" id="summary-kills">0</span>
                </div>
                <div class="summary-stat-row">
                    <span class="summary-stat-label">Gold Earned:</span>
                    <span class="summary-stat-value" id="summary-gold">0g</span>
                </div>
                <div class="summary-stat-row">
                    <span class="summary-stat-label">Loot Obtained:</span>
                    <span class="summary-stat-value" id="summary-loot">0 items</span>
                </div>
            </div>
            <button class="summary-button" id="summary-continue">Continue</button>
        </div>
    </div>
<!-- Skill Tree Overlay -->
    <div id="skill-tree-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 3000; background: linear-gradient(135deg, #0a0e27 0%, #151935 100%);">
        <div id="skill-tree-container" style="width: 100%; height: 100%; display: flex; flex-direction: column;">
            <!-- Skill tree UI here -->
        </div>
    </div>
    <script>
        // Asset Preloader System
class AssetPreloader {
    constructor() {
        this.assets = {
            images: {},
            loaded: 0,
            total: 0
        };
    }

    async loadAllAssets() {
        const imageList = {
            // Character icons
            tank: 'shield.png',
            healer: 'healer.png',
            mage: 'mage.png',
            rogue: 'rogue.png',
            archer: 'archer.png',
            paladin: 'paladin.png',

            // Backgrounds
            everfallBg: 'everfall.png',
            stoneforgeBg: 'stoneforge.png',
            umbralBg: 'umbral%20depths1.png',
            vaultBg: 'vault.png',
            runetrialBg: 'runetrial.png',

            // Banners
            everfallBanner: 'everfall%20banner.png',
            stoneforgeBanner: 'stoneforge%20banner.png',
            umbralBanner: 'umbral%20depths.png',
            vaultBanner: 'the%20vault.png',
            runetrialBanner: 'rune%20trials.png',

            // UI Icons
            combatLog: 'combat%20log2.png',
            lootIcon: 'Lootbad3.png',
            cacheIcon: 'cache%20tab.png',
            keystoneIcon: 'keystone%20tabs.png',
            dungeonIcon: 'dungeon%20tab.png',
            settingsIcon: 'settings%20tab.png',
            statsIcon: 'stats.png',

            // Keys and items
            blueKey: 'blue_key_64_transparent.png',
            goldKey: 'gold_key_64_transparent.png',
            chest: 'chest.png',
            keystoneEmoji: 'keystone%20emoji.png',
            runeEmoji: 'rune%20emoji.png'
        };

        this.total = Object.keys(imageList).length;

        // Show loading screen
        this.showLoadingScreen();

        // Load all images
        const loadPromises = Object.entries(imageList).map(([key, url]) => {
            return this.loadImage(key, url);
        });

        await Promise.all(loadPromises);

        // Hide loading screen
        this.hideLoadingScreen();

        return this.assets.images;
    }

    loadImage(key, url) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                this.assets.images[key] = img;
                this.assets.loaded++;
                this.updateLoadingProgress();
                resolve(img);
            };
            img.onerror = () => {
                console.error(`Failed to load image: ${key} from ${url}`);
                this.assets.loaded++;
                this.updateLoadingProgress();
                resolve(null); // Don't block loading on failed images
            };
            img.src = url;
        });
    }

    showLoadingScreen() {
        const loadingDiv = document.createElement('div');
        loadingDiv.id = 'preloader-screen';
        loadingDiv.innerHTML = `
            <div style="
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: linear-gradient(135deg, rgba(10, 14, 39, 0.9) 0%, rgba(21, 25, 53, 0.9) 100%),
                            url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PHBhdHRlcm4gaWQ9ImdyaWQiIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgcGF0dGVyblVuaXRzPSJ1c2VyU3BhY2VPblVzlIj48cGF0aCBkPSJNIDQwIDAgTCAwIDAgMCA0MCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNjM2NmYxIiBzdHJva2Utd2lkdGg9IjAuNSIgb3BhY2l0eT0iMC4xIi8+PC9wYXR0ZXJuPjwvZGVmcz48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSJ1cmwoI2dyaWQpIiAvPjwvc3ZnPg==');
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                font-family: 'Orbitron', sans-serif;
            ">
                <h1 style="color: #f59e0b; margin-bottom: 30px;">LOADING DUNGEON ASSETS</h1>
                <div style="
                    width: 300px;
                    height: 20px;
                    background: rgba(99, 102, 241, 0.2);
                    border: 2px solid rgba(99, 102, 241, 0.5);
                    border-radius: 10px;
                    overflow: hidden;
                ">
                    <div id="loading-bar" style="
                        width: 0%;
                        height: 100%;
                        background: linear-gradient(90deg, #6366f1 0%, #8b5cf6 100%);
                        transition: width 0.3s ease;
                    "></div>
                </div>
                <p id="loading-text" style="color: #94a3b8; margin-top: 20px;">Loading... 0%</p>
            </div>
        `;
        document.body.appendChild(loadingDiv);
    }

    updateLoadingProgress() {
        const percent = Math.round((this.assets.loaded / this.total) * 100);
        const bar = document.getElementById('loading-bar');
        const text = document.getElementById('loading-text');
        if (bar) bar.style.width = percent + '%';
        if (text) text.textContent = `Loading... ${percent}%`;
    }

    hideLoadingScreen() {
        const loader = document.getElementById('preloader-screen');
        if (loader) {
            loader.style.opacity = '0';
            loader.style.transition = 'opacity 0.5s ease';
            setTimeout(() => loader.remove(), 500);
        }
    }
}

// Initialize and load assets when game starts
let gameAssets = {};

        // Dungeon room types
const ROOM_TYPES = {
            ENTRANCE: 'entrance',
            NORMAL: 'normal',
            TREASURE: 'treasure',
            BOSS: 'boss',
            EMPTY: 'empty',
            PATHWAY: 'pathway',
            FOUNTAIN: 'fountain'
        };

        // Chest system constants
const CHEST_CONFIG = {
    DROP_CHANCE: 0.10,              // 10% chance per cleared floor (~1 every 10 floors)
    MYTHIC_CHEST_CHANCE: 0.10,      // 10% of chests are mythic (1% overall)
    OPEN_COST_MULTIPLIER: 500,      // Open cost = 500 √ó chest level
    MYTHIC_OPEN_COST_MULTIPLIER: 2500, // Mythic chest cost = 2500 √ó level
    SELL_VALUE_MULTIPLIER: 100,     // Sell value = 100 √ó chest level
    MYTHIC_SELL_VALUE_MULTIPLIER: 500, // Mythic sell value = 500 √ó level
    RARITY_DISTRIBUTION: {
        rare: 75,                    // 75% chance
        epic: 20,                    // 20% chance
        legendary: 5                 // 5% chance
    },
    MYTHIC_RARITY_DISTRIBUTION: {
        epic: 50,                    // 50% chance
        legendary: 49.9,             // 49.9% chance
        mythic: 0.1                  // 0.1% chance
    }
};

        // Keystone system constants
        const KEYSTONE_CONFIG = {
    DROP_CHANCE: 0.02,              // 2% chance per cleared floor
    DIFFICULTY_MULTIPLIER: 5,        // Vault enemies are 5x harder than normal
    RARITY_BOOST: {
        rare: 60,                    // 60% rare
        epic: 30,                    // 30% epic
        legendary: 10                // 10% legendary (no common/uncommon)
    },
    RARITY_BOOST_LVL20: {
        rare: 59.9,                  // 59.9% rare
        epic: 30,                    // 30% epic
        legendary: 10,               // 10% legendary
        mythic: 0.1                  // 0.1% mythic (Level 20 Vault only)
    }
};

// Vault Key system constants
const VAULT_KEY_CONFIG = {
    DROP_CHANCE: 0.10,             // 10% chance per cleared floor to find a key
    MAX_KEY_LEVEL: 20,             // Keys cap at level 20
    GOLD_PER_LEVEL: 200            // 200 gold per vault level
};

// Rune Trial Key system constants
const RUNE_TRIAL_KEY_CONFIG = {
    DROP_CHANCE: 0.10,             // 10% chance per cleared floor
    MIN_DROP_FLOOR: 45,            // Keys only start dropping after floor 45
    MAX_KEY_LEVEL: 5,              // Only 5 levels of keys
    RECOMMENDED_FLOORS: { 1: 50, 2: 60, 3: 70, 4: 80, 5: 90 }
};

// Rune Trial Dungeon constants
const RUNE_TRIAL_CONFIG = {
    LOOT_RARITY: {
        rare: 50,
        epic: 40,
        legendary: 10
    },
    LOOT_RARITY_TIER5: {
        rare: 49.9,
        epic: 40,
        legendary: 10,
        mythic: 0.1  // 0.1% mythic drop chance for Tier 5 only
    },
    LOOT_LEVEL_RANGE: { 1: {min: 50, max: 60}, 2: {min: 60, max: 70}, 3: {min: 70, max: 80}, 4: {min: 80, max: 90}, 5: {min: 90, max: 100} },
    ABILITY_RUNE_CHANCE: 0.40, // 40% ability rune, 60% stat rune
    BOSS_SCALING: { 1: 3.5, 2: 5.5, 3: 7.5, 4: 9.5, 5: 11.6 }
};

        // Vault boss scaling formulas
        const VAULT_SCALER = {
    bossHP:   L => 5000 * L,      // UNCHANGED
    bossATK:  L => 7 * L,         // BUFFED +40%
    bossDEF:  L => 16 * L,        // BUFFED +33%
    si:       L => Math.max(2.4, 4.0 - 0.08*L),  // seconds between summons (after first)
    cap:      L => 4 + Math.floor(L / 7),
    houndHP:  L => 120 * L,
    houndATK: L => 3 * L,
    houndDEF: L => 5 * L,
    houndAS:  1.0
};

        // Isometric helpers with smaller tile size for larger rooms
        const ISO = {
            tileWidth: 48,
            tileHeight: 24,
            toScreen(x, y) {
                return {
                    x: (x - y) * (this.tileWidth / 2),
                    y: (x + y) * (this.tileHeight / 2)
                };
            },
            fromScreen(x, y) {
                return {
                    x: (x / (this.tileWidth / 2) + y / (this.tileHeight / 2)) / 2,
                    y: (y / (this.tileHeight / 2) - x / (this.tileWidth / 2)) / 2
                };
            }
        };

        // Dungeon layout generator
        class DungeonLayout {
            constructor(floor) {
                this.floor = floor;
                this.gridSize = 7;
                this.grid = [];
                this.rooms = [];
                this.currentRoomIndex = 0;
                this.generateLayout();
            }

            generateLayout() {
                // Initialize grid
                for (let y = 0; y < this.gridSize; y++) {
                    this.grid[y] = [];
                    for (let x = 0; x < this.gridSize; x++) {
                        this.grid[y][x] = null;
                    }
                }

                // Place entrance at bottom center
                const entranceX = Math.floor(this.gridSize / 2);
                const entranceY = this.gridSize - 1;
                this.placeRoom(entranceX, entranceY, ROOM_TYPES.ENTRANCE);

                // Generate main path to boss
                const path = this.generatePath(entranceX, entranceY);

                // Place boss at end of path
                const bossPos = path[path.length - 1];
                this.grid[bossPos.y][bossPos.x] = ROOM_TYPES.BOSS;
                this.rooms[this.rooms.length - 1].type = ROOM_TYPES.BOSS;

                // Add side rooms
                this.addSideRooms(path);

                // Connect all rooms
                this.connectRooms();
            }

            generatePath(startX, startY) {
                const path = [{x: startX, y: startY}];
                let x = startX;
                let y = startY;
                const targetY = 0; // Boss should be near top

                while (y > targetY + 1) {
                    // Move up with some randomness
                    const moves = [];
                    if (y > 0) moves.push({x: x, y: y - 1});
                    if (x > 0 && Math.random() > 0.5) moves.push({x: x - 1, y: y});
                    if (x < this.gridSize - 1 && Math.random() > 0.5) moves.push({x: x + 1, y: y});

                    if (moves.length > 0) {
                        const move = moves[Math.floor(Math.random() * moves.length)];
                        x = move.x;
                        y = move.y;
                        path.push({x, y});

                        if (this.grid[y][x] === null) {
                            this.placeRoom(x, y, ROOM_TYPES.NORMAL);
                        }
                    }
                }

                return path;
            }

addSideRooms(mainPath) {
                const sideRoomCount = 3 + Math.floor(Math.random() * 3);
                let placed = 0;
                let fountainPlaced = false;
                let treasurePlaced = false;

                for (let i = 0; i < mainPath.length && placed < sideRoomCount; i++) {
                    const pos = mainPath[i];
                    const neighbors = [
                        {x: pos.x - 1, y: pos.y},
                        {x: pos.x + 1, y: pos.y},
                        {x: pos.x, y: pos.y - 1},
                        {x: pos.x, y: pos.y + 1}
                    ];

                    for (const neighbor of neighbors) {
                        if (neighbor.x >= 0 && neighbor.x < this.gridSize &&
                            neighbor.y >= 0 && neighbor.y < this.gridSize &&
                            this.grid[neighbor.y][neighbor.x] === null &&
                            Math.random() > 0.6) {

                            let type;
                            // Place one Fountain of Youth per dungeon - random placement
                            if (!fountainPlaced && Math.random() < 0.3) {
                                type = ROOM_TYPES.FOUNTAIN;
                                fountainPlaced = true;
                            }
                            // Place one treasure room at 10% chance
                            else if (!treasurePlaced && Math.random() < 0.1) {
                                type = ROOM_TYPES.TREASURE;
                                treasurePlaced = true;
                            }
                            else {
                                type = ROOM_TYPES.NORMAL;
                            }

                            this.placeRoom(neighbor.x, neighbor.y, type);
                            placed++;
                            break;
                        }
                    }
                }
            }

            placeRoom(x, y, type) {
                this.grid[y][x] = type;
                this.rooms.push({
                    x: x,
                    y: y,
                    type: type,
                    visited: false,
                    cleared: false,
                    connections: []
                });
            }

            connectRooms() {
                // Connect adjacent rooms
                for (let room of this.rooms) {
                    const neighbors = [
                        {x: room.x - 1, y: room.y},
                        {x: room.x + 1, y: room.y},
                        {x: room.x, y: room.y - 1},
                        {x: room.x, y: room.y + 1}
                    ];

                    for (const neighbor of neighbors) {
                        if (neighbor.x >= 0 && neighbor.x < this.gridSize &&
                            neighbor.y >= 0 && neighbor.y < this.gridSize &&
                            this.grid[neighbor.y][neighbor.x] !== null) {
                            room.connections.push(neighbor);
                        }
                    }
                }
            }

            getCurrentRoom() {
                return this.rooms[this.currentRoomIndex];
            }

            moveToRoom(x, y) {
                const roomIndex = this.rooms.findIndex(r => r.x === x && r.y === y);
                if (roomIndex !== -1) {
                    this.currentRoomIndex = roomIndex;
                    this.rooms[roomIndex].visited = true;
                    return this.rooms[roomIndex];
                }
                return null;
            }
        }

        // Character sprite class
        class CharacterSprite {
    constructor(x, y, color, type) {
        this.gridX = x;
        this.gridY = y;
        this.color = color;
        this.type = type;
        this.offsetY = 0;
        this.animTimer = Math.random() * Math.PI * 2;
        this.attacking = false;
        this.attackTimer = 0;

        // Combat positioning
        this.combatX = x;
        this.combatY = y;
                this.targetX = x;
                this.targetY = y;
                this.moveSpeed = 0.027; // Slowed down 3x (was 0.08)
                this.isMoving = false;

                const pos = ISO.toScreen(x, y);
                this.screenX = pos.x;
                this.screenY = pos.y;
            }

            update() {
                this.animTimer += 0.1;
                this.offsetY = Math.sin(this.animTimer) * 2;

                if (this.attacking) {
                    this.attackTimer++;
                    if (this.attackTimer > 15) {
                        this.attacking = false;
                        this.attackTimer = 0;
                    }
                }

                // Move towards target position
                const dx = this.targetX - this.gridX;
                const dy = this.targetY - this.gridY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 0.1) {
                    this.isMoving = true;
                    this.gridX += dx * this.moveSpeed;
                    this.gridY += dy * this.moveSpeed;
                } else {
                    this.isMoving = false;
                    this.gridX = this.targetX;
                    this.gridY = this.targetY;
                }

                // Boundary constraints for special dungeons (Rune Trial, Vault, Divine Arena)
                if (window.game && (window.game.currentDungeon === 'runetrial' ||
                    window.game.currentDungeon === 'vault' ||
                    window.game.currentDungeon === 'endlessblessings')) {
                    // Get grid size from the room
                    const gridSize = window.game.room ? (window.game.room.width || 30) : 30;
                    const minX = 0;
                    const maxX = gridSize - 1;
                    const minY = 0;
                    const maxY = gridSize - 1;

                    // Clamp position within bounds
                    this.gridX = Math.max(minX, Math.min(maxX, this.gridX));
                    this.gridY = Math.max(minY, Math.min(maxY, this.gridY));
                    this.targetX = Math.max(minX, Math.min(maxX, this.targetX));
                    this.targetY = Math.max(minY, Math.min(maxY, this.targetY));
                }

                // Smooth screen position update
                const targetPos = ISO.toScreen(this.gridX, this.gridY);
                this.screenX += (targetPos.x - this.screenX) * 0.2;
                this.screenY += (targetPos.y - this.screenY) * 0.2;
            }

            draw(ctx, offsetX, offsetY) {
    const x = this.screenX + offsetX;
    const y = this.screenY + offsetY + this.offsetY;

    // Store screen position for hover detection
    this.screenDrawX = x;
    this.screenDrawY = y;

    // Shadow (larger for bosses)
const enemy = this.type === 'enemy' ? window.game?.enemies?.find(e => e.sprite === this) : null;
const isBoss = enemy && (enemy.isRuneTrialBoss || enemy.name === 'Keystone Warden' || enemy.name === 'Rune Guardian' || enemy.name === 'Treasure Guardian');
const shadowSize = isBoss ? 35 : 12;
const shadowOpacity = isBoss ? 0.5 : 0.3;

ctx.fillStyle = `rgba(0,0,0,${shadowOpacity})`;
ctx.beginPath();
ctx.ellipse(x, y + 20, shadowSize, shadowSize * 0.5, 0, 0, Math.PI * 2);
ctx.fill();

                // Draw based on class for party members
                if (this.type === 'party') {
                    // Different drawing for each class
                    if (this.classSymbol === 'üõ°') { // Tank
                        // Heavy armor body
                        ctx.fillStyle = '#71717a';
                        ctx.fillRect(x - 11, y - 10, 22, 22);

                        // Armor details
                        ctx.fillStyle = '#52525b';
                        ctx.fillRect(x - 9, y - 8, 18, 4);
                        ctx.fillRect(x - 9, y + 4, 18, 4);

                        // Shield
                        ctx.fillStyle = '#a1a1aa';
                        ctx.fillRect(x - 15, y - 6, 5, 12);

                        // Sword
                        ctx.fillStyle = '#d4d4d8';
                        ctx.fillRect(x + 10, y - 12, 2, 18);
                        ctx.fillRect(x + 8, y - 2, 6, 2);

                        // Head with helmet
                        ctx.fillStyle = '#71717a';
                        ctx.fillRect(x - 9, y - 20, 18, 12);
                        ctx.fillStyle = '#fdbcb4';
                        ctx.fillRect(x - 6, y - 16, 12, 6);

                    } else if (this.classSymbol === 'üíä') { // Healer
                        // Robes (flowing)
                        ctx.fillStyle = '#f0fdf4';
                        ctx.beginPath();
                        ctx.moveTo(x - 12, y + 10);
                        ctx.lineTo(x - 8, y - 8);
                        ctx.lineTo(x + 8, y - 8);
                        ctx.lineTo(x + 12, y + 10);
                        ctx.closePath();
                        ctx.fill();

                        // Robe details
                        ctx.fillStyle = '#10b981';
                        ctx.fillRect(x - 2, y - 8, 4, 18);
                        ctx.fillRect(x - 8, y + 6, 16, 2);

                        // Staff
                        ctx.strokeStyle = '#84cc16';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x + 8, y - 15);
                        ctx.lineTo(x + 8, y + 12);
                        ctx.stroke();
                        // Staff orb
                        ctx.fillStyle = '#86efac';
                        ctx.beginPath();
                        ctx.arc(x + 8, y - 16, 3, 0, Math.PI * 2);
                        ctx.fill();

                        // Head with hood
                        ctx.fillStyle = '#10b981';
                        ctx.fillRect(x - 9, y - 20, 18, 14);
                        ctx.fillStyle = '#fdbcb4';
                        ctx.fillRect(x - 6, y - 16, 12, 8);

                    } else if (this.classSymbol === 'üîÆ') { // Mage
                        // Wizard robes
                        ctx.fillStyle = '#312e81';
                        ctx.beginPath();
                        ctx.moveTo(x - 12, y + 10);
                        ctx.lineTo(x - 8, y - 8);
                        ctx.lineTo(x + 8, y - 8);
                        ctx.lineTo(x + 12, y + 10);
                        ctx.closePath();
                        ctx.fill();

                        // Robe trim
                        ctx.fillStyle = '#8b5cf6';
                        ctx.fillRect(x - 2, y - 8, 4, 18);

                        // Wand
                        ctx.strokeStyle = '#a78bfa';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x - 8, y - 10);
                        ctx.lineTo(x - 8, y + 8);
                        ctx.stroke();
                        // Wand star
                        ctx.fillStyle = '#c4b5fd';
                        ctx.beginPath();
                        ctx.arc(x - 8, y - 12, 3, 0, Math.PI * 2);
                        ctx.fill();

                        // Head with hat
                        ctx.fillStyle = '#312e81';
                        ctx.fillRect(x - 10, y - 22, 20, 4);
                        ctx.fillRect(x - 6, y - 26, 12, 4);
                        ctx.fillStyle = '#fdbcb4';
                        ctx.fillRect(x - 6, y - 18, 12, 8);

                    } else if (this.classSymbol === 'üó°') { // Rogue
                        // Light armor/cloak
                        ctx.fillStyle = '#450a0a';
                        ctx.fillRect(x - 10, y - 10, 20, 20);

                        // Armor details
                        ctx.fillStyle = '#7f1d1d';
                        ctx.fillRect(x - 8, y - 6, 16, 2);
                        ctx.fillRect(x - 8, y + 2, 16, 2);

                        // Dual daggers
                        ctx.fillStyle = '#d4d4d8';
                        ctx.fillRect(x - 12, y - 4, 2, 10);
                        ctx.fillRect(x + 10, y - 4, 2, 10);
                        ctx.fillRect(x - 14, y - 2, 6, 2);
                        ctx.fillRect(x + 8, y - 2, 6, 2);

                        // Head with hood
                        ctx.fillStyle = '#450a0a';
                        ctx.fillRect(x - 9, y - 20, 18, 12);
                        ctx.fillStyle = '#fdbcb4';
                        ctx.fillRect(x - 6, y - 16, 12, 6);

                    } else if (this.classSymbol === 'üèπ') { // Archer
                        // Leather armor body
                        ctx.fillStyle = '#78350f';
                        ctx.fillRect(x - 10, y - 10, 20, 20);

                        // Armor details (leather straps)
                        ctx.fillStyle = '#92400e';
                        ctx.fillRect(x - 8, y - 8, 16, 2);
                        ctx.fillRect(x - 8, y, 16, 2);
                        ctx.fillRect(x - 8, y + 6, 16, 2);

                        // Quiver on back (LEFT SIDE - SWAPPED)
                        ctx.fillStyle = '#451a03';
                        ctx.fillRect(x - 12, y - 12, 6, 14);
                        // Arrows in quiver
                        ctx.fillStyle = '#84cc16';
                        ctx.fillRect(x - 11, y - 14, 1, 4);
                        ctx.fillRect(x - 9, y - 13, 1, 3);
                        ctx.fillRect(x - 7, y - 12, 1, 2);

                        // Bow (RIGHT SIDE - SWAPPED) - pullback when attacking
                        const bowPull = this.attacking ? (this.attackTimer / 15) * 6 : 0;
                        ctx.strokeStyle = '#92400e';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x + 12, y - 10);
                        ctx.quadraticCurveTo(x + 16 - bowPull, y, x + 12, y + 10);
                        ctx.stroke();
                        // Bow string - pulls back when attacking
                        ctx.strokeStyle = '#d4d4d8';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(x + 12, y - 10);
                        ctx.lineTo(x + 12 - bowPull, y);
                        ctx.lineTo(x + 12, y + 10);
                        ctx.stroke();

                        // Arrow ready (in hand) - visible when not attacking or just starting attack
                        if (!this.attacking || this.attackTimer < 10) {
                            ctx.fillStyle = '#84cc16';
                            ctx.fillRect(x + 4 + bowPull, y - 1, 8 - bowPull, 2);
                            ctx.fillStyle = '#78716c';
                            ctx.beginPath();
                            ctx.moveTo(x + 12 - bowPull, y);
                            ctx.lineTo(x + 15 - bowPull, y - 2);
                            ctx.lineTo(x + 15 - bowPull, y + 2);
                            ctx.closePath();
                            ctx.fill();
                        }

                        // Head with ranger hood
                        ctx.fillStyle = '#15803d';
                        ctx.fillRect(x - 9, y - 20, 18, 12);
                        ctx.fillStyle = '#fdbcb4';
                        ctx.fillRect(x - 6, y - 16, 12, 6);
                        // Hood point
                        ctx.fillStyle = '#15803d';
                        ctx.beginPath();
                        ctx.moveTo(x - 9, y - 20);
                        ctx.lineTo(x, y - 24);
                        ctx.lineTo(x + 9, y - 20);
                        ctx.fill();

                    } else if (this.classSymbol === '‚öîÔ∏è') { // Paladin
                        // Holy plate armor body
                        ctx.fillStyle = '#e0e7ff';
                        ctx.fillRect(x - 11, y - 10, 22, 22);

                        // Golden trim
                        ctx.fillStyle = '#fbbf24';
                        ctx.fillRect(x - 12, y - 11, 24, 2);
                        ctx.fillRect(x - 12, y - 1, 24, 2);
                        ctx.fillRect(x - 12, y + 9, 24, 2);

                        // Holy symbol on chest
                        ctx.fillStyle = '#fbbf24';
                        ctx.fillRect(x - 2, y - 6, 4, 12);
                        ctx.fillRect(x - 6, y - 2, 12, 4);
                        // Symbol glow
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = '#fbbf24';
                        ctx.fillStyle = '#fef3c7';
                        ctx.fillRect(x - 1, y - 5, 2, 10);
                        ctx.fillRect(x - 5, y - 1, 10, 2);
                        ctx.shadowBlur = 0;

                        // Holy sword (right side) - swings when attacking
                        const swordAngle = this.attacking ? Math.sin(this.attackTimer / 15 * Math.PI) * 0.5 : 0;
                        const swordOffset = this.attacking ? Math.sin(this.attackTimer / 15 * Math.PI) * 8 : 0;

                        ctx.save();
                        ctx.translate(x + 11, y - 2);
                        ctx.rotate(swordAngle);

                        // Sword blade
                        ctx.fillStyle = '#c0c0c0';
                        ctx.fillRect(0, -12 + swordOffset, 3, 22);
                        // Sword crossguard
                        ctx.fillStyle = '#fbbf24';
                        ctx.fillRect(-2, -2 + swordOffset, 7, 3);

                        // Sword glow effect (stronger when attacking)
                        const glowIntensity = this.attacking ? 0.8 : 0.3;
                        ctx.strokeStyle = `rgba(254, 243, 199, ${glowIntensity})`;
                        ctx.lineWidth = this.attacking ? 3 : 1;
                        ctx.shadowBlur = this.attacking ? 12 : 6;
                        ctx.shadowColor = '#fbbf24';
                        ctx.strokeRect(0.5, -11 + swordOffset, 2, 20);
                        ctx.shadowBlur = 0;

                        // Slash trail when attacking
                        if (this.attacking && this.attackTimer > 5 && this.attackTimer < 12) {
                            ctx.strokeStyle = 'rgba(251, 191, 36, 0.5)';
                            ctx.lineWidth = 4;
                            ctx.beginPath();
                            ctx.arc(0, 0, 20, -Math.PI / 3, Math.PI / 3);
                            ctx.stroke();
                        }

                        ctx.restore();

                        // Shield (left side)
                        ctx.fillStyle = '#3b82f6';
                        ctx.fillRect(x - 16, y - 8, 6, 14);
                        // Shield cross
                        ctx.fillStyle = '#fbbf24';
                        ctx.fillRect(x - 15, y - 6, 4, 10);
                        ctx.fillRect(x - 17, y - 2, 8, 2);

                        // Shoulder plates
                        ctx.fillStyle = '#fbbf24';
                        ctx.fillRect(x - 14, y - 11, 6, 4);
                        ctx.fillRect(x + 8, y - 11, 6, 4);

                        // Head with holy helm
                        ctx.fillStyle = '#e0e7ff';
                        ctx.fillRect(x - 9, y - 20, 18, 12);
                        // Helm glow
                        ctx.fillStyle = '#fbbf24';
                        ctx.fillRect(x - 10, y - 21, 20, 2);
                        // Face
                        ctx.fillStyle = '#fdbcb4';
                        ctx.fillRect(x - 6, y - 16, 12, 6);
                        // Divine halo effect
                        ctx.strokeStyle = '#fef3c7';
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#fbbf24';
                        ctx.beginPath();
                        ctx.arc(x, y - 22, 10, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                } else {
    // Enemy sprites based on type
    let enemyName = this.type === 'enemy' ? (window.game?.enemies?.find(e => e.sprite === this)?.name || '') : '';

    // Also check runeTrialBoss if not in enemies array yet
    if (!enemyName && window.game?.runeTrialBoss?.sprite === this) {
        enemyName = window.game.runeTrialBoss.name;
    }

    // CRITICAL: Fallback for Treasure Guardian (only if no other name found)
    if (!enemyName && this.color === '#f59e0b') {
        enemyName = 'Treasure Guardian';

    }



    // Enemy rendering


    // FORCE TREASURE GUARDIAN CHECK BY COLOR (PRIORITY)
    if (this.color === '#f59e0b' && (enemyName === 'Treasure Guardian' || !enemyName)) {
        // TREASURE GUARDIAN - MASSIVE 4X SIZE with bags of gold
        const scale = 1.0;;
        console.log('üí∞üí∞üí∞ RENDERING TREASURE GUARDIAN! Scale:', scale);

        // Larger golden aura
        const auraGradient = ctx.createRadialGradient(x, y, 0, x, y, 50 * scale);
        auraGradient.addColorStop(0, 'rgba(245, 158, 11, 0.4)');
        auraGradient.addColorStop(1, 'rgba(245, 158, 11, 0)');
        ctx.fillStyle = auraGradient;
        ctx.beginPath();
        ctx.arc(x, y, 50 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Massive armored body
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 16 * scale, y - 10 * scale, 32 * scale, 20 * scale);

        // Armor plating
        ctx.fillStyle = '#1a1300';
        ctx.fillRect(x - 13 * scale, y - 8 * scale, 26 * scale, 3 * scale);
        ctx.fillRect(x - 13 * scale, y - 2 * scale, 26 * scale, 3 * scale);
        ctx.fillRect(x - 13 * scale, y + 4 * scale, 26 * scale, 3 * scale);

        // Golden trim
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(x - 14 * scale, y - 9 * scale, 28 * scale, 2 * scale);
        ctx.fillRect(x - 14 * scale, y - 1 * scale, 28 * scale, 2 * scale);
        ctx.fillRect(x - 14 * scale, y + 5 * scale, 28 * scale, 2 * scale);

        // Shoulders
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 22 * scale, y - 9 * scale, 8 * scale, 12 * scale);
        ctx.fillRect(x + 14 * scale, y - 9 * scale, 8 * scale, 12 * scale);

        // Golden spikes
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(x - 21 * scale, y - 12 * scale, 3 * scale, 4 * scale);
        ctx.fillRect(x - 17 * scale, y - 14 * scale, 3 * scale, 6 * scale);
        ctx.fillRect(x - 13 * scale, y - 12 * scale, 3 * scale, 4 * scale);
        ctx.fillRect(x + 11 * scale, y - 12 * scale, 3 * scale, 4 * scale);
        ctx.fillRect(x + 15 * scale, y - 14 * scale, 3 * scale, 6 * scale);
        ctx.fillRect(x + 19 * scale, y - 12 * scale, 3 * scale, 4 * scale);

        // Helmet
        ctx.fillStyle = '#1a1300';
        ctx.fillRect(x - 10 * scale, y - 18 * scale, 20 * scale, 10 * scale);

        // Crown
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(x - 12 * scale, y - 24 * scale, 6 * scale, 6 * scale);
        ctx.fillRect(x - 5 * scale, y - 27 * scale, 5 * scale, 9 * scale);
        ctx.fillRect(x + 1 * scale, y - 28 * scale, 5 * scale, 10 * scale);
        ctx.fillRect(x + 7 * scale, y - 24 * scale, 6 * scale, 6 * scale);

        // Face plate
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(x - 9 * scale, y - 17 * scale, 18 * scale, 9 * scale);
        ctx.fillStyle = '#1a1300';
        ctx.fillRect(x - 7 * scale, y - 15 * scale, 14 * scale, 5 * scale);

        // Glowing eyes
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 15 * scale;
        ctx.shadowColor = '#f59e0b';
        ctx.fillRect(x - 6 * scale, y - 14 * scale, 4 * scale, 4 * scale);
        ctx.fillRect(x + 2 * scale, y - 14 * scale, 4 * scale, 4 * scale);
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(x - 5 * scale, y - 13 * scale, 2 * scale, 2 * scale);
        ctx.fillRect(x + 3 * scale, y - 13 * scale, 2 * scale, 2 * scale);
        ctx.shadowBlur = 0;

        // BAGS OF GOLD - left hand
        ctx.fillStyle = '#8b7355';
        ctx.fillRect(x - 28 * scale, y - 2 * scale, 10 * scale, 14 * scale);
        ctx.fillRect(x - 26 * scale, y - 4 * scale, 6 * scale, 3 * scale);
        ctx.fillStyle = '#6a5a45';
        ctx.fillRect(x - 25 * scale, y - 5 * scale, 4 * scale, 2 * scale);

        // Gold coins spilling
        ctx.fillStyle = '#fbbf24';
        ctx.beginPath();
        ctx.arc(x - 26 * scale, y + 11 * scale, 2 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x - 22 * scale, y + 10 * scale, 2 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x - 24 * scale, y + 8 * scale, 1.5 * scale, 0, Math.PI * 2);
        ctx.fill();

        // WAR HAMMER - right hand
        ctx.fillStyle = '#71717a';
        ctx.fillRect(x + 17 * scale, y - 25 * scale, 4 * scale, 40 * scale);
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(x + 12 * scale, y - 28 * scale, 14 * scale, 8 * scale);
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(x + 13 * scale, y - 27 * scale, 12 * scale, 6 * scale);

        // Hammer spikes
        ctx.fillStyle = '#c0c0c0';
        ctx.fillRect(x + 10 * scale, y - 26 * scale, 3 * scale, 4 * scale);
        ctx.fillRect(x + 25 * scale, y - 26 * scale, 3 * scale, 4 * scale);
        ctx.fillRect(x + 17 * scale, y - 30 * scale, 4 * scale, 3 * scale);

        // Chest emblem
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(x - 6 * scale, y - 4 * scale, 12 * scale, 8 * scale);
        ctx.fillStyle = '#1a1300';
        ctx.fillRect(x - 5 * scale, y - 3 * scale, 10 * scale, 6 * scale);

        // Glowing gem
        ctx.fillStyle = 'rgba(245, 158, 11, 0.9)';
        ctx.shadowBlur = 12 * scale;
        ctx.shadowColor = '#f59e0b';
        ctx.beginPath();
        ctx.arc(x, y + 5 * scale, 3 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    } else if (enemyName === 'Rune Guardian') {
        // RUNE GUARDIAN - ANCIENT NIGHTMARE
        const scale = 2.8; // Even BIGGER

        // Ominous purple void aura (multi-layered)
        for (let i = 3; i > 0; i--) {
            const auraGradient = ctx.createRadialGradient(x, y, 0, x, y, 35 * scale * i * 0.4);
            auraGradient.addColorStop(0, `rgba(88, 28, 135, ${0.2 * i})`);
            auraGradient.addColorStop(0.5, `rgba(109, 40, 217, ${0.15 * i})`);
            auraGradient.addColorStop(1, 'rgba(109, 40, 217, 0)');
            ctx.fillStyle = auraGradient;
            ctx.beginPath();
            ctx.arc(x, y, 35 * scale * i * 0.4, 0, Math.PI * 2);
            ctx.fill();
        }

        // Void tendrils emanating from body
        const time = Date.now() / 500;
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI * 2 * i / 6) + time;
            const tendrilLength = 20 * scale + Math.sin(time + i) * 8 * scale;
            ctx.strokeStyle = `rgba(168, 85, 247, ${0.4 + Math.sin(time + i) * 0.2})`;
            ctx.lineWidth = 3 * scale;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.quadraticCurveTo(
                x + Math.cos(angle) * tendrilLength * 0.6,
                y + Math.sin(angle) * tendrilLength * 0.4,
                x + Math.cos(angle) * tendrilLength,
                y + Math.sin(angle) * tendrilLength
            );
            ctx.stroke();
        }

        // Main body - dark void armor
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 20 * scale, y - 14 * scale, 40 * scale, 28 * scale);

        // Void cracks/energy seeping through armor
        ctx.fillStyle = '#6b21a8';
        ctx.fillRect(x - 18 * scale, y - 10 * scale, 3 * scale, 24 * scale);
        ctx.fillRect(x + 15 * scale, y - 10 * scale, 3 * scale, 24 * scale);
        ctx.fillRect(x - 15 * scale, y - 2 * scale, 30 * scale, 2 * scale);

        // Chest core - pulsing void energy
        const voidPulse = 0.5 + Math.sin(Date.now() / 300) * 0.5;
        ctx.fillStyle = `rgba(168, 85, 247, ${voidPulse})`;
        ctx.shadowBlur = 30;
        ctx.shadowColor = '#a855f7';
        ctx.beginPath();
        ctx.arc(x, y, 8 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Spiked shoulder plates
        ctx.fillStyle = '#0f0520';
        // Left shoulder
        ctx.fillRect(x - 30 * scale, y - 12 * scale, 15 * scale, 20 * scale);
        ctx.fillRect(x - 32 * scale, y - 16 * scale, 4 * scale, 8 * scale);
        ctx.fillRect(x - 28 * scale, y - 18 * scale, 4 * scale, 10 * scale);
        ctx.fillRect(x - 24 * scale, y - 16 * scale, 4 * scale, 8 * scale);
        // Right shoulder
        ctx.fillRect(x + 15 * scale, y - 12 * scale, 15 * scale, 20 * scale);
        ctx.fillRect(x + 28 * scale, y - 16 * scale, 4 * scale, 8 * scale);
        ctx.fillRect(x + 24 * scale, y - 18 * scale, 4 * scale, 10 * scale);
        ctx.fillRect(x + 20 * scale, y - 16 * scale, 4 * scale, 8 * scale);

        // Helmet - ancient and menacing
        ctx.fillStyle = '#050114';
        ctx.fillRect(x - 14 * scale, y - 24 * scale, 28 * scale, 16 * scale);

        // Face plate with runes
        ctx.fillStyle = '#1e1b4b';
        ctx.fillRect(x - 12 * scale, y - 22 * scale, 24 * scale, 12 * scale);

        // Massive curved demon horns
        ctx.fillStyle = '#000000';
        // Left horn
        ctx.fillRect(x - 18 * scale, y - 30 * scale, 7 * scale, 14 * scale);
        ctx.fillRect(x - 20 * scale, y - 32 * scale, 5 * scale, 10 * scale);
        // Right horn
        ctx.fillRect(x + 11 * scale, y - 30 * scale, 7 * scale, 14 * scale);
        ctx.fillRect(x + 15 * scale, y - 32 * scale, 5 * scale, 10 * scale);

        // Horn glow
        ctx.fillStyle = 'rgba(168, 85, 247, 0.3)';
        ctx.fillRect(x - 17 * scale, y - 28 * scale, 5 * scale, 10 * scale);
        ctx.fillRect(x + 12 * scale, y - 28 * scale, 5 * scale, 10 * scale);

        // DEMONIC RED EYES - SOUL-PIERCING
        ctx.fillStyle = '#ff0000';
        ctx.shadowBlur = 35;
        ctx.shadowColor = '#dc2626';
        ctx.fillRect(x - 10 * scale, y - 18 * scale, 6 * scale, 6 * scale);
        ctx.fillRect(x + 4 * scale, y - 18 * scale, 6 * scale, 6 * scale);

        // Eye cores (brighter)
        ctx.fillStyle = '#fef3c7';
        ctx.fillRect(x - 8 * scale, y - 16 * scale, 2 * scale, 2 * scale);
        ctx.fillRect(x + 6 * scale, y - 16 * scale, 2 * scale, 2 * scale);
        ctx.shadowBlur = 0;

        // Ancient glowing runes on armor (multiple, animated)
        const runePulse = 0.4 + Math.sin(Date.now() / 400) * 0.4;
        ctx.fillStyle = `rgba(139, 92, 246, ${runePulse})`;
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#8b5cf6';
        // Chest runes
        ctx.fillRect(x - 8 * scale, y - 8 * scale, 4 * scale, 4 * scale);
        ctx.fillRect(x + 4 * scale, y - 8 * scale, 4 * scale, 4 * scale);
        ctx.fillRect(x - 3 * scale, y + 2 * scale, 6 * scale, 6 * scale);
        // Shoulder runes
        ctx.fillRect(x - 24 * scale, y - 6 * scale, 3 * scale, 3 * scale);
        ctx.fillRect(x + 21 * scale, y - 6 * scale, 3 * scale, 3 * scale);
        ctx.shadowBlur = 0;

        // Floating void particles around boss
        for (let i = 0; i < 8; i++) {
            const particleAngle = (Math.PI * 2 * i / 8) + time * 0.5;
            const particleRadius = 40 * scale + Math.sin(time * 2 + i) * 5 * scale;
            const px = x + Math.cos(particleAngle) * particleRadius;
            const py = y + Math.sin(particleAngle) * particleRadius;
            ctx.fillStyle = `rgba(168, 85, 247, ${0.6 + Math.sin(time * 3 + i) * 0.3})`;
            ctx.beginPath();
            ctx.arc(px, py, 2 * scale, 0, Math.PI * 2);
            ctx.fill();
        }
    } else if (enemyName.includes('Wolf')) {
        // Wolf - fierce predator
        const wolfDark = this.color;
        const wolfLight = '#' + this.color.slice(1).split('').map(c => Math.min(15, parseInt(c, 16) + 3).toString(16)).join('');

        // Body with fur texture
        ctx.fillStyle = wolfDark;
        ctx.fillRect(x - 13, y - 9, 26, 14);

        // Fur details (darker stripes)
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(x - 11, y - 7, 2, 10);
        ctx.fillRect(x - 6, y - 7, 2, 10);
        ctx.fillRect(x + 4, y - 7, 2, 10);
        ctx.fillRect(x + 9, y - 7, 2, 10);

        // Head with snout
        ctx.fillStyle = wolfDark;
        ctx.fillRect(x - 16, y - 11, 10, 10);
        // Snout protruding
        ctx.fillRect(x - 19, y - 8, 5, 4);

        // Ears (pointed)
        ctx.fillRect(x - 15, y - 14, 3, 4);
        ctx.fillRect(x - 10, y - 14, 3, 4);

        // Fierce open mouth
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 18, y - 7, 3, 2);
        ctx.fillStyle = '#fff';
        ctx.fillRect(x - 18, y - 6, 1, 1);
        ctx.fillRect(x - 16, y - 6, 1, 1);

        // Muscular legs
        ctx.fillStyle = wolfDark;
        ctx.fillRect(x - 11, y + 5, 4, 7);
        ctx.fillRect(x - 4, y + 5, 4, 7);
        ctx.fillRect(x + 3, y + 5, 4, 7);
        ctx.fillRect(x + 10, y + 5, 4, 7);

        // Paws (darker)
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(x - 11, y + 11, 4, 2);
        ctx.fillRect(x - 4, y + 11, 4, 2);
        ctx.fillRect(x + 3, y + 11, 4, 2);
        ctx.fillRect(x + 10, y + 11, 4, 2);

        // Bushy tail (curved)
        ctx.fillRect(x + 13, y - 7, 3, 3);
        ctx.fillRect(x + 15, y - 9, 3, 3);
        ctx.fillRect(x + 17, y - 10, 3, 3);

        // Glowing red eyes
        ctx.fillStyle = '#ff0000';
        ctx.shadowBlur = 8;
        ctx.shadowColor = '#ff0000';
        ctx.fillRect(x - 14, y - 10, 3, 3);
        ctx.fillRect(x - 10, y - 10, 3, 3);
        ctx.shadowBlur = 0;
    } else if (enemyName.includes('Bandit') || enemyName.includes('Cutthroat')) {
        // Bandit - dangerous rogue

        // Tattered cloak with detail
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 11, y - 9, 22, 19);

        // Cloak tears and patches
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 9, y - 6, 3, 4);
        ctx.fillRect(x + 6, y - 4, 3, 5);
        ctx.fillRect(x - 2, y + 6, 2, 3);

        // Belt with pouches
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(x - 10, y + 2, 20, 2);
        ctx.fillRect(x - 8, y + 3, 3, 4);
        ctx.fillRect(x + 5, y + 3, 3, 4);

        // Leather armor underneath
        ctx.fillStyle = '#4a3020';
        ctx.fillRect(x - 7, y - 6, 14, 8);

        // Hood (deep and menacing)
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 10, y - 20, 20, 14);

        // Face partially hidden
        ctx.fillStyle = '#fdbcb4';
        ctx.fillRect(x - 6, y - 15, 12, 7);

        // Menacing eyes
        ctx.fillStyle = '#000';
        ctx.fillRect(x - 5, y - 13, 2, 2);
        ctx.fillRect(x + 3, y - 13, 2, 2);

        // Face mask/bandana
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(x - 6, y - 10, 12, 3);

        // Wicked curved dagger
        ctx.fillStyle = '#c0c0c0';
        ctx.fillRect(x + 11, y - 6, 2, 10);
        ctx.fillRect(x + 12, y - 8, 3, 3);
        // Blood stain on blade
        ctx.fillStyle = '#8b0000';
        ctx.fillRect(x + 11, y - 4, 2, 2);

        // Dagger handle (wrapped grip)
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(x + 9, y - 1, 6, 3);
    } else if (enemyName.includes('Boar')) {
        // Boar - aggressive beast

        // Massive bristly body
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 15, y - 11, 30, 18);

        // Bristle texture (spiky fur)
        ctx.fillStyle = '#2a2020';
        for (let i = 0; i < 8; i++) {
            ctx.fillRect(x - 13 + i * 3, y - 13, 2, 3);
        }

        // Muscular shoulders
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 16, y - 9, 6, 10);
        ctx.fillRect(x + 10, y - 9, 6, 10);

        // Large head
        ctx.fillRect(x - 18, y - 9, 12, 13);

        // Snout
        ctx.fillStyle = '#6a5040';
        ctx.fillRect(x - 21, y - 6, 5, 6);

        // Nostrils
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 20, y - 5, 1, 2);
        ctx.fillRect(x - 18, y - 5, 1, 2);

        // Fierce tusks (curved)
        ctx.fillStyle = '#fff';
        ctx.fillRect(x - 19, y - 3, 2, 5);
        ctx.fillRect(x - 20, y - 2, 1, 3);
        ctx.fillRect(x - 17, y - 3, 2, 5);
        ctx.fillRect(x - 16, y - 2, 1, 3);

        // Angry red eyes
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(x - 15, y - 7, 2, 2);
        ctx.fillRect(x - 12, y - 7, 2, 2);

        // Thick legs
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 13, y + 7, 5, 5);
        ctx.fillRect(x - 4, y + 7, 5, 5);
        ctx.fillRect(x + 4, y + 7, 5, 5);
        ctx.fillRect(x + 11, y + 7, 5, 5);

        // Hooves
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 13, y + 11, 5, 2);
        ctx.fillRect(x - 4, y + 11, 5, 2);
        ctx.fillRect(x + 4, y + 11, 5, 2);
        ctx.fillRect(x + 11, y + 11, 5, 2);
    } else if (enemyName.includes('Stag')) {
        // Stag - majestic forest guardian

        // Sleek body
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 11, y - 9, 22, 13);

        // Fur patterns (lighter spots)
        const lightColor = '#a0826d';
        ctx.fillStyle = lightColor;
        ctx.fillRect(x - 8, y - 7, 3, 3);
        ctx.fillRect(x - 3, y - 6, 3, 3);
        ctx.fillRect(x + 3, y - 7, 3, 3);

        // Graceful neck
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 14, y - 15, 6, 8);

        // Noble head
        ctx.fillRect(x - 16, y - 18, 8, 6);

        // Ears
        ctx.fillRect(x - 15, y - 21, 2, 3);
        ctx.fillRect(x - 11, y - 21, 2, 3);

        // Magnificent antlers (branching)
        ctx.fillStyle = '#8b7355';
        // Main beams
        ctx.fillRect(x - 17, y - 24, 2, 6);
        ctx.fillRect(x - 9, y - 24, 2, 6);
        // Points/tines
        ctx.fillRect(x - 19, y - 26, 2, 4);
        ctx.fillRect(x - 17, y - 28, 2, 5);
        ctx.fillRect(x - 15, y - 27, 2, 4);
        ctx.fillRect(x - 11, y - 27, 2, 4);
        ctx.fillRect(x - 9, y - 28, 2, 5);
        ctx.fillRect(x - 7, y - 26, 2, 4);

        // Gentle eyes
        ctx.fillStyle = '#2a1a0a';
        ctx.fillRect(x - 14, y - 16, 2, 2);
        ctx.fillRect(x - 11, y - 16, 2, 2);

        // Snout
        ctx.fillStyle = '#4a3a2a';
        ctx.fillRect(x - 17, y - 14, 3, 2);

        // Slender legs
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 9, y + 4, 2, 9);
        ctx.fillRect(x - 5, y + 4, 2, 9);
        ctx.fillRect(x + 3, y + 4, 2, 9);
        ctx.fillRect(x + 7, y + 4, 2, 9);

        // Hooves (dark)
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(x - 9, y + 12, 2, 2);
        ctx.fillRect(x - 5, y + 12, 2, 2);
        ctx.fillRect(x + 3, y + 12, 2, 2);
        ctx.fillRect(x + 7, y + 12, 2, 2);
    } else if (enemyName.includes('Treant')) {
        // Treant trunk (thick)
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 12, y - 10, 24, 20);
        // Branches
        ctx.fillRect(x - 18, y - 14, 6, 4);
        ctx.fillRect(x + 12, y - 14, 6, 4);
        ctx.fillRect(x - 16, y - 8, 4, 3);
        ctx.fillRect(x + 12, y - 8, 4, 3);
        // Root legs
        ctx.fillRect(x - 10, y + 10, 6, 4);
        ctx.fillRect(x + 4, y + 10, 6, 4);
        // Eyes
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(x - 6, y - 6, 3, 3);
        ctx.fillRect(x + 3, y - 6, 3, 3);
    } else if (enemyName.includes('Spider')) {
        // Spider body
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI * 2);
        ctx.fill();
        // Abdomen
        ctx.beginPath();
        ctx.arc(x, y + 6, 6, 0, Math.PI * 2);
        ctx.fill();
        // Legs
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 1;
        for (let i = 0; i < 4; i++) {
            const angle = (Math.PI / 4) * i - Math.PI/2;
            ctx.beginPath();
            ctx.moveTo(x - 6, y);
            ctx.lineTo(x - 6 - Math.cos(angle) * 10, y + Math.sin(angle) * 10);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x + 6, y);
            ctx.lineTo(x + 6 + Math.cos(angle) * 10, y + Math.sin(angle) * 10);
            ctx.stroke();
        }
    } else if (enemyName.includes('Scout')) {
        // Scout body (light armor)
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 8, y - 8, 16, 16);
        // Head
        ctx.fillStyle = '#fdbcb4';
        ctx.fillRect(x - 6, y - 16, 12, 8);
        // Helmet
        ctx.fillStyle = '#71717a';
        ctx.fillRect(x - 7, y - 18, 14, 4);
        // Bow
        ctx.strokeStyle = '#8b7355';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x - 12, y, 8, -Math.PI/3, Math.PI/3, false);
        ctx.stroke();
        // Arrow
        ctx.strokeStyle = '#8b7355';
        ctx.beginPath();
        ctx.moveTo(x - 12, y);
        ctx.lineTo(x - 8, y);
        ctx.stroke();
    } else if (enemyName.includes('Wisp')) {
        // Wisp glowing orb
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, 12);
        gradient.addColorStop(0, this.color + 'ff');
        gradient.addColorStop(0.5, this.color + '80');
        gradient.addColorStop(1, this.color + '20');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, 12, 0, Math.PI * 2);
        ctx.fill();
        // Inner core
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
        // Floating particles
        for (let i = 0; i < 3; i++) {
            const px = x + Math.cos(this.animTimer + i * 2) * 15;
            const py = y + Math.sin(this.animTimer + i * 2) * 15;
            ctx.fillStyle = this.color + '60';
            ctx.beginPath();
            ctx.arc(px, py, 2, 0, Math.PI * 2);
            ctx.fill();
        }
    } else if (enemyName.includes('Golem')) {
        // Enhanced Stone Golem - ancient construct with detail
        const stoneColor = this.color;
        const stoneDark = '#2a2a2a';
        const stoneLight = '#6a6a6a';

        // Massive stone body with segments
        ctx.fillStyle = stoneColor;
        ctx.fillRect(x - 15, y - 11, 30, 22);

        // Stone texture - cracks and segments
        ctx.fillStyle = stoneDark;
        ctx.fillRect(x - 13, y - 9, 26, 2);
        ctx.fillRect(x - 13, y - 2, 26, 2);
        ctx.fillRect(x - 13, y + 5, 26, 2);
        ctx.fillRect(x - 2, y - 10, 2, 20);

        // Stone highlights
        ctx.fillStyle = stoneLight;
        ctx.fillRect(x - 14, y - 10, 2, 20);
        ctx.fillRect(x + 12, y - 10, 2, 20);
        ctx.fillRect(x - 12, y - 8, 24, 1);

        // Boulder-like head
        ctx.fillStyle = stoneColor;
        ctx.fillRect(x - 9, y - 20, 18, 10);

        // Head segments
        ctx.fillStyle = stoneDark;
        ctx.fillRect(x - 8, y - 19, 16, 1);
        ctx.fillRect(x - 8, y - 14, 16, 1);
        ctx.fillRect(x - 1, y - 19, 1, 9);

        // Massive stone arms
        ctx.fillStyle = stoneColor;
        ctx.fillRect(x - 22, y - 9, 8, 16);
        ctx.fillRect(x + 14, y - 9, 8, 16);

        // Arm joints/segments
        ctx.fillStyle = stoneDark;
        ctx.fillRect(x - 21, y - 4, 6, 2);
        ctx.fillRect(x + 15, y - 4, 6, 2);

        // Fists (larger)
        ctx.fillRect(x - 22, y + 6, 8, 5);
        ctx.fillRect(x + 14, y + 6, 8, 5);

        // Thick stone legs
        ctx.fillStyle = stoneColor;
        ctx.fillRect(x - 11, y + 11, 9, 7);
        ctx.fillRect(x + 2, y + 11, 9, 7);

        // Leg segments
        ctx.fillStyle = stoneDark;
        ctx.fillRect(x - 10, y + 14, 7, 1);
        ctx.fillRect(x + 3, y + 14, 7, 1);

        // GLOWING ORANGE CORE EYES
        ctx.fillStyle = '#ff4500';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#ff4500';
        ctx.fillRect(x - 6, y - 16, 4, 4);
        ctx.fillRect(x + 2, y - 16, 4, 4);

        // Eye glow core (brighter)
        ctx.fillStyle = '#ffaa00';
        ctx.fillRect(x - 5, y - 15, 2, 2);
        ctx.fillRect(x + 3, y - 15, 2, 2);
        ctx.shadowBlur = 0;

        // Ancient runes on chest (dim glow)
        ctx.fillStyle = 'rgba(255, 69, 0, 0.4)';
        ctx.fillRect(x - 4, y - 6, 2, 2);
        ctx.fillRect(x + 2, y - 6, 2, 2);
        ctx.fillRect(x - 1, y - 1, 2, 2);
    } else if (enemyName.includes('Sprite')) {
        // Sprite small floating flame
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, 10);
        gradient.addColorStop(0, '#ffff00');
        gradient.addColorStop(0.3, this.color);
        gradient.addColorStop(1, this.color + '40');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, 10, 0, Math.PI * 2);
        ctx.fill();
        // Flame effect
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(x - 6, y);
        ctx.lineTo(x, y - 12);
        ctx.lineTo(x + 6, y);
        ctx.arc(x, y, 6, 0, Math.PI, false);
        ctx.fill();
    } else if (enemyName.includes('Rat')) {
        // Enhanced Rat - diseased dungeon pest (static, no animations)
        const ratBrown = this.color;
        const ratDark = '#2a1a1a';

        // Hunched body with fur texture
        ctx.fillStyle = ratBrown;
        ctx.fillRect(x - 9, y - 5, 18, 10);

        // Fur details (darker patches)
        ctx.fillStyle = ratDark;
        ctx.fillRect(x - 7, y - 4, 2, 8);
        ctx.fillRect(x - 3, y - 3, 2, 7);
        ctx.fillRect(x + 2, y - 4, 2, 8);
        ctx.fillRect(x + 6, y - 3, 2, 7);

        // Head with detail
        ctx.fillStyle = ratBrown;
        ctx.fillRect(x - 11, y - 5, 7, 8);

        // Pointed snout
        ctx.fillRect(x - 13, y - 3, 3, 4);

        // Whiskers (static lines)
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(x - 13, y - 2);
        ctx.lineTo(x - 16, y - 3);
        ctx.moveTo(x - 13, y);
        ctx.lineTo(x - 16, y);
        ctx.moveTo(x - 13, y + 1);
        ctx.lineTo(x - 16, y + 2);
        ctx.stroke();

        // Large round ears
        ctx.fillStyle = '#8b6f5f';
        ctx.beginPath();
        ctx.arc(x - 9, y - 7, 3, 0, Math.PI * 2);
        ctx.arc(x - 5, y - 7, 3, 0, Math.PI * 2);
        ctx.fill();

        // Inner ear detail
        ctx.fillStyle = '#d4a574';
        ctx.beginPath();
        ctx.arc(x - 9, y - 7, 1.5, 0, Math.PI * 2);
        ctx.arc(x - 5, y - 7, 1.5, 0, Math.PI * 2);
        ctx.fill();

        // Menacing red eyes (static glow)
        ctx.fillStyle = '#ff0000';
        ctx.shadowBlur = 6;
        ctx.shadowColor = '#ff0000';
        ctx.fillRect(x - 10, y - 3, 2, 2);
        ctx.fillRect(x - 6, y - 3, 2, 2);
        ctx.shadowBlur = 0;

        // Long curved tail with segmented texture
        ctx.strokeStyle = ratBrown;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x + 9, y + 1);
        ctx.quadraticCurveTo(x + 14, y + 3, x + 18, y - 1);
        ctx.stroke();

        // Tail segments (static stripes)
        ctx.strokeStyle = ratDark;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x + 10, y);
        ctx.lineTo(x + 10, y + 2);
        ctx.moveTo(x + 12, y + 1);
        ctx.lineTo(x + 12, y + 3);
        ctx.moveTo(x + 14, y + 1);
        ctx.lineTo(x + 14, y + 3);
        ctx.moveTo(x + 16, y);
        ctx.lineTo(x + 16, y + 2);
        ctx.stroke();

        // Clawed feet
        ctx.fillStyle = ratDark;
        ctx.fillRect(x - 7, y + 5, 3, 2);
        ctx.fillRect(x - 2, y + 5, 3, 2);
        ctx.fillRect(x + 3, y + 5, 3, 2);
        ctx.fillRect(x + 7, y + 5, 3, 2);
    } else if (enemyName.includes('Brute')) {
        // Brute body (muscular)
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 16, y - 10, 32, 20);
        // Head (small)
        ctx.fillRect(x - 6, y - 16, 12, 6);
        // Arms (thick)
        ctx.fillRect(x - 22, y - 8, 8, 16);
        ctx.fillRect(x + 14, y - 8, 8, 16);
        // Legs
        ctx.fillRect(x - 12, y + 10, 10, 6);
        ctx.fillRect(x + 2, y + 10, 10, 6);
    } else if (enemyName.includes('Guard')) {
        // Guard body (heavy armor)
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 12, y - 10, 24, 20);
        // Helmet
        ctx.fillStyle = '#71717a';
        ctx.fillRect(x - 8, y - 18, 16, 10);
        // Shield
        ctx.fillStyle = '#a0522d';
        ctx.fillRect(x - 18, y - 8, 6, 14);
        // Hammer
        ctx.fillStyle = '#71717a';
        ctx.fillRect(x + 12, y - 12, 4, 16);
        ctx.fillRect(x + 10, y - 14, 8, 4);
    } else if (enemyName.includes('Imp')) {
        // Imp body (small)
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 6, y - 4, 12, 10);
        // Head with horns
        ctx.fillRect(x - 5, y - 10, 10, 6);
        ctx.fillStyle = '#8b0000';
        ctx.fillRect(x - 6, y - 12, 2, 3);
        ctx.fillRect(x + 4, y - 12, 2, 3);
        // Wings
        ctx.fillStyle = this.color + '80';
        ctx.beginPath();
        ctx.moveTo(x - 6, y - 4);
        ctx.lineTo(x - 12, y - 8);
        ctx.lineTo(x - 10, y + 2);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x + 6, y - 4);
        ctx.lineTo(x + 12, y - 8);
        ctx.lineTo(x + 10, y + 2);
        ctx.closePath();
        ctx.fill();
        // Tail
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x, y + 6);
        ctx.quadraticCurveTo(x + 4, y + 10, x + 8, y + 8);
        ctx.stroke();
    } else if (enemyName.includes('Beetle')) {
        // Beetle shell
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.ellipse(x, y, 10, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        // Head
        ctx.fillRect(x - 6, y - 10, 12, 6);
        // Horn
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(x - 2, y - 12, 4, 3);
        // Legs
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        for (let i = -1; i <= 1; i++) {
            ctx.beginPath();
            ctx.moveTo(x - 8, y + i * 4);
            ctx.lineTo(x - 12, y + i * 4 + 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x + 8, y + i * 4);
            ctx.lineTo(x + 12, y + i * 4 + 2);
            ctx.stroke();
        }
    } else if (enemyName.includes('Slime')) {
        // Enhanced Slime - gelatinous blob with depth
        const slimeAlpha = 0.85;

        // Shadow puddle beneath
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        ctx.beginPath();
        ctx.ellipse(x, y + 8, 14, 7, 0, 0, Math.PI * 2);
        ctx.fill();

        // Bottom blob (darker, more opaque)
        ctx.fillStyle = this.color + 'dd';
        ctx.beginPath();
        ctx.ellipse(x, y + 5, 13, 9, 0, 0, Math.PI * 2);
        ctx.fill();

        // Middle blob
        ctx.fillStyle = this.color + 'cc';
        ctx.beginPath();
        ctx.ellipse(x, y, 11, 11, 0, 0, Math.PI * 2);
        ctx.fill();

        // Top blob (more transparent)
        ctx.fillStyle = this.color + 'bb';
        ctx.beginPath();
        ctx.ellipse(x, y - 4, 9, 9, 0, 0, Math.PI * 2);
        ctx.fill();

        // Multiple glossy highlights for depth
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.beginPath();
        ctx.ellipse(x - 4, y - 7, 5, 4, -Math.PI/4, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.ellipse(x + 3, y - 5, 3, 2, Math.PI/6, 0, Math.PI * 2);
        ctx.fill();

        // Smaller shine spots
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.beginPath();
        ctx.arc(x - 5, y - 6, 2, 0, Math.PI * 2);
        ctx.fill();

        // Internal bubbles
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.beginPath();
        ctx.arc(x + 2, y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x - 3, y + 2, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x + 4, y + 3, 2.5, 0, Math.PI * 2);
        ctx.fill();

        // Simple dot eyes
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(x - 4, y - 1, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x + 4, y - 1, 2, 0, Math.PI * 2);
        ctx.fill();

        // Eye highlights
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(x - 3.5, y - 1.5, 0.8, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x + 4.5, y - 1.5, 0.8, 0, Math.PI * 2);
        ctx.fill();
    } else if (enemyName.includes('Shade')) {
        // Enhanced Shade - ethereal specter with layers
        const shadeAlpha = 0.7 + Math.sin(this.animTimer * 0.5) * 0.2;

        // Outer ethereal aura (pulsing)
        ctx.fillStyle = this.color + '30';
        ctx.beginPath();
        ctx.moveTo(x - 14, y + 12);
        ctx.lineTo(x - 10, y - 12);
        ctx.lineTo(x + 10, y - 12);
        ctx.lineTo(x + 14, y + 12);
        ctx.quadraticCurveTo(x + 7, y + 10, x, y + 13);
        ctx.quadraticCurveTo(x - 7, y + 10, x - 14, y + 12);
        ctx.fill();

        // Main ghostly body (flowing robes)
        ctx.fillStyle = this.color + Math.floor(shadeAlpha * 255).toString(16).padStart(2, '0');
        ctx.beginPath();
        ctx.moveTo(x - 11, y + 11);
        ctx.lineTo(x - 9, y - 11);
        ctx.lineTo(x + 9, y - 11);
        ctx.lineTo(x + 11, y + 11);
        // Wispy bottom
        ctx.quadraticCurveTo(x + 6, y + 9, x + 3, y + 12);
        ctx.quadraticCurveTo(x, y + 11, x - 3, y + 12);
        ctx.quadraticCurveTo(x - 6, y + 9, x - 11, y + 11);
        ctx.fill();

        // Inner darker core
        ctx.fillStyle = this.color + '90';
        ctx.fillRect(x - 6, y - 6, 12, 10);

        // Hood/cowl
        ctx.fillStyle = this.color + 'aa';
        ctx.fillRect(x - 8, y - 15, 16, 5);

        // Spectral tendrils floating around
        const time = Date.now() / 800;
        for (let i = 0; i < 3; i++) {
            const angle = (Math.PI * 2 * i / 3) + time;
            const radius = 12 + Math.sin(time * 2 + i) * 3;
            const tx = x + Math.cos(angle) * radius;
            const ty = y + Math.sin(angle) * radius * 0.6;

            ctx.fillStyle = this.color + '40';
            ctx.beginPath();
            ctx.arc(tx, ty, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // PIERCING PURPLE EYES (more intense)
        ctx.fillStyle = '#ff00ff';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#ff00ff';
        ctx.fillRect(x - 6, y - 5, 4, 4);
        ctx.fillRect(x + 2, y - 5, 4, 4);

        // Eye cores (brighter center)
        ctx.fillStyle = '#fff';
        ctx.fillRect(x - 5, y - 4, 2, 2);
        ctx.fillRect(x + 3, y - 4, 2, 2);
        ctx.shadowBlur = 0;

        // Faint ethereal glow around entire shade
        const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, 20);
        glowGradient.addColorStop(0, this.color + '00');
        glowGradient.addColorStop(1, this.color + '20');
        ctx.fillStyle = glowGradient;
        ctx.beginPath();
        ctx.arc(x, y, 20, 0, Math.PI * 2);
        ctx.fill();
    } else if (enemyName.includes('Gloomling')) {
        // Enhanced Gloomling - writhing shadow creature
        const pulseSize = 10 + Math.sin(this.animTimer * 0.8) * 2;

        // Dark aura
        const auraGradient = ctx.createRadialGradient(x, y, 0, x, y, 18);
        auraGradient.addColorStop(0, this.color + '60');
        auraGradient.addColorStop(1, this.color + '00');
        ctx.fillStyle = auraGradient;
        ctx.beginPath();
        ctx.arc(x, y, 18, 0, Math.PI * 2);
        ctx.fill();

        // Main body (pulsing)
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(x, y, pulseSize, 0, Math.PI * 2);
        ctx.fill();

        // Inner darker core
        ctx.fillStyle = '#0a0a0a';
        ctx.beginPath();
        ctx.arc(x, y, pulseSize * 0.6, 0, Math.PI * 2);
        ctx.fill();

        // Animated writhing tendrils (6 instead of 4)
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2.5;
        ctx.lineCap = 'round';

        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI * 2 * i / 6) + this.animTimer * 0.15;
            const wave = Math.sin(this.animTimer * 0.3 + i) * 3;
            const length = 18 + Math.sin(this.animTimer * 0.4 + i * 0.5) * 5;

            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.quadraticCurveTo(
                x + Math.cos(angle) * (length * 0.6) + wave,
                y + Math.sin(angle) * (length * 0.4) + wave * 0.5,
                x + Math.cos(angle) * length,
                y + Math.sin(angle) * length * 0.7
            );
            ctx.stroke();

            // Tendril tips (smaller blobs)
            ctx.fillStyle = this.color + 'aa';
            ctx.beginPath();
            ctx.arc(
                x + Math.cos(angle) * length,
                y + Math.sin(angle) * length * 0.7,
                2,
                0,
                Math.PI * 2
            );
            ctx.fill();
        }

        // Sinister glowing eyes
        ctx.fillStyle = '#8b00ff';
        ctx.shadowBlur = 8;
        ctx.shadowColor = '#8b00ff';
        ctx.fillRect(x - 4, y - 2, 2, 3);
        ctx.fillRect(x + 2, y - 2, 2, 3);
        ctx.shadowBlur = 0;
    } else if (enemyName.includes('Stalker')) {
        // Night Stalker predator
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 10, y - 6, 20, 12);
        // Head with sharp features
        ctx.beginPath();
        ctx.moveTo(x - 12, y - 4);
        ctx.lineTo(x - 8, y - 8);
        ctx.lineTo(x - 4, y - 6);
        ctx.closePath();
        ctx.fill();
        // Claws
        ctx.fillStyle = '#fff';
        ctx.fillRect(x - 12, y + 4, 2, 4);
        ctx.fillRect(x - 9, y + 4, 2, 4);
        ctx.fillRect(x + 8, y + 4, 2, 4);
        ctx.fillRect(x + 11, y + 4, 2, 4);
        // Eyes
        ctx.fillStyle = '#ff00ff';
        ctx.fillRect(x - 10, y - 6, 2, 2);
        ctx.fillRect(x - 6, y - 6, 2, 2);
    } else if (enemyName.includes('Mite')) {
        // Void Mite tiny creature
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI * 2);
        ctx.fill();
        // Legs (tiny)
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 1;
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(angle) * 8, y + Math.sin(angle) * 8);
            ctx.stroke();
        }
    } else if (enemyName.includes('Leech')) {
        // Abyssal Leech segmented
        ctx.fillStyle = this.color;
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc(x - i * 6, y + i * 2, 6 - i, 0, Math.PI * 2);
            ctx.fill();
        }
        // Mouth
        ctx.fillStyle = '#8b0000';
        ctx.beginPath();
        ctx.arc(x + 4, y, 3, 0, Math.PI * 2);
        ctx.fill();
    } else if (enemyName.includes('Bat')) {
        // Dread Bat wings spread
        ctx.fillStyle = this.color;
        // Body
        ctx.beginPath();
        ctx.ellipse(x, y, 6, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        // Wings
        ctx.beginPath();
        ctx.moveTo(x - 6, y);
        ctx.lineTo(x - 16, y - 4);
        ctx.lineTo(x - 14, y + 4);
        ctx.lineTo(x - 10, y + 2);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x + 6, y);
        ctx.lineTo(x + 16, y - 4);
        ctx.lineTo(x + 14, y + 4);
        ctx.lineTo(x + 10, y + 2);
        ctx.closePath();
        ctx.fill();
        // Eyes
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(x - 3, y - 2, 2, 2);
        ctx.fillRect(x + 1, y - 2, 2, 2);
    } else if (enemyName.includes('Cultist')) {
        // Hollow Cultist robed
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(x - 12, y + 10);
        ctx.lineTo(x - 8, y - 8);
        ctx.lineTo(x + 8, y - 8);
        ctx.lineTo(x + 12, y + 10);
        ctx.closePath();
        ctx.fill();
        // Hood
        ctx.fillStyle = '#2a1a3a';
        ctx.beginPath();
        ctx.arc(x, y - 10, 10, Math.PI, 0, true);
        ctx.fill();
        // Glowing eyes
        ctx.fillStyle = '#ff00ff';
        ctx.shadowBlur = 5;
        ctx.shadowColor = '#ff00ff';
        ctx.fillRect(x - 4, y - 8, 2, 2);
        ctx.fillRect(x + 2, y - 8, 2, 2);
        ctx.shadowBlur = 0;
        // Staff
        ctx.strokeStyle = '#8b7bc8';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x + 10, y - 12);
        ctx.lineTo(x + 10, y + 8);
        ctx.stroke();
        // Orb on staff
        ctx.fillStyle = '#ff00ff';
        ctx.beginPath();
        ctx.arc(x + 10, y - 14, 3, 0, Math.PI * 2);
        ctx.fill();
    } else if (enemyName.includes('Colossus')) {
        // TITAN COLOSSUS - Massive stone giant
        const scale = 0.95;

        // Ground pound aura
        const auraGradient = ctx.createRadialGradient(x, y, 0, x, y, 40 * scale);
        auraGradient.addColorStop(0, 'rgba(74, 85, 104, 0.3)');
        auraGradient.addColorStop(1, 'rgba(74, 85, 104, 0)');
        ctx.fillStyle = auraGradient;
        ctx.beginPath();
        ctx.arc(x, y, 40 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Massive rocky body
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 32 * scale, y - 20 * scale, 64 * scale, 42 * scale);

        // Rock texture
        ctx.fillStyle = '#3a4150';
        for (let i = 0; i < 8; i++) {
            ctx.fillRect((x - 28 * scale) + (i * 7 * scale), y - 16 * scale, 5 * scale, 8 * scale);
            ctx.fillRect((x - 28 * scale) + (i * 7 * scale), y + 2 * scale, 5 * scale, 8 * scale);
        }

        // Massive shoulders
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 44 * scale, y - 18 * scale, 16 * scale, 24 * scale);
        ctx.fillRect(x + 28 * scale, y - 18 * scale, 16 * scale, 24 * scale);

        // Head with cracks
        ctx.fillStyle = '#2d3748';
        ctx.fillRect(x - 18 * scale, y - 38 * scale, 36 * scale, 20 * scale);

        // Glowing cracks in head
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 2 * scale;
        ctx.beginPath();
        ctx.moveTo(x - 12 * scale, y - 28 * scale);
        ctx.lineTo(x - 6 * scale, y - 22 * scale);
        ctx.moveTo(x + 6 * scale, y - 30 * scale);
        ctx.lineTo(x + 10 * scale, y - 24 * scale);
        ctx.stroke();

        // Glowing eyes
        ctx.fillStyle = '#fbbf24';
        ctx.shadowBlur = 20 * scale;
        ctx.shadowColor = '#f59e0b';
        ctx.fillRect(x - 12 * scale, y - 28 * scale, 6 * scale, 6 * scale);
        ctx.fillRect(x + 6 * scale, y - 28 * scale, 6 * scale, 6 * scale);
        ctx.shadowBlur = 0;

        // Massive fists
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 50 * scale, y + 2 * scale, 12 * scale, 16 * scale);

        // MASSIVE WAR HAMMER - right hand
        ctx.fillStyle = '#71717a';
        ctx.fillRect(x + 42 * scale, y - 30 * scale, 6 * scale, 50 * scale);
        ctx.fillStyle = '#4a5568';
        ctx.fillRect(x + 36 * scale, y - 36 * scale, 18 * scale, 12 * scale);
        ctx.fillStyle = '#2d3748';
        ctx.fillRect(x + 38 * scale, y - 34 * scale, 14 * scale, 8 * scale);
        // Hammer spikes
        ctx.fillStyle = '#9ca3af';
        ctx.fillRect(x + 33 * scale, y - 32 * scale, 5 * scale, 6 * scale);
        ctx.fillRect(x + 52 * scale, y - 32 * scale, 5 * scale, 6 * scale);
        ctx.fillRect(x + 42 * scale, y - 40 * scale, 6 * scale, 5 * scale);
    } else if (enemyName.includes('Behemoth')) {
        // INFERNAL BEHEMOTH - Burning demon lord
        const scale = 0.9;

        // Infernal aura
        const auraGradient = ctx.createRadialGradient(x, y, 0, x, y, 45 * scale);
        auraGradient.addColorStop(0, 'rgba(220, 38, 38, 0.4)');
        auraGradient.addColorStop(1, 'rgba(220, 38, 38, 0)');
        ctx.fillStyle = auraGradient;
        ctx.beginPath();
        ctx.arc(x, y, 45 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Muscular demonic body
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 30 * scale, y - 18 * scale, 60 * scale, 38 * scale);

        // Flame patterns
        ctx.fillStyle = '#ff4500';
        for (let i = 0; i < 6; i++) {
            const flameX = (x - 24 * scale) + (i * 8 * scale);
            ctx.beginPath();
            ctx.moveTo(flameX, y - 12 * scale);
            ctx.lineTo(flameX + 4 * scale, y - 18 * scale);
            ctx.lineTo(flameX + 8 * scale, y - 12 * scale);
            ctx.fill();
        }

        // Massive horned head
        ctx.fillStyle = '#7f1d1d';
        ctx.fillRect(x - 20 * scale, y - 36 * scale, 40 * scale, 20 * scale);

        // Curved horns
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 4 * scale;
        ctx.beginPath();
        ctx.moveTo(x - 18 * scale, y - 34 * scale);
        ctx.quadraticCurveTo(x - 26 * scale, y - 44 * scale, x - 22 * scale, y - 48 * scale);
        ctx.moveTo(x + 18 * scale, y - 34 * scale);
        ctx.quadraticCurveTo(x + 26 * scale, y - 44 * scale, x + 22 * scale, y - 48 * scale);
        ctx.stroke();

        // Burning eyes
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 25 * scale;
        ctx.shadowColor = '#ff4500';
        ctx.fillRect(x - 12 * scale, y - 28 * scale, 6 * scale, 8 * scale);
        ctx.fillRect(x + 6 * scale, y - 28 * scale, 6 * scale, 8 * scale);
        ctx.shadowBlur = 0;

        // Clawed hands
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 42 * scale, y - 8 * scale, 14 * scale, 20 * scale);

        // FLAMING GREATSWORD - right hand
        ctx.fillStyle = '#71717a';
        ctx.fillRect(x + 32 * scale, y - 40 * scale, 8 * scale, 60 * scale);
        ctx.fillStyle = '#c0c0c0';
        ctx.fillRect(x + 33 * scale, y - 38 * scale, 6 * scale, 55 * scale);
        // Crossguard
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(x + 24 * scale, y - 10 * scale, 24 * scale, 4 * scale);
        // Flame effect on blade
        ctx.shadowBlur = 20 * scale;
        ctx.shadowColor = '#ff4500';
        ctx.fillStyle = 'rgba(255, 69, 0, 0.6)';
        ctx.fillRect(x + 34 * scale, y - 36 * scale, 4 * scale, 50 * scale);
        ctx.shadowBlur = 0;

        // Left clawed hand
        ctx.fillStyle = this.color;
        ctx.fillRect(x + 28 * scale, y - 8 * scale, 14 * scale, 20 * scale);

        // Claws
        ctx.fillStyle = '#1a1a1a';
        for (let i = 0; i < 3; i++) {
            ctx.fillRect((x - 40 * scale) + (i * 4 * scale), y + 10 * scale, 2 * scale, 6 * scale);
            ctx.fillRect((x + 30 * scale) + (i * 4 * scale), y + 10 * scale, 2 * scale, 6 * scale);
        }
    } else if (enemyName.includes('Leviathan')) {
        // FROST LEVIATHAN - Ice dragon-like beast
        const scale = 0.95;

        // Frost aura
        const auraGradient = ctx.createRadialGradient(x, y, 0, x, y, 48 * scale);
        auraGradient.addColorStop(0, 'rgba(59, 130, 246, 0.3)');
        auraGradient.addColorStop(1, 'rgba(147, 197, 253, 0)');
        ctx.fillStyle = auraGradient;
        ctx.beginPath();
        ctx.arc(x, y, 48 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Serpentine body with ice crystals
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 34 * scale, y - 16 * scale, 68 * scale, 36 * scale);

        // Ice crystal spikes along back
        ctx.fillStyle = '#bfdbfe';
        for (let i = 0; i < 7; i++) {
            const spikeX = (x - 30 * scale) + (i * 10 * scale);
            ctx.beginPath();
            ctx.moveTo(spikeX, y - 16 * scale);
            ctx.lineTo(spikeX + 4 * scale, y - 26 * scale);
            ctx.lineTo(spikeX + 8 * scale, y - 16 * scale);
            ctx.closePath();
            ctx.fill();
        }

        // Dragon-like head
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 22 * scale, y - 40 * scale, 44 * scale, 26 * scale);

        // Snout
        ctx.fillRect(x - 16 * scale, y - 46 * scale, 32 * scale, 8 * scale);

        // Ice horns
        ctx.fillStyle = '#dbeafe';
        ctx.beginPath();
        ctx.moveTo(x - 20 * scale, y - 38 * scale);
        ctx.lineTo(x - 24 * scale, y - 50 * scale);
        ctx.lineTo(x - 16 * scale, y - 40 * scale);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x + 20 * scale, y - 38 * scale);
        ctx.lineTo(x + 24 * scale, y - 50 * scale);
        ctx.lineTo(x + 16 * scale, y - 40 * scale);
        ctx.fill();

        // Glowing ice eyes
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 22 * scale;
        ctx.shadowColor = '#60a5fa';
        ctx.fillRect(x - 14 * scale, y - 32 * scale, 7 * scale, 7 * scale);
        ctx.fillRect(x + 7 * scale, y - 32 * scale, 7 * scale, 7 * scale);
        ctx.shadowBlur = 0;

        // Massive clawed limbs
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 46 * scale, y - 6 * scale, 16 * scale, 22 * scale);
        ctx.fillRect(x + 30 * scale, y - 6 * scale, 16 * scale, 22 * scale);
    } else if (enemyName.includes('Juggernaut')) {
        // CHAOS JUGGERNAUT - Void-touched warrior
        const scale = 0.925;

        // Chaos aura with swirling effect
        const time = Date.now() / 600;
        const auraGradient = ctx.createRadialGradient(x, y, 0, x, y, 42 * scale);
        auraGradient.addColorStop(0, 'rgba(168, 85, 247, 0.4)');
        auraGradient.addColorStop(0.5, 'rgba(139, 92, 246, 0.2)');
        auraGradient.addColorStop(1, 'rgba(168, 85, 247, 0)');
        ctx.fillStyle = auraGradient;
        ctx.beginPath();
        ctx.arc(x, y, 42 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Chaos tendrils
        ctx.strokeStyle = '#a855f7';
        ctx.lineWidth = 2 * scale;
        for (let i = 0; i < 4; i++) {
            const angle = (Math.PI * 2 * i / 4) + time;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(angle) * 35 * scale, y + Math.sin(angle) * 35 * scale);
            ctx.stroke();
        }

        // Armored body with chaos energy
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 28 * scale, y - 20 * scale, 56 * scale, 40 * scale);

        // Energy lines
        ctx.strokeStyle = '#c084fc';
        ctx.lineWidth = 2 * scale;
        for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.moveTo(x - 24 * scale, (y - 16 * scale) + (i * 7 * scale));
            ctx.lineTo(x + 24 * scale, (y - 16 * scale) + (i * 7 * scale));
            ctx.stroke();
        }

        // Helmet with void energy
        ctx.fillStyle = '#581c87';
        ctx.fillRect(x - 20 * scale, y - 38 * scale, 40 * scale, 20 * scale);

        // Void eyes
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 28 * scale;
        ctx.shadowColor = '#a855f7';
        ctx.fillRect(x - 14 * scale, y - 30 * scale, 8 * scale, 8 * scale);
        ctx.fillRect(x + 6 * scale, y - 30 * scale, 8 * scale, 8 * scale);
        ctx.shadowBlur = 0;

        // Chaos blades in hands
        ctx.fillStyle = '#8b5cf6';
        ctx.fillRect(x - 48 * scale, y - 24 * scale, 8 * scale, 36 * scale);
        ctx.fillRect(x + 40 * scale, y - 24 * scale, 8 * scale, 36 * scale);
    } else if (enemyName.includes('Dreadnought')) {
        // VOID DREADNOUGHT - Dark matter tank
        const scale = 1.0;

        // Void aura
        const auraGradient = ctx.createRadialGradient(x, y, 0, x, y, 50 * scale);
        auraGradient.addColorStop(0, 'rgba(30, 27, 75, 0.5)');
        auraGradient.addColorStop(1, 'rgba(30, 27, 75, 0)');
        ctx.fillStyle = auraGradient;
        ctx.beginPath();
        ctx.arc(x, y, 50 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Void particles
        for (let i = 0; i < 8; i++) {
            const angle = (Math.PI * 2 * i / 8) + Date.now() / 800;
            const radius = 30 * scale;
            ctx.fillStyle = 'rgba(139, 92, 246, 0.6)';
            ctx.beginPath();
            ctx.arc(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius, 2 * scale, 0, Math.PI * 2);
            ctx.fill();
        }

        // Ultra-heavy armor
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 36 * scale, y - 22 * scale, 72 * scale, 44 * scale);

        // Armor plating
        ctx.fillStyle = '#0f0a2e';
        ctx.fillRect(x - 32 * scale, y - 18 * scale, 64 * scale, 8 * scale);
        ctx.fillRect(x - 32 * scale, y - 2 * scale, 64 * scale, 8 * scale);
        ctx.fillRect(x - 32 * scale, y + 14 * scale, 64 * scale, 8 * scale);

        // Massive pauldrons
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 50 * scale, y - 20 * scale, 18 * scale, 28 * scale);
        ctx.fillRect(x + 32 * scale, y - 20 * scale, 18 * scale, 28 * scale);

        // Void core on chest
        const voidPulse = 0.5 + Math.sin(Date.now() / 400) * 0.5;
        ctx.fillStyle = `rgba(139, 92, 246, ${voidPulse})`;
        ctx.shadowBlur = 20 * scale;
        ctx.shadowColor = '#8b5cf6';
        ctx.beginPath();
        ctx.arc(x, y, 8 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Helmet
        ctx.fillStyle = '#0a0825';
        ctx.fillRect(x - 22 * scale, y - 42 * scale, 44 * scale, 22 * scale);

        // Glowing void eyes
        ctx.fillStyle = '#8b5cf6';
        ctx.shadowBlur = 25 * scale;
        ctx.shadowColor = '#8b5cf6';
        ctx.fillRect(x - 14 * scale, y - 34 * scale, 8 * scale, 8 * scale);
        ctx.fillRect(x + 6 * scale, y - 34 * scale, 8 * scale, 8 * scale);
        ctx.shadowBlur = 0;
    } else if (enemyName.includes('Ravager')) {
        // STORM RAVAGER - Lightning-charged berserker
        const scale = 0.875;

        // Storm aura with lightning
        const auraGradient = ctx.createRadialGradient(x, y, 0, x, y, 40 * scale);
        auraGradient.addColorStop(0, 'rgba(251, 191, 36, 0.4)');
        auraGradient.addColorStop(1, 'rgba(251, 191, 36, 0)');
        ctx.fillStyle = auraGradient;
        ctx.beginPath();
        ctx.arc(x, y, 40 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Lightning bolts
        ctx.strokeStyle = '#fef3c7';
        ctx.lineWidth = 2 * scale;
        ctx.shadowBlur = 10 * scale;
        ctx.shadowColor = '#fbbf24';
        for (let i = 0; i < 3; i++) {
            const startX = x + (i - 1) * 20 * scale;
            ctx.beginPath();
            ctx.moveTo(startX, y - 40 * scale);
            ctx.lineTo(startX + 5 * scale, y - 25 * scale);
            ctx.lineTo(startX - 3 * scale, y - 20 * scale);
            ctx.lineTo(startX + 4 * scale, y);
            ctx.stroke();
        }
        ctx.shadowBlur = 0;

        // Battle-scarred body
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 26 * scale, y - 16 * scale, 52 * scale, 34 * scale);

        // Scars (dark lines)
        ctx.strokeStyle = '#92400e';
        ctx.lineWidth = 2 * scale;
        ctx.beginPath();
        ctx.moveTo(x - 20 * scale, y - 10 * scale);
        ctx.lineTo(x + 18 * scale, y + 8 * scale);
        ctx.moveTo(x - 14 * scale, y);
        ctx.lineTo(x + 10 * scale, y);
        ctx.stroke();

        // Wild hair/mane
        ctx.fillStyle = '#f59e0b';
        for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.moveTo((x - 18 * scale) + (i * 9 * scale), y - 26 * scale);
            ctx.lineTo((x - 14 * scale) + (i * 9 * scale), y - 38 * scale);
            ctx.lineTo((x - 10 * scale) + (i * 9 * scale), y - 26 * scale);
            ctx.fill();
        }

        // Fierce face
        ctx.fillStyle = '#d97706';
        ctx.fillRect(x - 16 * scale, y - 28 * scale, 32 * scale, 14 * scale);

        // Glowing yellow eyes
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 20 * scale;
        ctx.shadowColor = '#fbbf24';
        ctx.fillRect(x - 10 * scale, y - 24 * scale, 6 * scale, 6 * scale);
        ctx.fillRect(x + 4 * scale, y - 24 * scale, 6 * scale, 6 * scale);
        ctx.shadowBlur = 0;

        // Thunder axes
        ctx.fillStyle = '#78350f';
        ctx.fillRect(x - 44 * scale, y - 20 * scale, 6 * scale, 28 * scale);
        ctx.fillRect(x + 38 * scale, y - 20 * scale, 6 * scale, 28 * scale);
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(x - 48 * scale, y - 24 * scale, 14 * scale, 6 * scale);
        ctx.fillRect(x + 34 * scale, y - 24 * scale, 14 * scale, 6 * scale);
    } else if (enemyName.includes('Abomination')) {
        // PLAGUE ABOMINATION - Toxic undead horror
        const scale = 0.95;

        // Toxic aura
        const auraGradient = ctx.createRadialGradient(x, y, 0, x, y, 45 * scale);
        auraGradient.addColorStop(0, 'rgba(22, 163, 74, 0.4)');
        auraGradient.addColorStop(1, 'rgba(22, 163, 74, 0)');
        ctx.fillStyle = auraGradient;
        ctx.beginPath();
        ctx.arc(x, y, 45 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Plague clouds
        for (let i = 0; i < 5; i++) {
            const angle = (Math.PI * 2 * i / 5) + Date.now() / 1000;
            const radius = 25 * scale + Math.sin(Date.now() / 500 + i) * 5 * scale;
            ctx.fillStyle = 'rgba(34, 197, 94, 0.3)';
            ctx.beginPath();
            ctx.arc(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius, 4 * scale, 0, Math.PI * 2);
            ctx.fill();
        }

        // Grotesque bloated body
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 32 * scale, y - 18 * scale, 64 * scale, 38 * scale);

        // Pustules and sores
        ctx.fillStyle = '#84cc16';
        for (let i = 0; i < 12; i++) {
            const pX = (x - 28 * scale) + Math.random() * 56 * scale;
            const pY = (y - 14 * scale) + Math.random() * 30 * scale;
            ctx.beginPath();
            ctx.arc(pX, pY, 2 * scale, 0, Math.PI * 2);
            ctx.fill();
        }

        // Deformed head
        ctx.fillStyle = '#166534';
        ctx.fillRect(x - 20 * scale, y - 36 * scale, 40 * scale, 20 * scale);

        // Exposed bone/teeth
        ctx.fillStyle = '#fef3c7';
        for (let i = 0; i < 8; i++) {
            ctx.fillRect((x - 16 * scale) + (i * 4 * scale), y - 20 * scale, 2 * scale, 4 * scale);
        }

        // Sickly glowing eyes
        ctx.fillStyle = '#84cc16';
        ctx.shadowBlur = 20 * scale;
        ctx.shadowColor = '#22c55e';
        ctx.fillRect(x - 12 * scale, y - 30 * scale, 6 * scale, 6 * scale);
        ctx.fillRect(x + 6 * scale, y - 30 * scale, 6 * scale, 6 * scale);
        ctx.shadowBlur = 0;

        // Grotesque limbs
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 44 * scale, y - 8 * scale, 14 * scale, 24 * scale);
        ctx.fillRect(x + 30 * scale, y - 8 * scale, 14 * scale, 24 * scale);
    } else if (enemyName.includes('Tyrant')) {
        // CRIMSON TYRANT - Blood-soaked warlord
        const scale = 0.9;

        // Blood aura
        const auraGradient = ctx.createRadialGradient(x, y, 0, x, y, 42 * scale);
        auraGradient.addColorStop(0, 'rgba(153, 27, 27, 0.4)');
        auraGradient.addColorStop(1, 'rgba(153, 27, 27, 0)');
        ctx.fillStyle = auraGradient;
        ctx.beginPath();
        ctx.arc(x, y, 42 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Blood droplets
        for (let i = 0; i < 6; i++) {
            const dropX = x + (Math.random() - 0.5) * 50 * scale;
            const dropY = y + (Math.random() - 0.5) * 40 * scale;
            ctx.fillStyle = '#dc2626';
            ctx.beginPath();
            ctx.arc(dropX, dropY, 1.5 * scale, 0, Math.PI * 2);
            ctx.fill();
        }

        // Blood-stained armor
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 28 * scale, y - 18 * scale, 56 * scale, 38 * scale);

        // Blood splatters
        ctx.fillStyle = '#7f1d1d';
        for (let i = 0; i < 10; i++) {
            const sX = (x - 24 * scale) + Math.random() * 48 * scale;
            const sY = (y - 14 * scale) + Math.random() * 30 * scale;
            ctx.fillRect(sX, sY, 3 * scale, 3 * scale);
        }

        // Crown of thorns
        ctx.fillStyle = '#450a0a';
        ctx.fillRect(x - 22 * scale, y - 40 * scale, 44 * scale, 8 * scale);
        for (let i = 0; i < 7; i++) {
            ctx.fillRect((x - 18 * scale) + (i * 6 * scale), y - 46 * scale, 2 * scale, 6 * scale);
        }

        // Helmeted face
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 18 * scale, y - 34 * scale, 36 * scale, 16 * scale);

        // Burning red eyes
        ctx.fillStyle = '#ff0000';
        ctx.shadowBlur = 25 * scale;
        ctx.shadowColor = '#dc2626';
        ctx.fillRect(x - 12 * scale, y - 28 * scale, 7 * scale, 7 * scale);
        ctx.fillRect(x + 5 * scale, y - 28 * scale, 7 * scale, 7 * scale);
        ctx.shadowBlur = 0;

        // Blood-dripping greatsword
        ctx.fillStyle = '#71717a';
        ctx.fillRect(x + 36 * scale, y - 40 * scale, 6 * scale, 60 * scale);
        ctx.fillStyle = '#991b1b';
        ctx.fillRect(x + 34 * scale, y - 42 * scale, 10 * scale, 10 * scale);
        // Dripping blood
        for (let i = 0; i < 3; i++) {
            ctx.fillStyle = '#dc2626';
            ctx.fillRect(x + 37 * scale + (i * 2 * scale), y + 18 * scale + (i * 3 * scale), 2 * scale, 4 * scale);
        }
    } else if (enemyName.includes('Devastator')) {
        // ARCANE DEVASTATOR - Magical destroyer
        const scale = 0.85;

        // Arcane aura with runes
        const auraGradient = ctx.createRadialGradient(x, y, 0, x, y, 44 * scale);
        auraGradient.addColorStop(0, 'rgba(139, 92, 246, 0.5)');
        auraGradient.addColorStop(1, 'rgba(139, 92, 246, 0)');
        ctx.fillStyle = auraGradient;
        ctx.beginPath();
        ctx.arc(x, y, 44 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Floating arcane runes
        const time = Date.now() / 800;
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI * 2 * i / 6) + time;
            const radius = 30 * scale;
            const runeX = x + Math.cos(angle) * radius;
            const runeY = y + Math.sin(angle) * radius;

            ctx.fillStyle = '#c084fc';
            ctx.shadowBlur = 8 * scale;
            ctx.shadowColor = '#8b5cf6';
            ctx.fillRect(runeX - 2 * scale, runeY - 3 * scale, 4 * scale, 6 * scale);
            ctx.fillRect(runeX - 3 * scale, runeY - 2 * scale, 6 * scale, 4 * scale);
        }
        ctx.shadowBlur = 0;

        // Robed body
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(x - 30 * scale, y + 20 * scale);
        ctx.lineTo(x - 22 * scale, y - 16 * scale);
        ctx.lineTo(x + 22 * scale, y - 16 * scale);
        ctx.lineTo(x + 30 * scale, y + 20 * scale);
        ctx.closePath();
        ctx.fill();

        // Arcane energy lines
        ctx.strokeStyle = '#c084fc';
        ctx.lineWidth = 2 * scale;
        for (let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.moveTo(x - 20 * scale, (y - 12 * scale) + (i * 8 * scale));
            ctx.lineTo(x + 20 * scale, (y - 12 * scale) + (i * 8 * scale));
            ctx.stroke();
        }

        // Hooded head
        ctx.fillStyle = '#581c87';
        ctx.beginPath();
        ctx.arc(x, y - 24 * scale, 18 * scale, Math.PI, 0, true);
        ctx.fill();

        // Glowing arcane eyes
        ctx.fillStyle = '#e9d5ff';
        ctx.shadowBlur = 30 * scale;
        ctx.shadowColor = '#8b5cf6';
        ctx.fillRect(x - 10 * scale, y - 26 * scale, 6 * scale, 8 * scale);
        ctx.fillRect(x + 4 * scale, y - 26 * scale, 6 * scale, 8 * scale);
        ctx.shadowBlur = 0;

        // Staff with orb
        ctx.strokeStyle = '#a855f7';
        ctx.lineWidth = 4 * scale;
        ctx.beginPath();
        ctx.moveTo(x + 30 * scale, y - 30 * scale);
        ctx.lineTo(x + 30 * scale, y + 20 * scale);
        ctx.stroke();

        // Pulsing arcane orb
        const orbPulse = 0.6 + Math.sin(Date.now() / 300) * 0.4;
        ctx.fillStyle = `rgba(139, 92, 246, ${orbPulse})`;
        ctx.shadowBlur = 25 * scale;
        ctx.shadowColor = '#8b5cf6';
        ctx.beginPath();
        ctx.arc(x + 30 * scale, y - 34 * scale, 6 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    } else if (enemyName.includes('Overlord')) {
        // SHADOW OVERLORD - Dark entity
        const scale = 0.925;

        // Shadow aura
        const auraGradient = ctx.createRadialGradient(x, y, 0, x, y, 46 * scale);
        auraGradient.addColorStop(0, 'rgba(49, 46, 129, 0.5)');
        auraGradient.addColorStop(1, 'rgba(49, 46, 129, 0)');
        ctx.fillStyle = auraGradient;
        ctx.beginPath();
        ctx.arc(x, y, 46 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Shadowy tendrils
        const shadowTime = Date.now() / 600;
        for (let i = 0; i < 8; i++) {
            const angle = (Math.PI * 2 * i / 8) + shadowTime;
            const wave = Math.sin(shadowTime * 2 + i) * 8 * scale;
            const length = 32 * scale;

            ctx.strokeStyle = 'rgba(67, 56, 202, 0.6)';
            ctx.lineWidth = 3 * scale;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.quadraticCurveTo(
                x + Math.cos(angle) * (length * 0.6) + wave,
                y + Math.sin(angle) * (length * 0.6) + wave,
                x + Math.cos(angle) * length,
                y + Math.sin(angle) * length
            );
            ctx.stroke();
        }

        // Dark robed body
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(x - 32 * scale, y + 22 * scale);
        ctx.lineTo(x - 24 * scale, y - 18 * scale);
        ctx.lineTo(x + 24 * scale, y - 18 * scale);
        ctx.lineTo(x + 32 * scale, y + 22 * scale);
        // Wispy bottom
        ctx.quadraticCurveTo(x + 18 * scale, y + 18 * scale, x + 8 * scale, y + 24 * scale);
        ctx.quadraticCurveTo(x, y + 22 * scale, x - 8 * scale, y + 24 * scale);
        ctx.quadraticCurveTo(x - 18 * scale, y + 18 * scale, x - 32 * scale, y + 22 * scale);
        ctx.fill();

        // Crown of shadows
        ctx.fillStyle = '#1e1b4b';
        for (let i = 0; i < 7; i++) {
            ctx.beginPath();
            ctx.moveTo((x - 20 * scale) + (i * 6 * scale), y - 38 * scale);
            ctx.lineTo((x - 17 * scale) + (i * 6 * scale), y - 50 * scale);
            ctx.lineTo((x - 14 * scale) + (i * 6 * scale), y - 38 * scale);
            ctx.fill();
        }

        // Hooded face
        ctx.fillStyle = '#0c0a1f';
        ctx.fillRect(x - 20 * scale, y - 40 * scale, 40 * scale, 24 * scale);

        // Piercing purple eyes
        ctx.fillStyle = '#c084fc';
        ctx.shadowBlur = 28 * scale;
        ctx.shadowColor = '#a855f7';
        ctx.fillRect(x - 14 * scale, y - 32 * scale, 8 * scale, 10 * scale);
        ctx.fillRect(x + 6 * scale, y - 32 * scale, 8 * scale, 10 * scale);
        ctx.shadowBlur = 0;

        // Shadow scythe
        ctx.strokeStyle = '#4338ca';
        ctx.lineWidth = 5 * scale;
        ctx.beginPath();
        ctx.moveTo(x - 40 * scale, y + 10 * scale);
        ctx.lineTo(x - 40 * scale, y - 30 * scale);
        ctx.stroke();
        ctx.fillStyle = '#312e81';
        ctx.beginPath();
        ctx.arc(x - 40 * scale, y - 34 * scale, 10 * scale, Math.PI / 4, Math.PI, false);
        ctx.fill();
    } else if (enemyName.includes('Destroyer')) {
        // MOLTEN DESTROYER - Lava colossus
        const scale = 0.95;

        // Molten aura
        const auraGradient = ctx.createRadialGradient(x, y, 0, x, y, 48 * scale);
        auraGradient.addColorStop(0, 'rgba(249, 115, 22, 0.5)');
        auraGradient.addColorStop(1, 'rgba(249, 115, 22, 0)');
        ctx.fillStyle = auraGradient;
        ctx.beginPath();
        ctx.arc(x, y, 48 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Heat waves
        for (let i = 0; i < 4; i++) {
            const waveY = y - 30 * scale + (i * 15 * scale);
            ctx.strokeStyle = `rgba(251, 146, 60, ${0.3 - i * 0.05})`;
            ctx.lineWidth = 2 * scale;
            ctx.beginPath();
            ctx.moveTo(x - 40 * scale, waveY);
            ctx.quadraticCurveTo(x - 20 * scale, waveY - 4 * scale, x, waveY);
            ctx.quadraticCurveTo(x + 20 * scale, waveY + 4 * scale, x + 40 * scale, waveY);
            ctx.stroke();
        }

        // Rocky body with lava cracks
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 34 * scale, y - 20 * scale, 68 * scale, 42 * scale);

        // Glowing lava cracks
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 3 * scale;
        ctx.shadowBlur = 15 * scale;
        ctx.shadowColor = '#f97316';
        for (let i = 0; i < 6; i++) {
            ctx.beginPath();
            ctx.moveTo((x - 30 * scale) + (i * 10 * scale), y - 16 * scale);
            ctx.lineTo((x - 26 * scale) + (i * 10 * scale), y + 16 * scale);
            ctx.stroke();
        }
        ctx.shadowBlur = 0;

        // Molten shoulders
        ctx.fillStyle = '#c2410c';
        ctx.fillRect(x - 48 * scale, y - 18 * scale, 18 * scale, 26 * scale);
        ctx.fillRect(x + 30 * scale, y - 18 * scale, 18 * scale, 26 * scale);

        // Lava drips
        ctx.fillStyle = '#fb923c';
        for (let i = 0; i < 4; i++) {
            ctx.fillRect((x - 42 * scale) + (i * 3 * scale), y + 6 * scale + (i * 2 * scale), 2 * scale, 6 * scale);
            ctx.fillRect((x + 34 * scale) + (i * 3 * scale), y + 6 * scale + (i * 2 * scale), 2 * scale, 6 * scale);
        }

        // Head with molten core
        ctx.fillStyle = '#9a3412';
        ctx.fillRect(x - 22 * scale, y - 40 * scale, 44 * scale, 22 * scale);

        // Blazing eyes
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 30 * scale;
        ctx.shadowColor = '#f97316';
        ctx.fillRect(x - 14 * scale, y - 34 * scale, 8 * scale, 8 * scale);
        ctx.fillRect(x + 6 * scale, y - 34 * scale, 8 * scale, 8 * scale);
        ctx.shadowBlur = 0;

        // Molten core on chest (pulsing)
        const corePulse = 0.7 + Math.sin(Date.now() / 350) * 0.3;
        ctx.fillStyle = `rgba(251, 191, 36, ${corePulse})`;
        ctx.shadowBlur = 25 * scale;
        ctx.shadowColor = '#f97316';
        ctx.beginPath();
        ctx.arc(x, y, 10 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // MASSIVE LAVA HAMMER - right hand
        ctx.fillStyle = '#9a3412';
        ctx.fillRect(x + 38 * scale, y - 32 * scale, 8 * scale, 54 * scale);
        ctx.fillStyle = '#c2410c';
        ctx.fillRect(x + 30 * scale, y - 40 * scale, 24 * scale, 16 * scale);
        // Molten core in hammer
        ctx.fillStyle = '#fbbf24';
        ctx.shadowBlur = 20 * scale;
        ctx.shadowColor = '#f97316';
        ctx.fillRect(x + 34 * scale, y - 36 * scale, 16 * scale, 8 * scale);
        ctx.shadowBlur = 0;
        // Lava drips from hammer
        ctx.fillStyle = '#fb923c';
        for (let i = 0; i < 3; i++) {
            ctx.fillRect((x + 34 * scale) + (i * 5 * scale), y - 24 * scale + (i * 2 * scale), 2 * scale, 6 * scale);
        }
    } else if (enemyName.includes('Sentinel')) {
        // CRYSTAL SENTINEL - Diamond fortress
        const scale = 1.0;

        // Crystal refraction aura
        const auraGradient = ctx.createRadialGradient(x, y, 0, x, y, 50 * scale);
        auraGradient.addColorStop(0, 'rgba(6, 182, 212, 0.4)');
        auraGradient.addColorStop(1, 'rgba(103, 232, 249, 0)');
        ctx.fillStyle = auraGradient;
        ctx.beginPath();
        ctx.arc(x, y, 50 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Floating crystal shards
        for (let i = 0; i < 8; i++) {
            const angle = (Math.PI * 2 * i / 8) + Date.now() / 1000;
            const radius = 32 * scale + Math.sin(Date.now() / 500 + i) * 4 * scale;
            const shardX = x + Math.cos(angle) * radius;
            const shardY = y + Math.sin(angle) * radius;

            ctx.fillStyle = '#67e8f9';
            ctx.shadowBlur = 10 * scale;
            ctx.shadowColor = '#06b6d4';
            ctx.beginPath();
            ctx.moveTo(shardX, shardY - 4 * scale);
            ctx.lineTo(shardX + 2 * scale, shardY);
            ctx.lineTo(shardX, shardY + 4 * scale);
            ctx.lineTo(shardX - 2 * scale, shardY);
            ctx.closePath();
            ctx.fill();
        }
        ctx.shadowBlur = 0;

        // Crystalline body
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 36 * scale, y - 22 * scale, 72 * scale, 44 * scale);

        // Crystal facets (lighter)
        ctx.fillStyle = '#22d3ee';
        ctx.fillRect(x - 32 * scale, y - 18 * scale, 30 * scale, 18 * scale);
        ctx.fillRect(x + 2 * scale, y - 18 * scale, 30 * scale, 18 * scale);
        ctx.fillRect(x - 32 * scale, y + 4 * scale, 30 * scale, 16 * scale);
        ctx.fillRect(x + 2 * scale, y + 4 * scale, 30 * scale, 16 * scale);

        // Crystal highlights
        ctx.fillStyle = '#f0fdfa';
        for (let i = 0; i < 12; i++) {
            const hX = (x - 30 * scale) + (i * 5 * scale);
            const hY = (y - 16 * scale) + ((i % 3) * 12 * scale);
            ctx.fillRect(hX, hY, 2 * scale, 4 * scale);
        }

        // Massive crystal pauldrons
        ctx.fillStyle = '#0891b2';
        ctx.fillRect(x - 52 * scale, y - 20 * scale, 20 * scale, 30 * scale);
        ctx.fillRect(x + 32 * scale, y - 20 * scale, 20 * scale, 30 * scale);

        // Crystal spikes on shoulders
        ctx.fillStyle = '#67e8f9';
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.moveTo((x - 46 * scale) + (i * 6 * scale), y - 20 * scale);
            ctx.lineTo((x - 43 * scale) + (i * 6 * scale), y - 32 * scale);
            ctx.lineTo((x - 40 * scale) + (i * 6 * scale), y - 20 * scale);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo((x + 36 * scale) + (i * 6 * scale), y - 20 * scale);
            ctx.lineTo((x + 39 * scale) + (i * 6 * scale), y - 32 * scale);
            ctx.lineTo((x + 42 * scale) + (i * 6 * scale), y - 20 * scale);
            ctx.fill();
        }

        // Crystal helmet
        ctx.fillStyle = '#0e7490';
        ctx.fillRect(x - 24 * scale, y - 44 * scale, 48 * scale, 24 * scale);

        // Glowing crystal eyes
        ctx.fillStyle = '#f0fdfa';
        ctx.shadowBlur = 28 * scale;
        ctx.shadowColor = '#06b6d4';
        ctx.fillRect(x - 16 * scale, y - 36 * scale, 8 * scale, 10 * scale);
        ctx.fillRect(x + 8 * scale, y - 36 * scale, 8 * scale, 10 * scale);
        ctx.shadowBlur = 0;

        // Crystal core on chest (bright pulsing)
        const crystalPulse = 0.8 + Math.sin(Date.now() / 400) * 0.2;
        ctx.fillStyle = `rgba(103, 232, 249, ${crystalPulse})`;
        ctx.shadowBlur = 30 * scale;
        ctx.shadowColor = '#06b6d4';
        ctx.beginPath();
        ctx.arc(x, y, 8 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(x - 2 * scale, y - 2 * scale, 3 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // CRYSTAL SWORD - right hand
        ctx.fillStyle = '#22d3ee';
        ctx.fillRect(x + 40 * scale, y - 38 * scale, 6 * scale, 58 * scale);
        ctx.fillStyle = '#67e8f9';
        ctx.fillRect(x + 41 * scale, y - 36 * scale, 4 * scale, 54 * scale);
        // Crossguard
        ctx.fillStyle = '#06b6d4';
        ctx.fillRect(x + 32 * scale, y - 10 * scale, 22 * scale, 4 * scale);
        // Crystal glow on blade
        ctx.shadowBlur = 18 * scale;
        ctx.shadowColor = '#06b6d4';
        ctx.fillStyle = 'rgba(103, 232, 249, 0.8)';
        ctx.fillRect(x + 42 * scale, y - 34 * scale, 2 * scale, 50 * scale);
        ctx.shadowBlur = 0;
			} else if (enemyName === 'Treasure Guardian') {
    // TREASURE GUARDIAN - MASSIVE 2X SIZE with bags of gold
    const scale = 4.0; // 4x bigger to match shadow!
    console.log('üí∞ Treasure Guardian scale:', scale, 'Shadow should be:', 35 * scale);

    // Larger golden aura
    const auraGradient = ctx.createRadialGradient(x, y, 0, x, y, 50 * scale);
    auraGradient.addColorStop(0, 'rgba(245, 158, 11, 0.4)');
    auraGradient.addColorStop(1, 'rgba(245, 158, 11, 0)');
    ctx.fillStyle = auraGradient;
    ctx.beginPath();
    ctx.arc(x, y, 50 * scale, 0, Math.PI * 2);
    ctx.fill();

    // Massive armored body with ornate detail
    ctx.fillStyle = this.color;
    ctx.fillRect(x - 16 * scale, y - 10 * scale, 32 * scale, 20 * scale);

    // Armor plating with gold inlay
    ctx.fillStyle = '#1a1300';
    ctx.fillRect(x - 13 * scale, y - 8 * scale, 26 * scale, 3 * scale);
    ctx.fillRect(x - 13 * scale, y - 2 * scale, 26 * scale, 3 * scale);
    ctx.fillRect(x - 13 * scale, y + 4 * scale, 26 * scale, 3 * scale);

    // Golden trim (thicker for bigger size)
    ctx.fillStyle = '#f59e0b';
    ctx.fillRect(x - 14 * scale, y - 9 * scale, 28 * scale, 2 * scale);
    ctx.fillRect(x - 14 * scale, y - 1 * scale, 28 * scale, 2 * scale);
    ctx.fillRect(x - 14 * scale, y + 5 * scale, 28 * scale, 2 * scale);

    // Ornate gold patterns on chest
    ctx.fillStyle = '#fbbf24';
    ctx.fillRect(x - 8 * scale, y - 6 * scale, 2 * scale, 2 * scale);
    ctx.fillRect(x + 6 * scale, y - 6 * scale, 2 * scale, 2 * scale);
    ctx.fillRect(x - 4 * scale, y * scale, 8 * scale, 2 * scale);

    // Large pauldrons (shoulders)
    ctx.fillStyle = this.color;
    ctx.fillRect(x - 22 * scale, y - 9 * scale, 8 * scale, 12 * scale);
    ctx.fillRect(x + 14 * scale, y - 9 * scale, 8 * scale, 12 * scale);

    // Golden shoulder spikes (more impressive)
    ctx.fillStyle = '#f59e0b';
    ctx.fillRect(x - 21 * scale, y - 12 * scale, 3 * scale, 4 * scale);
    ctx.fillRect(x - 17 * scale, y - 14 * scale, 3 * scale, 6 * scale);
    ctx.fillRect(x - 13 * scale, y - 12 * scale, 3 * scale, 4 * scale);
    ctx.fillRect(x + 11 * scale, y - 12 * scale, 3 * scale, 4 * scale);
    ctx.fillRect(x + 15 * scale, y - 14 * scale, 3 * scale, 6 * scale);
    ctx.fillRect(x + 19 * scale, y - 12 * scale, 3 * scale, 4 * scale);

    // Imposing helmet
    ctx.fillStyle = '#1a1300';
    ctx.fillRect(x - 10 * scale, y - 18 * scale, 20 * scale, 10 * scale);

    // Elaborate golden crown
    ctx.fillStyle = '#f59e0b';
    ctx.fillRect(x - 12 * scale, y - 24 * scale, 6 * scale, 6 * scale);
    ctx.fillRect(x - 5 * scale, y - 27 * scale, 5 * scale, 9 * scale);
    ctx.fillRect(x + 1 * scale, y - 28 * scale, 5 * scale, 10 * scale);
    ctx.fillRect(x + 7 * scale, y - 24 * scale, 6 * scale, 6 * scale);

    // Crown jewels (emeralds)
    ctx.fillStyle = '#10b981';
    ctx.fillRect(x - 9 * scale, y - 22 * scale, 2 * scale, 2 * scale);
    ctx.fillRect(x - 2 * scale, y - 24 * scale, 2 * scale, 2 * scale);
    ctx.fillRect(x + 3 * scale, y - 25 * scale, 2 * scale, 2 * scale);
    ctx.fillRect(x + 9 * scale, y - 22 * scale, 2 * scale, 2 * scale);

    // Golden face plate
    ctx.fillStyle = '#f59e0b';
    ctx.fillRect(x - 9 * scale, y - 17 * scale, 18 * scale, 9 * scale);
    ctx.fillStyle = '#1a1300';
    ctx.fillRect(x - 7 * scale, y - 15 * scale, 14 * scale, 5 * scale);

    // Intimidating glowing eyes
    ctx.fillStyle = '#fff';
    ctx.shadowBlur = 15 * scale;
    ctx.shadowColor = '#f59e0b';
    ctx.fillRect(x - 6 * scale, y - 14 * scale, 4 * scale, 4 * scale);
    ctx.fillRect(x + 2 * scale, y - 14 * scale, 4 * scale, 4 * scale);

    ctx.fillStyle = '#fbbf24';
    ctx.fillRect(x - 5 * scale, y - 13 * scale, 2 * scale, 2 * scale);
    ctx.fillRect(x + 3 * scale, y - 13 * scale, 2 * scale, 2 * scale);
    ctx.shadowBlur = 0;

    // BAGS OF GOLD IN LEFT HAND (instead of shield)
    // Large bulging sack
    ctx.fillStyle = '#8b7355';
    ctx.fillRect(x - 28 * scale, y - 2 * scale, 10 * scale, 14 * scale);
    ctx.fillRect(x - 26 * scale, y - 4 * scale, 6 * scale, 3 * scale);

    // Sack tie (rope)
    ctx.fillStyle = '#6a5a45';
    ctx.fillRect(x - 25 * scale, y - 5 * scale, 4 * scale, 2 * scale);

    // Gold coins spilling out
    ctx.fillStyle = '#fbbf24';
    ctx.beginPath();
    ctx.arc(x - 26 * scale, y + 11 * scale, 2 * scale, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x - 22 * scale, y + 10 * scale, 2 * scale, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x - 24 * scale, y + 8 * scale, 1.5 * scale, 0, Math.PI * 2);
    ctx.fill();

    // Coin shine
    ctx.fillStyle = '#fef3c7';
    ctx.beginPath();
    ctx.arc(x - 25 * scale, y + 10 * scale, 0.8 * scale, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x - 21 * scale, y + 9 * scale, 0.8 * scale, 0, Math.PI * 2);
    ctx.fill();

    // MASSIVE WAR HAMMER in right hand
    ctx.fillStyle = '#71717a';
    ctx.fillRect(x + 17 * scale, y - 25 * scale, 4 * scale, 40 * scale);

    // Ornate hammer head (golden with spikes)
    ctx.fillStyle = '#f59e0b';
    ctx.fillRect(x + 12 * scale, y - 28 * scale, 14 * scale, 8 * scale);
    ctx.fillStyle = '#fbbf24';
    ctx.fillRect(x + 13 * scale, y - 27 * scale, 12 * scale, 6 * scale);

    // Hammer spikes (more dangerous)
    ctx.fillStyle = '#c0c0c0';
    ctx.fillRect(x + 10 * scale, y - 26 * scale, 3 * scale, 4 * scale);
    ctx.fillRect(x + 25 * scale, y - 26 * scale, 3 * scale, 4 * scale);
    ctx.fillRect(x + 17 * scale, y - 30 * scale, 4 * scale, 3 * scale);

    // Handle wrap (leather)
    ctx.fillStyle = '#8b7355';
    for (let i = 0; i < 5; i++) {
        ctx.fillRect(x + 17 * scale, y - 20 * scale + i * 6 * scale, 4 * scale, 2 * scale);
    }

    // Large treasure chest emblem on chest armor
    ctx.fillStyle = '#f59e0b';
    ctx.fillRect(x - 6 * scale, y - 4 * scale, 12 * scale, 8 * scale);
    ctx.fillStyle = '#1a1300';
    ctx.fillRect(x - 5 * scale, y - 3 * scale, 10 * scale, 6 * scale);

    // Chest lock (golden)
    ctx.fillStyle = '#fbbf24';
    ctx.fillRect(x - 1 * scale, y - 2 * scale, 2 * scale, 4 * scale);
    ctx.fillRect(x - 2 * scale, y - 1 * scale, 4 * scale, 2 * scale);

    // Glowing treasure gem on chest (static)
    ctx.fillStyle = 'rgba(245, 158, 11, 0.9)';
    ctx.shadowBlur = 12 * scale;
    ctx.shadowColor = '#f59e0b';
    ctx.beginPath();
    ctx.arc(x, y + 5 * scale, 3 * scale, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;

    // Gem highlight
    ctx.fillStyle = '#fef3c7';
    ctx.beginPath();
    ctx.arc(x - 1 * scale, y + 4 * scale, 1.5 * scale, 0, Math.PI * 2);
    ctx.fill();

    // Gold coin details on armor (decorative)
    ctx.fillStyle = '#fbbf24';
    ctx.beginPath();
    ctx.arc(x - 10 * scale, y + 6 * scale, 1.5 * scale, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x + 10 * scale, y + 6 * scale, 1.5 * scale, 0, Math.PI * 2);
    ctx.fill();
} else if (enemyName === 'Keystone Warden' || (enemyName.includes('Warden') && !enemyName.includes('Hound'))) {
        // KEYSTONE WARDEN - VAULT GUARDIAN
        console.log('‚úÖ RENDERING KEYSTONE WARDEN NOW');
        const scale = 1.0;
    // ... rest of Keystone Warden code

        // Golden aura around boss
        const auraGradient = ctx.createRadialGradient(x, y, 0, x, y, 60 * scale);
        auraGradient.addColorStop(0, 'rgba(245, 158, 11, 0.4)');
        auraGradient.addColorStop(1, 'rgba(245, 158, 11, 0)');
        ctx.fillStyle = auraGradient;
        ctx.beginPath();
        ctx.arc(x, y, 60 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Massive armored body with detail
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 36, y - 24, 72, 48);

        // Armor plating details
        ctx.fillStyle = '#1a1300';
        ctx.fillRect(x - 30, y - 18, 60, 6);
        ctx.fillRect(x - 30, y - 6, 60, 6);
        ctx.fillRect(x - 30, y + 6, 60, 6);

        // Golden trim on armor
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(x - 32, y - 20, 64, 2);
        ctx.fillRect(x - 32, y - 4, 64, 2);
        ctx.fillRect(x - 32, y + 8, 64, 2);

        // Massive pauldrons (shoulders)
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 50, y - 20, 18, 28);
        ctx.fillRect(x + 32, y - 20, 18, 28);

        // Golden spikes on shoulders
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(x - 48, y - 26, 3, 6);
        ctx.fillRect(x - 43, y - 28, 3, 8);
        ctx.fillRect(x - 38, y - 26, 3, 6);
        ctx.fillRect(x + 35, y - 26, 3, 6);
        ctx.fillRect(x + 40, y - 28, 3, 8);
        ctx.fillRect(x + 45, y - 26, 3, 6);

        // Ornate helmet
        ctx.fillStyle = '#1a1300';
        ctx.fillRect(x - 22, y - 42, 44, 24);

        // Golden crown/helmet crest
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(x - 24, y - 50, 10, 8);
        ctx.fillRect(x - 10, y - 54, 8, 12);
        ctx.fillRect(x + 2, y - 56, 8, 14);
        ctx.fillRect(x + 14, y - 50, 10, 8);

        // Face plate with details
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(x - 18, y - 38, 36, 18);
        ctx.fillStyle = '#1a1300';
        ctx.fillRect(x - 14, y - 34, 28, 10);

        // GLOWING GOLDEN EYES - INTIMIDATING
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 25;
        ctx.shadowColor = '#f59e0b';
        ctx.fillRect(x - 12, y - 32, 7, 7);
        ctx.fillRect(x + 5, y - 32, 7, 7);

        // Eye glow effect (layered)
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(x - 11, y - 31, 5, 5);
        ctx.fillRect(x + 6, y - 31, 5, 5);
        ctx.shadowBlur = 0;

        // Massive war hammer
        ctx.fillStyle = '#71717a';
        ctx.fillRect(x + 38, y - 45, 6, 70);

        // Hammer head (golden)
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(x + 30, y - 50, 22, 12);
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(x + 32, y - 48, 18, 8);

        // Hammer spikes
        ctx.fillStyle = '#c0c0c0';
        ctx.fillRect(x + 28, y - 46, 4, 4);
        ctx.fillRect(x + 50, y - 46, 4, 4);

        // Keystone gem on chest (pulsing)
        const keystonePulse = 0.6 + Math.sin(Date.now() / 400) * 0.4;
        ctx.fillStyle = `rgba(245, 158, 11, ${keystonePulse})`;
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#f59e0b';
        ctx.beginPath();
        ctx.arc(x, y - 8, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Gem highlight
        ctx.fillStyle = '#fef3c7';
        ctx.beginPath();
        ctx.arc(x - 2, y - 10, 3, 0, Math.PI * 2);
        ctx.fill();
    } else if (enemyName.includes('Hound')) {
        // Warden Hound (miniature Warden - 0.8x scale)
        ctx.fillStyle = this.color;
        // Massive armored body
        ctx.fillRect(x - 14.4, y - 9.6, 28.8, 19.2);
        // Shoulders
        ctx.fillRect(x - 17.6, y - 8, 6.4, 9.6);
        ctx.fillRect(x + 11.2, y - 8, 6.4, 9.6);
        // Helmet with crown
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(x - 8, y - 16, 16, 8);
        // Crown points (smaller)
        ctx.fillRect(x - 8, y - 19.2, 3.2, 3.2);
        ctx.fillRect(x - 1.6, y - 20.8, 3.2, 4.8);
        ctx.fillRect(x + 4.8, y - 19.2, 3.2, 3.2);
        // Glowing eyes
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 8;
        ctx.shadowColor = '#f59e0b';
        ctx.fillRect(x - 4.8, y - 12.8, 2.4, 2.4);
        ctx.fillRect(x + 2.4, y - 12.8, 2.4, 2.4);
        ctx.shadowBlur = 0;
        // Weapon (smaller)
        ctx.fillStyle = '#c0c0c0';
        ctx.fillRect(x + 14.4, y - 16, 3.2, 24);
        ctx.fillRect(x + 12.8, y - 17.6, 6.4, 3.2);
    } else if (enemyName.includes('Guardian')) {
        console.log('üî• RENDERING CUSTOM RUNE GUARDIAN!');
        console.log('Guardian rendering - enemyName:', enemyName);
        // RUNE GUARDIAN BOSS - MASSIVE AND TERRIFYING
        const scale = 2.5; // 2.5x bigger than normal

        // Massive dark body with purple glow
        ctx.fillStyle = this.color;
        ctx.fillRect(x - 18 * scale, y - 12 * scale, 36 * scale, 24 * scale);

        // Armored shoulders
        ctx.fillStyle = '#2a1a4a';
        ctx.fillRect(x - 24 * scale, y - 10 * scale, 12 * scale, 16 * scale);
        ctx.fillRect(x + 12 * scale, y - 10 * scale, 12 * scale, 16 * scale);

        // Helmet/head with horns
        ctx.fillStyle = '#1a0a3a';
        ctx.fillRect(x - 12 * scale, y - 20 * scale, 24 * scale, 12 * scale);

        // Large curved horns
        ctx.fillStyle = '#0f0520';
        ctx.fillRect(x - 16 * scale, y - 26 * scale, 6 * scale, 10 * scale);
        ctx.fillRect(x + 10 * scale, y - 26 * scale, 6 * scale, 10 * scale);

        // GLOWING RED EYES - TERRIFYING
        ctx.fillStyle = '#ff0000';
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#ff0000';
        ctx.fillRect(x - 8 * scale, y - 16 * scale, 4 * scale, 4 * scale);
        ctx.fillRect(x + 4 * scale, y - 16 * scale, 4 * scale, 4 * scale);
        ctx.shadowBlur = 0;

        // Purple energy aura
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, 40 * scale);
        gradient.addColorStop(0, 'rgba(168, 85, 247, 0.3)');
        gradient.addColorStop(1, 'rgba(168, 85, 247, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, 40 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Glowing runes on body (pulsing)
        const pulseAlpha = 0.5 + Math.sin(Date.now() / 300) * 0.3;
        ctx.fillStyle = `rgba(139, 92, 246, ${pulseAlpha})`;
        ctx.fillRect(x - 6 * scale, y - 6 * scale, 3 * scale, 3 * scale);
        ctx.fillRect(x + 3 * scale, y - 6 * scale, 3 * scale, 3 * scale);
        ctx.fillRect(x - 2 * scale, y + 2 * scale, 4 * scale, 4 * scale);

    } else {
        // Default fallback for bosses and unknown enemies
        const isBoss = window.game?.enemies?.find(e => e.sprite === this)?.isBoss;
        if (isBoss) {
            // Boss default (larger, more menacing)
            ctx.fillStyle = this.color;
            ctx.fillRect(x - 14, y - 12, 28, 24);
            ctx.fillRect(x - 10, y - 18, 20, 8);
            // Crown or horns
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(x - 8, y - 22, 3, 4);
            ctx.fillRect(x - 2, y - 24, 4, 6);
            ctx.fillRect(x + 5, y - 22, 3, 4);
        } else {
            // Simple default enemy
            ctx.fillStyle = this.color;
            ctx.fillRect(x - 10, y - 10, 20, 20);
            ctx.fillRect(x - 8, y - 18, 16, 10);
        }
    }
}

                // Attack effect removed for less clutter

                // Movement trail effect when moving fast
        if (this.isMoving && this.type === 'party') {
            ctx.fillStyle = this.color + '30';
            ctx.fillRect(x - 8 - this.offsetY * 2, y - 8, 16, 16);
        }

        }

            moveTo(x, y, instant = false) {
                // Boundary constraints for special dungeons
                if (window.game && (window.game.currentDungeon === 'runetrial' ||
                    window.game.currentDungeon === 'vault' ||
                    window.game.currentDungeon === 'endlessblessings')) {
                    const gridSize = window.game.room ? (window.game.room.width || 30) : 30;
                    x = Math.max(0, Math.min(gridSize - 1, x));
                    y = Math.max(0, Math.min(gridSize - 1, y));
                }

                if (instant) {
                    this.gridX = x;
                    this.gridY = y;
                    this.targetX = x;
                    this.targetY = y;
                    const pos = ISO.toScreen(x, y);
                    this.screenX = pos.x;
                    this.screenY = pos.y;
                } else {
                    this.targetX = x;
                    this.targetY = y;
                }
            }

            setCombatPosition(x, y) {
                this.combatX = x;
                this.combatY = y;
                this.moveTo(x, y);
            }

            returnToCombatPosition() {
                this.moveTo(this.combatX, this.combatY);
            }
        }

        // Dungeon room class
        class DungeonRoom {
            constructor(width, height, type, dungeonTheme = 'stoneforge') {
                this.width = width;
                this.height = height;
                this.type = type;
                this.dungeonTheme = dungeonTheme;
                this.tiles = [];
                this.generateTiles();
            }

generateTiles() {
    for (let y = 0; y < this.height; y++) {
        for (let x = 0; x < this.width; x++) {
            const variation = Math.random();
            let color;

            // Vault rooms are black with gold accents
            if (this.dungeonTheme === 'vault') {
                color = variation < 0.2 ? '#1a1300' : '#0a0a00';
            }
            // Divine Arena - divine yellow/gold theme (toned down)
            else if (this.dungeonTheme === 'endlessblessings') {
                if (variation < 0.1) {
                    color = '#9a7d3a'; // Darker muted gold
                } else if (variation < 0.3) {
                    color = '#b89d58'; // Muted khaki
                } else if (variation < 0.5) {
                    color = '#c4a747'; // Subdued gold
                } else if (variation < 0.7) {
                    color = '#d4b86a'; // Muted yellow-gold
                } else {
                    color = '#ccbb7a'; // Soft cream-gold
                }
            }
            // Boss rooms are always red regardless of dungeon
            else if (this.type === ROOM_TYPES.BOSS) {
                color = variation < 0.3 ? '#8b0000' : '#660000';
                        } else if (this.type === ROOM_TYPES.TREASURE) {
                            color = variation < 0.3 ? '#665500' : '#554400';
                        } else if (this.type === ROOM_TYPES.FOUNTAIN) {
                            // Fountain of Youth - blue colored tiles
                            color = variation < 0.3 ? '#1a3a4a' : '#2a4a5a';
                        } else if (this.type === ROOM_TYPES.ENTRANCE) {
                            // Entrance matches dungeon theme
                            if (this.dungeonTheme === 'umbral') {
                                color = variation < 0.3 ? '#2a1a3a' : '#3a2a4a';
                            } else if (this.dungeonTheme === 'everfall') {
                                color = variation < 0.3 ? '#1a3a2a' : '#2a4a3a';
                            } else {
                                // Stoneforge - grey
                                color = variation < 0.2 ? '#2a2a2a' : '#333333';
                            }
                        } else if (this.type === ROOM_TYPES.PATHWAY) {
                            // Hallway tiles match dungeon theme
                            if (this.dungeonTheme === 'umbral') {
                                color = variation < 0.2 ? '#2a1a3a' : '#3a2a4a';
                            } else if (this.dungeonTheme === 'everfall') {
                                color = variation < 0.2 ? '#1a3a2a' : '#2a4a3a';
                            } else {
                                color = variation < 0.2 ? '#2a2a2a' : '#333333';
                            }
                        } else {
                            // Normal room colors based on dungeon theme
                            if (this.dungeonTheme === 'umbral') {
                                // Purple theme for Umbral Depths
                                if (variation < 0.1) {
                                    color = '#3a2a4a';
                                } else if (variation < 0.2) {
                                    color = '#4a3a5a';
                                } else {
                                    color = '#5a4a6a';
                                }
                            } else if (this.dungeonTheme === 'everfall') {
                                // Green theme for Everfall
                                if (variation < 0.1) {
                                    color = '#2a4a3a';
                                } else if (variation < 0.2) {
                                    color = '#3a5a4a';
                                } else {
                                    color = '#4a6a5a';
                                }
                            } else {
                                // Grey theme for Stoneforge (default)
                                if (variation < 0.1) {
                                    color = '#3a3a3a';
                                } else if (variation < 0.2) {
                                    color = '#424242';
                                } else {
                                    color = '#4a4a4a';
                                }
                            }
                        }
                        this.tiles.push({ x, y, color });
                    }
                }
            }

            draw(ctx, offsetX, offsetY, drawWalls = true) {
                // Draw tiles in isometric order
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const tile = this.tiles[y * this.width + x];
                        const pos = ISO.toScreen(x, y);

                        ctx.fillStyle = tile.color;
                        ctx.beginPath();
                        ctx.moveTo(pos.x + offsetX, pos.y + offsetY);
                        ctx.lineTo(pos.x + offsetX + ISO.tileWidth/2, pos.y + offsetY + ISO.tileHeight/2);
                        ctx.lineTo(pos.x + offsetX, pos.y + offsetY + ISO.tileHeight);
                        ctx.lineTo(pos.x + offsetX - ISO.tileWidth/2, pos.y + offsetY + ISO.tileHeight/2);
                        ctx.closePath();
                        ctx.fill();

                        ctx.strokeStyle = '#222';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }

// Draw walls only for main rooms, not hallways
if (drawWalls && this.type !== ROOM_TYPES.PATHWAY) {
    // Vault rooms have golden walls
    ctx.fillStyle = this.dungeonTheme === 'vault' ? '#f59e0b' : '#222';
    for (let x = 0; x < this.width; x++) {
        const pos = ISO.toScreen(x, 0);
        ctx.fillRect(pos.x + offsetX - 2, pos.y + offsetY - 40, 4, 40);
    }
    for (let y = 0; y < this.height; y++) {
        const pos = ISO.toScreen(0, y);
        ctx.fillRect(pos.x + offsetX - 2, pos.y + offsetY - 40, 4, 40);
    }
}
            }
        }

        // Character classes
class Character {
            constructor(name, className, level, maxHp, maxMana, attack, defense, attackSpeed) {
    this.name = name;
    this.className = className;
    this.level = level;
    this.maxHp = maxHp;
    this.hp = maxHp;
    this.maxMana = maxMana;
this.mana = maxMana;
this._baseMana = maxMana; // Store base for recalculation
    this.attack = attack;
    this.defense = defense;
    this.attackSpeed = attackSpeed;

    // New combat stats
    this.critChance = 5; // Base 5%
    this.critDamage = 150; // Base 150% (1.5x multiplier)
    this.dodgeChance = 0; // Base 0%
    this.lifesteal = 0; // Base 0%
    this.hpRegen = 0; // Base 0% - % of max HP restored between rooms
    this.manaRegen = 0; // Base 0% - % of max Mana restored per second
    this.cdr = 0; // Cooldown reduction %

    // Skill tree bonuses (initialized to 0)
    this.skillTreeAttack = 0;
    this.skillTreeDefense = 0;
    this.skillTreeHP = 0;
    this.skillTreeMana = 0;
    this.skillTreeAttackSpeed = 0;
    this.skillTreeCritChance = 0;
    this.skillTreeCritDamage = 0;
    this.skillTreeDodge = 0;
    this.skillTreeLifesteal = 0;
    this.skillTreeHPRegen = 0;
    this.skillTreeManaRegen = 0;
    this.skillTreeCDR = 0;

                this.xp = 0;
                this.maxXp = 100;
                this.skillPoints = 1; // Start with 1 skill point
                this.allocatedSkillNodes = new Set([0]); // Start node always allocated
                this.skillTreeData = {
                    allocatedNodes: new Set([0]),
                    usedPoints: 0
                };
                this.equipment = {
                    weapon: null,
                    chest: null,
                    helmet: null,
                    gloves: null,
                    boots: null,
                    amulet: null,
                    belt: null,
                    ring1: null,
                    ring2: null
                };
                this.cooldown = 0;
                this.sprite = null;
                this.isAlive = true;
            }

takeDamage(damage) {
    // God mode cheat - party members take no damage
    if (window.game && window.game.godModeEnabled && window.game.party.includes(this)) {
        return 0;
    }

    // Prevent damage to already dead units
    if (!this.isAlive || this.hp <= 0) {
        this.hp = 0;
        this.isAlive = false;

        // Pet drop from boss only (1 in 100, or 1 in 10 for first pet)
        if (window.game && this.isBoss && !this._petDropped) {
            this._petDropped = true;

            // Check if player has any pets yet
            const hasPets = window.game.pets.length > 0 ||
                           Object.values(window.game.equippedPets).some(pet => pet !== null);

            // Drop rate: 1 in 10 for first pet, 1 in 100 after that
            const dropRate = hasPets ? 0.01 : 0.1;

            if (Math.random() < dropRate) {
                const rarity = window.game.rollPetRarity();
                const petLevel = 1; // Always drop at level 1
                const dungeonType = window.game.currentDungeon || 'everfall';
                const pet = new Pet(rarity, petLevel, dungeonType);
                window.game.pets.push(pet);
                window.game.addLog(`Found pet: ${pet.getDisplayName()}!`, 'loot');

                // Show popup for rare+ pets
                if (['rare', 'epic', 'legendary'].includes(rarity)) {
                    lootPopupManager.showItemPopup({
                        rarity: rarity,
                        name: pet.name,
                        slot: 'Pet',
                        level: petLevel,
                        emoji: pet.emoji
                    });
                }
            }
        }

        return 0;
    }

    // Check for dodge
    if (Math.random() * 100 < this.getTotalDodgeChance()) {
        return 'DODGE';
    }

    // Check for invulnerability (Warden's Aegis)
    if (this.invulnerable) {
        return 0;
    }

    // Calculate damage reduction from defense (diminishing returns)
    const defense = this.getTotalDefense();
    const damageReduction = defense / (defense + 100); // Returns 0-1 (0% to 100%)
    let actualDamage = Math.max(1, Math.floor(damage * (1 - damageReduction)));

    // Shield absorbs damage first
    if (this.shieldAmount && this.shieldAmount > 0) {
        if (actualDamage <= this.shieldAmount) {
            // Shield absorbs all damage
            this.shieldAmount -= actualDamage;
            return actualDamage;
        } else {
            // Shield breaks, remaining damage goes to HP
            const remainingDamage = actualDamage - this.shieldAmount;
            this.shieldAmount = 0;
            this.hp = Math.max(0, this.hp - remainingDamage);
            actualDamage = remainingDamage;
        }
    } else {
        // No shield, damage goes directly to HP
        this.hp = Math.max(0, this.hp - actualDamage);
    }

    // Force HP to exactly 0 and mark as dead if HP is at or below 0
    if (this.hp <= 0) {
        this.hp = 0;
        this.isAlive = false;
        // Mark that positions changed for re-sorting
        if (window.game) window.game._unitPositionsChanged = true;
    }

    return actualDamage;
}

heal(amount) {
    const totalMaxHp = this.getTotalMaxHp();
    const healed = Math.min(amount, totalMaxHp - this.hp);
    this.hp += healed;
    return Math.round(healed * 100) / 100;  // Round to 2 decimal places
}

getTotalAttack() {
    let total = this.attack + this.skillTreeAttack;
    if (this.equipment.weapon) total += this.equipment.weapon.attack || 0;
    if (this.equipment.gloves) total += this.equipment.gloves.attack || 0;
    if (this.equipment.amulet) total += this.equipment.amulet.attack || 0;
    if (this.equipment.ring1) total += this.equipment.ring1.attack || 0;
    if (this.equipment.ring2) total += this.equipment.ring2.attack || 0;

    // Apply rune percentage bonuses
    if (this.runePercentBonuses && this.runePercentBonuses.attack) {
        total = total * (1 + this.runePercentBonuses.attack / 100);
    }

    // Apply attack debuffs (Earthshaker's Resolve)
    if (this.attackDebuff && this.attackDebuff > 0 && this.attackDebuff < 1) {
        total = total * this.attackDebuff; // attackDebuff is a multiplier (0.6 = 40% reduction)
    }

    return parseFloat(total.toFixed(2));
}

getTotalDefense() {
    let total = this.defense + this.skillTreeDefense;
    if (this.equipment.weapon) total += this.equipment.weapon.defense || 0;
    if (this.equipment.chest) total += this.equipment.chest.defense || 0;
    if (this.equipment.helmet) total += this.equipment.helmet.defense || 0;
    if (this.equipment.gloves) total += this.equipment.gloves.defense || 0;
    if (this.equipment.boots) total += this.equipment.boots.defense || 0;
    if (this.equipment.belt) total += this.equipment.belt.defense || 0;
    if (this.equipment.amulet) total += this.equipment.amulet.defense || 0;
    if (this.equipment.ring1) total += this.equipment.ring1.defense || 0;
    if (this.equipment.ring2) total += this.equipment.ring2.defense || 0;

    // Tank's taunt buff: +10 flat + percentage of defense for 5 seconds
    if (this.className === 'Tank' && this.tauntActive) {
        total += this.tauntDefenseBonus || 10;
    }

    // Apply rune percentage bonuses
    if (this.runePercentBonuses && this.runePercentBonuses.defense) {
        total = total * (1 + this.runePercentBonuses.defense / 100);
    }

    // Sacred Barrier: +30% defense
    if (this.sacredBarrierDefense) {
        total = total * (1 + this.sacredBarrierDefense);
    }

    // Apply defense debuffs (Assassin's Mark, Earthshaker's Resolve, etc.)
    if (this.defenseDebuff && this.defenseDebuff > 0) {
        total = Math.max(0, total - this.defenseDebuff);
    }

    // Cap at 999 defense
    total = Math.min(total, 999);

    return parseFloat(total.toFixed(2));
}

getTotalAttackSpeed() {
    let total = this.attackSpeed + (this.skillTreeAttackSpeed / 100);
    if (this.equipment.weapon) total += this.equipment.weapon.attackSpeed || 0;
    if (this.equipment.gloves) total += this.equipment.gloves.attackSpeed || 0;
    if (this.equipment.boots) total += this.equipment.boots.attackSpeed || 0;
    if (this.equipment.amulet) total += this.equipment.amulet.attackSpeed || 0;
    if (this.equipment.ring1) total += this.equipment.ring1.attackSpeed || 0;
    if (this.equipment.ring2) total += this.equipment.ring2.attackSpeed || 0;

    // Apply rune percentage bonuses
    if (this.runePercentBonuses && this.runePercentBonuses.attackspeed) {
        total = total * (1 + this.runePercentBonuses.attackspeed / 100);
    }

    // Berserker's Pact: +100% attack speed
    if (this.berserkerActive) {
        total = total * 2.0;
    }

    // Righteous Fury: +35% attack speed
    if (this.righteousFuryAS) {
        total = total * (1 + this.righteousFuryAS);
    }

    // Cap at 5.0 attack speed
    total = Math.min(total, 5.0);

    return parseFloat(total.toFixed(2));
}

getTotalCritChance() {
    let total = this.critChance + this.skillTreeCritChance;
    if (this.equipment.weapon) total += this.equipment.weapon.critChance || 0;
    if (this.equipment.gloves) total += this.equipment.gloves.critChance || 0;
    if (this.equipment.amulet) total += this.equipment.amulet.critChance || 0;
    if (this.equipment.ring1) total += this.equipment.ring1.critChance || 0;
    if (this.equipment.ring2) total += this.equipment.ring2.critChance || 0;

    // Apply rune percentage bonuses
    if (this.runePercentBonuses && this.runePercentBonuses.crit) {
        total = total + this.runePercentBonuses.crit;
    }

    // Cap at 100% crit chance
    total = Math.min(total, 100);

    return parseFloat(total.toFixed(2));
}

getTotalCritDamage() {
    let total = this.critDamage + this.skillTreeCritDamage;
    if (this.equipment.weapon) total += this.equipment.weapon.critDamage || 0;
    if (this.equipment.amulet) total += this.equipment.amulet.critDamage || 0;
    if (this.equipment.ring1) total += this.equipment.ring1.critDamage || 0;
    if (this.equipment.ring2) total += this.equipment.ring2.critDamage || 0;

    // Apply rune percentage bonuses
    if (this.runePercentBonuses && this.runePercentBonuses.critDamage) {
        total = total + this.runePercentBonuses.critDamage;
    }

    return parseFloat(total.toFixed(2));
}

getTotalDodgeChance() {
    let total = this.dodgeChance + this.skillTreeDodge;
    if (this.equipment.chest) total += this.equipment.chest.dodgeChance || 0;
    if (this.equipment.boots) total += this.equipment.boots.dodgeChance || 0;
    if (this.equipment.amulet) total += this.equipment.amulet.dodgeChance || 0;
    if (this.equipment.ring1) total += this.equipment.ring1.dodgeChance || 0;
    if (this.equipment.ring2) total += this.equipment.ring2.dodgeChance || 0;

    // Apply rune percentage bonuses
    if (this.runePercentBonuses && this.runePercentBonuses.dodge) {
        total = total + this.runePercentBonuses.dodge;
    }

    // Cap at 60% dodge
    total = Math.min(total, 60);

    return parseFloat(total.toFixed(2));
}

getTotalLifesteal() {
    let total = this.lifesteal + this.skillTreeLifesteal;
    if (this.equipment.weapon) total += this.equipment.weapon.lifesteal || 0;
    if (this.equipment.belt) total += this.equipment.belt.lifesteal || 0;
    if (this.equipment.amulet) total += this.equipment.amulet.lifesteal || 0;
    if (this.equipment.ring1) total += this.equipment.ring1.lifesteal || 0;
    if (this.equipment.ring2) total += this.equipment.ring2.lifesteal || 0;

    // Apply rune percentage bonuses
    if (this.runePercentBonuses && this.runePercentBonuses.lifesteal) {
        total = total + this.runePercentBonuses.lifesteal;
    }

    // Berserker's Pact: +50% lifesteal
    if (this.berserkerActive) {
        total = total + 50;
    }

    // Cap at 100% lifesteal (increased cap due to berserker)
    total = Math.min(total, 100);

    return parseFloat(total.toFixed(2));
}

getTotalHpRegen() {
    let total = this.hpRegen + this.skillTreeHPRegen;
    if (this.equipment.chest) total += this.equipment.chest.hpRegen || 0;
    if (this.equipment.belt) total += this.equipment.belt.hpRegen || 0;
    if (this.equipment.amulet) total += this.equipment.amulet.hpRegen || 0;
    if (this.equipment.ring1) total += this.equipment.ring1.hpRegen || 0;
    if (this.equipment.ring2) total += this.equipment.ring2.hpRegen || 0;

    // Apply rune percentage bonuses
    if (this.runePercentBonuses && this.runePercentBonuses.health) {
        // Note: health runes affect HP, not HP regen - kept separate
    }

    return parseFloat(total.toFixed(2));
}

getTotalManaRegen() {
    let total = this.manaRegen + this.skillTreeManaRegen;
    if (this.equipment.helmet) total += this.equipment.helmet.manaRegen || 0;
    if (this.equipment.weapon) total += this.equipment.weapon.manaRegen || 0;
    if (this.equipment.amulet) total += this.equipment.amulet.manaRegen || 0;
    if (this.equipment.ring1) total += this.equipment.ring1.manaRegen || 0;
    if (this.equipment.ring2) total += this.equipment.ring2.manaRegen || 0;

    // Apply rune percentage bonuses
    if (this.runePercentBonuses && this.runePercentBonuses.mana) {
        // Note: mana runes affect max mana, not mana regen - kept separate
    }

    return parseFloat(total.toFixed(2));
}

getTotalCDR() {
    let total = this.cdr + this.skillTreeCDR;
    if (this.equipment.helmet) total += this.equipment.helmet.cdr || 0;
    if (this.equipment.weapon && this.equipment.weapon.weaponType === 'wand') {
        total += this.equipment.weapon.cdr || 0;
    }
    if (this.equipment.weapon && this.equipment.weapon.weaponType === 'staff') {
        total += this.equipment.weapon.cdr || 0;
    }

    // Apply rune percentage bonuses (time runes give CDR)
    if (this.runePercentBonuses && this.runePercentBonuses.cdr) {
        total = total + this.runePercentBonuses.cdr;
    }

    // Cap at 80% CDR
    total = Math.min(total, 80);

    return parseFloat(total.toFixed(2));
}

getTotalMaxHp() {
    let total = this.maxHp + this.getMaxHpBonus();

    // Apply rune percentage bonuses
    if (this.runePercentBonuses && this.runePercentBonuses.health) {
        total = Math.floor(total * (1 + this.runePercentBonuses.health / 100));
    }

    return parseFloat(total.toFixed(2));
}

getTotalMaxMana() {
    let total = this.maxMana + this.getMaxManaBonus();

    // Apply rune percentage bonuses
    if (this.runePercentBonuses && this.runePercentBonuses.mana) {
        total = Math.floor(total * (1 + this.runePercentBonuses.mana / 100));
    }

    return parseFloat(total.toFixed(2));
}

getMaxHpBonus() {
    let bonus = this.skillTreeHP;
    if (this.equipment.weapon) bonus += this.equipment.weapon.hp || 0;
    if (this.equipment.helmet) bonus += this.equipment.helmet.hp || 0;
    if (this.equipment.gloves) bonus += this.equipment.gloves.hp || 0;
    if (this.equipment.chest) bonus += this.equipment.chest.hp || 0;
    if (this.equipment.boots) bonus += this.equipment.boots.hp || 0;
    if (this.equipment.belt) bonus += this.equipment.belt.hp || 0;
    if (this.equipment.amulet) bonus += this.equipment.amulet.hp || 0;
    if (this.equipment.ring1) bonus += this.equipment.ring1.hp || 0;
    if (this.equipment.ring2) bonus += this.equipment.ring2.hp || 0;
    return bonus;
}

getMaxManaBonus() {
    let bonus = this.skillTreeMana;
    if (this.equipment.weapon) bonus += this.equipment.weapon.mana || 0;
    if (this.equipment.helmet) bonus += this.equipment.helmet.mana || 0;
    if (this.equipment.chest) bonus += this.equipment.chest.mana || 0;
    if (this.equipment.amulet) bonus += this.equipment.amulet.mana || 0;
    if (this.equipment.ring1) bonus += this.equipment.ring1.mana || 0;
    if (this.equipment.ring2) bonus += this.equipment.ring2.mana || 0;
    return bonus;
}

            gainXP(amount) {
                this.xp += amount;
                while (this.xp >= this.maxXp) {
                    this.xp -= this.maxXp;
                    this.levelUp();
                }
            }

            levelUp() {
    if (this.level >= 100) return; // Level cap at 100

    this.level++;
    // Stat increases per level - gear is still 90%+ of power
    this.attack += 1;
    this.maxHp += 10;
    this.hp = this.getTotalMaxHp();
    this.maxMana += 0; // Mana doesn't increase on level
    this.mana = this.getTotalMaxMana();
    this.defense += 0.5;
    // No mana regen on level up - it comes from gear only (% based)

    // Grant skill point
    this.skillPoints++;

    // Update skill cost based on new level (scales +5 every 5 levels)
    if (this.updateSkillCost) {
        this.updateSkillCost();
    }

    // Exponential XP curve - slows down significantly at level 40
    let multiplier;
    if (this.level < 21) {
        multiplier = 1.27;   // Levels 1-20: UNCHANGED
    } else if (this.level < 46) {
        multiplier = 1.121;  // Levels 21-45
    } else if (this.level < 71) {
        multiplier = 1.101;  // Levels 46-70
    } else {
        multiplier = 1.074;  // Levels 71-100
    }
    this.maxXp = Math.floor(this.maxXp * multiplier);

    // Log level up
    if (window.game) {
        window.game.addLog(`${this.name} reached level ${this.level}! (+1 skill point)`, 'heal');
    }
}
        }

class Tank extends Character {
    constructor() {
        super('Tank', 'Tank', 1, 100, 50, 5, 10, 0.8);
        this.skillName = 'Taunt';
        this.baseManaSkillCost = 15;
        this.skillCost = 15;
        this.maxCooldown = 14;
        this.tauntActive = false;
        this.tauntTimer = 0;
        this.tauntDefenseBonus = 10; // Base +10 flat defense
    }

    updateSkillCost() {
        // Mana cost scales +5 every 5 levels
        const costIncrease = Math.floor(this.level / 5) * 5;
        this.skillCost = this.baseManaSkillCost + costIncrease;
    }

    useSkill(target) {
        this.updateSkillCost();
        if (this.cooldown === 0 && this.mana >= this.skillCost) {
            this.mana -= this.skillCost;
            this.cooldown = this.maxCooldown;
            this.tauntActive = true;
            this.tauntTimer = 300; // 5 seconds at 60fps

            // Calculate defense bonus: +10 flat + percentage of current defense
            const baseDefense = this.getTotalDefense();
            let defensePercent = 0.02; // Base 2%

            // Check for taunt rune to increase percentage
            // FIX: Use this.className.toLowerCase() instead of hardcoded party order
            if (window.game) {
                const charKey = this.className.toLowerCase();
                const equippedRunes = window.game.equippedRunes[charKey];

                if (equippedRunes) {
                    for (let i = 0; i < equippedRunes.length; i++) {
                        const rune = equippedRunes[i];
                        if (rune && rune.runeType === 'taunt') {
                            // +4% per tier (2% base + 4% per tier)
                            // Tier 1: 6%, Tier 2: 10%, Tier 3: 14%, Tier 4: 18%, Tier 5: 22%
                            defensePercent = 0.02 + (rune.tier * 0.04);
                            break;
                        }
                    }
                }
            }

            this.tauntDefenseBonus = 10 + Math.floor(baseDefense * defensePercent);
            this.tauntDefensePercent = defensePercent; // Store for display

            // TAUNT ALL ENEMIES - make them target the tank
            if (window.game && window.game.enemies) {
                window.game.enemies.forEach(enemy => {
                    if (enemy.isAlive) {
                        enemy.currentTarget = this;
                        enemy.isTaunted = true;
                        enemy.tauntTimer = 300; // 5 seconds
                    }
                });
                const percentDisplay = Math.round(defensePercent * 100);
                window.game.addLog(`${this.name} taunts all enemies! (+${this.tauntDefenseBonus} DEF [+10 + ${percentDisplay}%] for 5s)`, 'heal');
            }

            return 0; // Taunt doesn't deal damage
        }
        return 0;
    }
}

        // In class Rogue (around line 1960)
class Rogue extends Character {
    constructor() {
        super('Rogue', 'Rogue', 1, 80, 60, 8, 5, 1.5);
        this.skillName = 'Double Strike';
        this.baseManaSkillCost = 15;
        this.skillCost = 15;
        this.maxCooldown = 6;
    }

    updateSkillCost() {
        // Mana cost scales +5 every 5 levels
        const costIncrease = Math.floor(this.level / 5) * 5;
        this.skillCost = this.baseManaSkillCost + costIncrease;
    }

    useSkill(target) {
        this.updateSkillCost();
        if (this.cooldown === 0 && this.mana >= this.skillCost) {
            this.mana -= this.skillCost;
            this.cooldown = this.maxCooldown;
            return this.getTotalAttack() * 1.5;
        }
        return 0;
    }
}

// In class Mage (around line 1970)
class Mage extends Character {
    constructor() {
                super('Mage', 'Mage', 1, 70, 100, 10, 3, 0.9);
                this.skillName = 'Fireball';
                this.baseManaSkillCost = 20;
                this.skillCost = 20;
                this.maxCooldown = 6;
            }

            updateSkillCost() {
                // Mana cost scales +5 every 5 levels
                const costIncrease = Math.floor(this.level / 5) * 5;
                this.skillCost = this.baseManaSkillCost + costIncrease;
            }

            useSkill(targets) {
                this.updateSkillCost();
                if (this.cooldown === 0 && this.mana >= this.skillCost) {
                    this.mana -= this.skillCost;
                    this.cooldown = this.maxCooldown;
                    return this.getTotalAttack() * 0.8; // AOE damage - balanced to 80%
                }
                return 0;
            }
        }

class Healer extends Character {
    constructor() {
        super('Healer', 'Healer', 1, 75, 80, 4, 5, 1.0);
        this.skillName = 'Heal';
        this.baseManaSkillCost = 20;
        this.skillCost = 20;
        this.maxCooldown = 8;
        this.manaRegen = 4; // CHANGE FROM 20 TO 4
    }

    updateSkillCost() {
        // Mana cost scales +5 every 5 levels
        const costIncrease = Math.floor(this.level / 5) * 5;
        this.skillCost = this.baseManaSkillCost + costIncrease;
    }

    useSkill(target) {
        this.updateSkillCost();
        if (this.cooldown === 0 && this.mana >= this.skillCost) {
            this.mana -= this.skillCost;
            this.cooldown = this.maxCooldown;
            // New Healing Formula: 5% of target's max HP + (Bonus Mana √ó 0.4) + 10 flat
            // Bonus Mana = Total Mana - Base Mana (80 for Healer)
            const baseMana = 80;
            const bonusMana = Math.max(0, this.maxMana - baseMana);

            // Get heal rune scaling if equipped
            let percentScaling = 0.05; // Base 5%
            let manaScaling = 0.4; // Base 0.4

            // Check for equipped heal rune
            // FIX: Use this.className.toLowerCase() instead of hardcoded party order
            if (window.game) {
                const charKey = this.className.toLowerCase();
                const equippedRunes = window.game.equippedRunes[charKey];

                if (equippedRunes) {
                    for (let i = 0; i < equippedRunes.length; i++) {
                        const rune = equippedRunes[i];
                        if (rune && rune.runeType === 'heal') {
                            // Apply tier-based scaling
                            percentScaling = 0.05 * (1 + (rune.tier * 0.15)); // +15% effectiveness per tier
                            manaScaling = 0.4 + (rune.tier * 0.1); // +0.1 per tier
                            break; // Only use first heal rune found
                        }
                    }
                }
            }

            return (target.maxHp * percentScaling) + (bonusMana * manaScaling) + 10;
        }
        return 0;
    }
}

// ARCHER CLASS - NEW
class Archer extends Character {
    constructor() {
        super('Archer', 'Archer', 1, 85, 70, 9, 4, 1.2);
        this.skillName = 'Multi-Shot';
        this.baseManaSkillCost = 18;
        this.skillCost = 18;
        this.maxCooldown = 7;
    }

    updateSkillCost() {
        // Mana cost scales +5 every 5 levels
        const costIncrease = Math.floor(this.level / 5) * 5;
        this.skillCost = this.baseManaSkillCost + costIncrease;
    }

    useSkill(targets) {
        this.updateSkillCost();
        if (this.cooldown === 0 && this.mana >= this.skillCost) {
            this.mana -= this.skillCost;
            this.cooldown = this.maxCooldown;

            // Multi-shot: 3 arrows at 70% damage each
            let damageMultiplier = 0.7;

            // Check for multi-shot rune to increase damage
            // FIX: Use this.className.toLowerCase() instead of hardcoded party order
            if (window.game) {
                const charKey = this.className.toLowerCase();
                const equippedRunes = window.game.equippedRunes[charKey];

                if (equippedRunes) {
                    for (let i = 0; i < equippedRunes.length; i++) {
                        const rune = equippedRunes[i];
                        if (rune && rune.runeType === 'multishot') {
                            // +15% per tier
                            damageMultiplier = 0.7 + (rune.tier * 0.15);
                            break;
                        }
                    }
                }
            }

            return this.getTotalAttack() * damageMultiplier * 3; // 3 hits
        }
        return 0;
    }
}

// PALADIN CLASS - NEW
class Paladin extends Character {
    constructor() {
        super('Paladin', 'Paladin', 1, 90, 65, 6, 8, 0.95);
        this.skillName = 'Divine Shield';
        this.baseManaSkillCost = 20;
        this.skillCost = 20;
        this.maxCooldown = 10;
        this.shieldActive = false;
        this.shieldEndTime = null;
        this.shieldAmount = 0;
    }

    updateSkillCost() {
        // Mana cost scales +5 every 5 levels
        const costIncrease = Math.floor(this.level / 5) * 5;
        this.skillCost = this.baseManaSkillCost + costIncrease;
    }

    useSkill(target) {
        this.updateSkillCost();
        if (this.cooldown === 0 && this.mana >= this.skillCost) {
            this.mana -= this.skillCost;
            this.cooldown = this.maxCooldown;

            // Divine Shield: Grant shield to self and nearby allies
            let shieldStrength = 0.15; // Base 15% of max HP
            let duration = 4; // 4 seconds

            // Check for divine shield rune
            // FIX: Use this.className.toLowerCase() instead of hardcoded party order
            if (window.game) {
                const charKey = this.className.toLowerCase();
                const equippedRunes = window.game.equippedRunes[charKey];

                if (equippedRunes) {
                    for (let i = 0; i < equippedRunes.length; i++) {
                        const rune = equippedRunes[i];
                        if (rune && rune.runeType === 'divineshield') {
                            // +5% per tier
                            shieldStrength = 0.15 + (rune.tier * 0.05);
                            break;
                        }
                    }
                }

                // Apply shield to all party members
                if (window.game && window.game.party) {
                    const now = Date.now();
                    let totalShieldAmount = 0;
                    window.game.party.forEach(member => {
                        if (member.isAlive) {
                            const shieldAmount = Math.floor(member.maxHp * shieldStrength);
                            member.shieldAmount = (member.shieldAmount || 0) + shieldAmount;
                            member.shieldEndTime = now + (duration * 1000); // duration in seconds, convert to ms
                            totalShieldAmount += shieldAmount;
                        }
                    });

                    // Track total shields granted in stats
                    if (window.game.characterStats && window.game.characterStats[this.name]) {
                        window.game.characterStats[this.name].healingDone += totalShieldAmount;
                        console.log(`‚úÖ ${this.name} shield tracked: +${totalShieldAmount} to healing (Total: ${window.game.characterStats[this.name].healingDone})`);
                    } else {
                        console.warn(`‚ö†Ô∏è Failed to track ${this.name} shields - characterStats not initialized`);
                    }

                    const percentDisplay = Math.round(shieldStrength * 100);
                    window.game.addLog(`${this.name} grants ${percentDisplay}% max HP shields to all allies!`, 'heal');
                }
            }

            return 0; // Shield doesn't deal damage
        }
        return 0;
    }
}

class Enemy extends Character {
    constructor(type, dungeonLevel, dungeonTheme, isTreasureGuardian = false) {
        // Treasure Guardian - special enemy for treasure rooms
if (isTreasureGuardian) {
    const hp = dungeonLevel * 1000;
    const attack = Math.floor(7 + (dungeonLevel * 2.8));

            super(
                'Treasure Guardian',
                'Enemy',
                dungeonLevel,
                hp,
                20,
                attack,
                Math.min(Math.floor(4 + (dungeonLevel * 1.0) + (dungeonLevel * dungeonLevel * 0.005)), 140),
                0.8 // Slightly slower attack speed
            );

            this.color = '#f59e0b'; // Golden color for treasure guardians
            this.xpReward = dungeonLevel * 100; // Flat 100 XP per level
            this.goldReward = dungeonLevel * 200; // Already set in spawnEnemies, but kept here for consistency
            this.isTreasureGuardian = true;
            this.isBoss = true; // Mark as boss to guarantee loot drop
            this.isBig = true; // Set to true for 2x size rendering
            return;
        }

        // Dungeon-specific enemy pools
const everfallEnemies = {
            forest_wolf:      { hpMult: 1.0,  atkMult: 0.9,  defMult: 1.0,  atkSpd: 1.3, color: '#8b7355', archetype: 'Fast' },
            bandit_cutthroat: { hpMult: 1.1,  atkMult: 1.3,  defMult: 0.8,  atkSpd: 1.1, color: '#6b4423', archetype: 'DPS' },
            moss_boar:        { hpMult: 1.5,  atkMult: 0.7,  defMult: 1.4,  atkSpd: 0.7, color: '#6b8e23', archetype: 'Tank' },
            hollow_stag:      { hpMult: 1.0,  atkMult: 1.0,  defMult: 1.0,  atkSpd: 1.0, color: '#d2691e', archetype: 'Balanced' },
            rotting_treant:   { hpMult: 1.8,  atkMult: 0.6,  defMult: 1.6,  atkSpd: 0.6, color: '#556b2f', archetype: 'Ultra Tank' },
            briar_spider:     { hpMult: 0.7,  atkMult: 1.2,  defMult: 0.7,  atkSpd: 1.4, color: '#2f4f2f', archetype: 'Glass Cannon' },
            fallen_scout:     { hpMult: 0.8,  atkMult: 0.8,  defMult: 0.9,  atkSpd: 1.2, color: '#8fbc8f', archetype: 'Weak' },
            autumn_wisp:      { hpMult: 0.6,  atkMult: 1.4,  defMult: 0.6,  atkSpd: 1.5, color: '#ff8c00', archetype: 'Assassin' }
        };

        const stoneforgeEnemies = {
            forge_golem:      { hpMult: 2.0,  atkMult: 0.7,  defMult: 1.8,  atkSpd: 0.5, color: '#808080', archetype: 'Ultra Tank' },
            ember_sprite:     { hpMult: 0.6,  atkMult: 1.5,  defMult: 0.6,  atkSpd: 1.6, color: '#ff4500', archetype: 'Assassin' },
            tunnel_rat:       { hpMult: 0.7,  atkMult: 1.0,  defMult: 0.8,  atkSpd: 1.4, color: '#696969', archetype: 'Fast Weak' },
            quarry_brute:     { hpMult: 1.5,  atkMult: 1.2,  defMult: 1.3,  atkSpd: 0.7, color: '#8b4513', archetype: 'Heavy Hitter' },
            anvil_guard:      { hpMult: 1.7,  atkMult: 0.8,  defMult: 1.6,  atkSpd: 0.6, color: '#708090', archetype: 'Defender' },
            smelter_imp:      { hpMult: 0.9,  atkMult: 1.1,  defMult: 0.9,  atkSpd: 1.2, color: '#dc143c', archetype: 'Balanced DPS' },
            oreback_beetle:   { hpMult: 1.3,  atkMult: 0.7,  defMult: 1.5,  atkSpd: 0.8, color: '#a0522d', archetype: 'Tank' },
            molten_slime:     { hpMult: 1.0,  atkMult: 0.9,  defMult: 1.0,  atkSpd: 0.9, color: '#ff6347', archetype: 'Balanced' }
        };

        const umbralEnemies = {
            shade:            { hpMult: 0.8,  atkMult: 1.1,  defMult: 0.8,  atkSpd: 1.3, color: '#8b7bc8', archetype: 'Fast' },
            gloomling:        { hpMult: 1.0,  atkMult: 0.9,  defMult: 1.1,  atkSpd: 1.1, color: '#9d8cd4', archetype: 'Defensive' },
            night_stalker:    { hpMult: 1.2,  atkMult: 1.3,  defMult: 0.9,  atkSpd: 1.2, color: '#a855f7', archetype: 'DPS' },
            void_mite:        { hpMult: 0.6,  atkMult: 0.8,  defMult: 0.6,  atkSpd: 1.5, color: '#7c6baa', archetype: 'Swarm' },
            abyssal_leech:    { hpMult: 1.1,  atkMult: 1.0,  defMult: 1.2,  atkSpd: 1.0, color: '#b084cc', archetype: 'Balanced Tank' },
            umbral_wisp:      { hpMult: 0.7,  atkMult: 1.4,  defMult: 0.6,  atkSpd: 1.4, color: '#c4b5fd', archetype: 'Glass Cannon' },
            dread_bat:        { hpMult: 0.9,  atkMult: 1.1,  defMult: 0.8,  atkSpd: 1.3, color: '#a78bfa', archetype: 'Fast DPS' },
            hollow_cultist:   { hpMult: 1.4,  atkMult: 0.9,  defMult: 1.4,  atkSpd: 0.9, color: '#9f7aea', archetype: 'Tank' }
        };

        // ENDLESS BLESSINGS - EPIC LARGE MONSTERS (Treasure Guardian Scale)
        const endlessEnemies = {
            titan_colossus:        { hpMult: 2.2,  atkMult: 1.1,  defMult: 1.9,  atkSpd: 0.6, color: '#4a5568', archetype: 'Ultra Tank' },
            infernal_behemoth:     { hpMult: 1.8,  atkMult: 1.4,  defMult: 1.3,  atkSpd: 0.8, color: '#dc2626', archetype: 'Heavy Hitter' },
            frost_leviathan:       { hpMult: 2.0,  atkMult: 1.2,  defMult: 1.6,  atkSpd: 0.7, color: '#3b82f6', archetype: 'Ice Tank' },
            chaos_juggernaut:      { hpMult: 1.9,  atkMult: 1.3,  defMult: 1.5,  atkSpd: 0.7, color: '#a855f7', archetype: 'Chaos Warrior' },
            void_dreadnought:      { hpMult: 2.1,  atkMult: 1.0,  defMult: 1.8,  atkSpd: 0.6, color: '#1e1b4b', archetype: 'Void Tank' },
            storm_ravager:         { hpMult: 1.7,  atkMult: 1.5,  defMult: 1.2,  atkSpd: 0.9, color: '#fbbf24', archetype: 'Storm DPS' },
            plague_abomination:    { hpMult: 2.0,  atkMult: 1.1,  defMult: 1.7,  atkSpd: 0.6, color: '#16a34a', archetype: 'Plague Tank' },
            crimson_tyrant:        { hpMult: 1.8,  atkMult: 1.4,  defMult: 1.4,  atkSpd: 0.8, color: '#991b1b', archetype: 'Blood Lord' },
            arcane_devastator:     { hpMult: 1.6,  atkMult: 1.6,  defMult: 1.1,  atkSpd: 1.0, color: '#8b5cf6', archetype: 'Arcane Nuker' },
            shadow_overlord:       { hpMult: 1.9,  atkMult: 1.3,  defMult: 1.5,  atkSpd: 0.8, color: '#312e81', archetype: 'Shadow Lord' },
            molten_destroyer:      { hpMult: 2.0,  atkMult: 1.3,  defMult: 1.6,  atkSpd: 0.7, color: '#f97316', archetype: 'Molten Titan' },
            crystal_sentinel:      { hpMult: 2.2,  atkMult: 0.9,  defMult: 2.0,  atkSpd: 0.5, color: '#06b6d4', archetype: 'Crystal Fortress' }
        };

        // Select appropriate enemy pool based on dungeon
        let enemyPool;
        if (dungeonTheme === 'everfall') enemyPool = everfallEnemies;
        else if (dungeonTheme === 'stoneforge') enemyPool = stoneforgeEnemies;
        else if (dungeonTheme === 'umbral') enemyPool = umbralEnemies;
        else if (dungeonTheme === 'endlessblessings') enemyPool = endlessEnemies;
        else enemyPool = everfallEnemies; // Default

        const stats = enemyPool[type];

// Safety check - if enemy type doesn't exist, use a default
if (!stats) {
    console.error(`Enemy type "${type}" not found in ${dungeonTheme} dungeon!`);
    // Use first enemy from pool as fallback
    const fallbackType = Object.keys(enemyPool)[0];
    const fallbackStats = enemyPool[fallbackType];

    super(
        `Unknown Enemy`,
        'Enemy',
        dungeonLevel,
        50,
        20,
        Math.floor(8 * (0.9 + (dungeonLevel - 1) * 0.6)),
        5,
        1.0
    );
    this.color = '#ff0000';
    this.xpReward = 10;
    this.goldReward = dungeonLevel;
    return;
}

        // Logarithmic HP scaling - heavy buff for longer fights
const hpScaling = Math.floor(50 + (dungeonLevel * 30) + (dungeonLevel * dungeonLevel * 1.2) + (Math.log(dungeonLevel + 1) * 90));

        // Gentler attack scaling for floors 1-4, then moderate ramp up
let atkScaling;
if (dungeonLevel <= 5) {
    // Floors 1-5: Keep original (UNCHANGED)
    atkScaling = Math.floor(3 + (dungeonLevel * 1.2));
} else {
    // Floor 6+: Modest ATK buff
    const adjustedLevel = dungeonLevel - 5;
    atkScaling = Math.floor(8.5 + (adjustedLevel * 1.4) + (adjustedLevel * adjustedLevel * 0.014));
}
        // Calculate base stats
        let finalHp = Math.floor(hpScaling * (stats.hpMult || 1.0));
        let finalAttack = Math.floor(atkScaling * (stats.atkMult || 1.0));

        // Theme-specific scaling modifiers
        if (dungeonTheme === 'everfall') {
            // HP-focused: Tanky but weaker offense
            finalHp *= 1.15;           // +15% HP
            finalAttack *= 0.85;       // -15% Attack
        }
        else if (dungeonTheme === 'stoneforge') {
            // Attack-focused: Hard hitters but more fragile
            finalAttack *= 1.15;       // +15% Attack
            finalHp *= 0.85;           // -15% HP
        }
        else if (dungeonTheme === 'umbral') {
            // Numbers-focused: More enemies but individually weaker
            // (Enemy count: +2-5 handled in spawn function)
            finalHp *= 0.75;           // -25% HP
            finalAttack *= 0.75;       // -25% Attack
        }

        super(
    type.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' '),
    'Enemy',
    dungeonLevel,
    Math.floor(finalHp),
    20, // Mana doesn't matter for enemies
    Math.floor(finalAttack),
    Math.min(Math.floor((4 + (dungeonLevel * 1.0) + (dungeonLevel * dungeonLevel * 0.005)) * (stats.defMult || 1.0)), 200),
    stats.atkSpd
);

        this.color = stats.color;
        this.xpReward = Math.floor(this.maxHp / 10);
        this.goldReward = dungeonLevel;
    }
}

class Boss extends Character {
    constructor(floor, bossType, dungeonTheme) {
        // Boss stats by dungeon
        const bossStats = {
            everfall: {
                red_stag:     { hp: 180, atk: 16, def: 8,  atkSpd: 0.9, color: '#8b4513' },
                elder_treant: { hp: 250, atk: 12, def: 14, atkSpd: 0.5, color: '#2f4f2f' }
            },
            stoneforge: {
                foundry_master:  { hp: 200, atk: 18, def: 10, atkSpd: 0.7, color: '#ff4500' },
                colossus_of_iron: { hp: 300, atk: 20, def: 16, atkSpd: 0.4, color: '#708090' }
            },
            umbral: {
                night_herald: { hp: 160, atk: 22, def: 6,  atkSpd: 1.1, color: '#4b0082' },
                maw_of_deep:  { hp: 220, atk: 19, def: 11, atkSpd: 0.8, color: '#191970' }
            }
        };

        // Get boss stats
        const stats = bossStats[dungeonTheme]?.[bossType] || { hp: 200, atk: 18, def: 10, atkSpd: 0.7, color: '#ff0000' };

        // Boss HP is 6x common enemy HP (using same logarithmic formula)
const hpScaling = Math.floor((50 + (floor * 30) + (floor * floor * 1.2) + (Math.log(floor + 1) * 90)) * 6);

        // Boss attack scaling - slower growth until floor 50, then aggressive
let atkScaling;
if (floor <= 50) {
    // Floors 1-50: Modest buff
    atkScaling = Math.floor(10 + (floor * 1.8) + (floor * floor * 0.010));
} else {
    // Floor 50+: Modest endgame buff
    atkScaling = Math.floor(120 + (floor - 50) * 3.0);
}

        super(
    bossType.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' '),
    'Boss',
    floor,
    hpScaling,
    100,
    atkScaling,
    Math.min(Math.floor((4 + (floor * 1.0) + (floor * floor * 0.005)) * 1.5), 200), // Boss defense caps at 200 at floor 90
    stats.atkSpd
);

        this.color = stats.color;
        this.xpReward = Math.floor(this.maxHp / 10);
        this.goldReward = floor * 10;
        this.isBoss = true;
        this.isBig = true; // Make bosses render 2x larger
        this.renderScale = 2.0; // Explicit 2x rendering scale for floor bosses
    }
}

        class Pet {
            constructor(rarity, level = 1, dungeonType = null) {
                this.rarity = rarity;
                this.level = Math.min(level, 20); // Cap at level 20
                this.id = Date.now() + Math.random();
                this.isActive = false;
                this.dungeonType = dungeonType; // Track which dungeon this pet is from

                // Pet types by dungeon
                const petTypes = {
                    everfall: {
                        common: [
                            { name: 'Plumee', emoji: 'ü™∂', bonus: 'hp', base: 10, upgrade: 5, image: 'Kin/Air/plumee.png' },
                            { name: 'Tuffit', emoji: 'üêøÔ∏è', bonus: 'dodge', base: 1, upgrade: 1, image: 'Kin/Air/tuffit.png' },
                            { name: 'Zeffi', emoji: 'üçÉ', bonus: 'defense', base: 5, upgrade: 2, image: 'Kin/Air/zeffi.png' },
                            { name: 'Loofin', emoji: 'üåä', bonus: 'mana', base: 20, upgrade: 10, image: 'Kin/Air/loofin.png' },
                            { name: 'Flitta', emoji: 'ü¶ã', bonus: 'attack', base: 1, upgrade: 1, image: 'Kin/Air/flitta.png' }
                        ],
                        uncommon: [
                            { name: 'Preep', emoji: 'üê∏', bonus: 'lifesteal', base: 1, upgrade: 0.5, image: 'Kin/Air/preep.png' },
                            { name: 'Skibbin', emoji: 'ü¶é', bonus: 'hp', base: 20, upgrade: 10, image: 'Kin/Air/skibbin.png' }
                        ],
                        rare: [
                            { name: 'Fandrel', emoji: 'ü¶ä', bonus: 'dodge', base: 3, upgrade: 1, image: 'Kin/Air/fandrel.png' },
                            { name: 'Yuralon', emoji: 'ü¶å', bonus: 'attack', base: 10, upgrade: 2, image: 'Kin/Air/yuralon.png' },
                            { name: 'Zenth', emoji: 'üê∫', bonus: 'manaRegen', base: 2, upgrade: 2, image: 'Kin/Air/zenth.png' }
                        ],
                        epic: [
                            { name: 'Arvent', emoji: 'ü¶Ö', bonus: 'cdr', base: 5, upgrade: 1, image: 'Kin/Air/arvent.png' },
                            { name: 'Quist', emoji: 'ü¶â', bonus: 'critDamage', base: 5, upgrade: 2, image: 'Kin/Air/quist.png' },
                            { name: 'Whisbit', emoji: 'üêª', bonus: 'defense', base: 20, upgrade: 10, image: 'Kin/Air/whisbit.png' }
                        ],
                        legendary: [
                            { name: 'Siroth', emoji: 'ü¶Å', bonus: 'attack', base: 25, upgrade: 10, image: 'Kin/Air/siroth.png' }
                        ]
                    },
                    stoneforge: {
                        common: [
                            { name: 'Crimbee', emoji: 'üêù', bonus: 'attack', base: 1, upgrade: 1, image: 'Kin/Fire/crimbee.png' },
                            { name: 'Pikkit', emoji: 'ü™®', bonus: 'hp', base: 10, upgrade: 5, image: 'Kin/Fire/pikkit.png' },
                            { name: 'Gritbun', emoji: 'üêá', bonus: 'dodge', base: 1, upgrade: 1, image: 'Kin/Fire/gritbun.png' },
                            { name: 'Fennix', emoji: 'ü¶ä', bonus: 'defense', base: 5, upgrade: 2, image: 'Kin/Fire/fennix.png' }
                        ],
                        uncommon: [
                            { name: 'Varnowl', emoji: 'ü¶â', bonus: 'dodge', base: 1, upgrade: 0.5, image: 'Kin/Fire/varnowl.png' },
                            { name: 'Bristlepup', emoji: 'üêï', bonus: 'attack', base: 10, upgrade: 2, image: 'Kin/Fire/bristlepup.png' }
                        ],
                        rare: [
                            { name: 'Ignishade', emoji: 'üî•', bonus: 'critDamage', base: 5, upgrade: 2, image: 'Kin/Fire/ignishade.png' },
                            { name: 'Wiskit', emoji: 'üêøÔ∏è', bonus: 'dodge', base: 3, upgrade: 1, image: 'Kin/Fire/wiskit.png' },
                            { name: 'Quenra', emoji: 'ü¶î', bonus: 'defense', base: 10, upgrade: 2, image: 'Kin/Fire/quenra.png' },
                            { name: 'Cindor', emoji: 'üêª', bonus: 'hp', base: 20, upgrade: 10, image: 'Kin/Fire/cindor.png' },
                            { name: 'Solmere', emoji: '‚òÄÔ∏è', bonus: 'attack', base: 10, upgrade: 2, image: 'Kin/Fire/solmere.png' }
                        ],
                        epic: [
                            { name: 'Moltara', emoji: 'üåã', bonus: 'defense', base: 20, upgrade: 10, image: 'Kin/Fire/moltara.png' },
                            { name: 'Braxen', emoji: 'ü¶¨', bonus: 'hp', base: 20, upgrade: 10, image: 'Kin/Fire/braxen.png' }
                        ],
                        legendary: [
                            { name: 'Ashkara', emoji: 'üêâ', bonus: 'attack', base: 25, upgrade: 10, image: 'Kin/Fire/ashkara.png' }
                        ]
                    },
                    umbral: {
                        common: [
                            { name: 'Pepple', emoji: 'üåë', bonus: 'hp', base: 10, upgrade: 5, image: 'Kin/Water/pepple.png' }
                        ],
                        uncommon: [],
                        rare: [
                            { name: 'Nymbark', emoji: 'üåô', bonus: 'dodge', base: 3, upgrade: 1, image: 'Kin/Water/nymbark.png' }
                        ],
                        epic: [
                            { name: 'Moondra', emoji: 'üå†', bonus: 'mana', base: 20, upgrade: 10, image: 'Kin/Water/moondra.png' },
                            { name: 'Typharos', emoji: 'üëÅÔ∏è', bonus: 'attack', base: 20, upgrade: 10, image: 'Kin/Water/typharos.png' }
                        ],
                        legendary: []
                    }
                };

                // Select pet pool based on dungeon type, fallback to everfall
                const dungeonPool = petTypes[dungeonType] || petTypes.everfall;
                const typePool = dungeonPool[rarity] || [];

                // If pool is empty for this rarity/dungeon combo, use everfall as fallback
                const finalPool = typePool.length > 0 ? typePool : petTypes.everfall[rarity];
                const chosen = finalPool[Math.floor(Math.random() * finalPool.length)];

                this.name = chosen.name;
                this.emoji = chosen.emoji;
                this.bonusType = chosen.bonus;
                this.baseValue = chosen.base;
                this.upgradeValue = chosen.upgrade;
                this.image = chosen.image || 'Kin/Earth/chundra.png'; // Fallback image

                // Fixed upgrade costs: 50k, 200k, 500k, 1m, 2m, 5m, 10m, 20m, 30m, 40m, 50m, then 50m per level
                this.upgradeCosts = [
                    50000, 200000, 500000, 1000000, 2000000, 5000000, 10000000,
                    20000000, 30000000, 40000000, 50000000, 50000000, 50000000,
                    50000000, 50000000, 50000000, 50000000, 50000000, 50000000, 50000000
                ];
            }

            getUpgradeCost() {
                if (this.level >= 20) return null; // Max level
                return this.upgradeCosts[this.level - 1];
            }

            getCurrentBonus() {
                // Base + (upgrade * (level - 1))
                return this.baseValue + (this.upgradeValue * (this.level - 1));
            }

            getDungeonDamageBonus() {
                // Damage bonus when in matching dungeon
                const bonuses = {
                    common: 5,
                    uncommon: 6,
                    rare: 7,
                    epic: 8,
                    legendary: 10
                };
                return bonuses[this.rarity] || 0;
            }

            upgrade() {
                if (this.level < 20) {
                    this.level++;
                }
            }

            getDisplayName() {
                const rarityColors = {
                    common: '#94a3b8',
                    uncommon: '#10b981',
                    rare: '#3b82f6',
                    epic: '#a855f7',
                    legendary: '#f59e0b'
                };

                return `${this.emoji} ${this.name} (Lv.${this.level})`;
            }
        }

        class Item {
            constructor(type, rarity, level) {
                this.type = type;
                this.rarity = rarity;
                this.level = level;
                this.levelReq = Math.max(1, level - 1);

// Stat pools by slot type
                const statPools = {
    helmet: ['defense', 'hp', 'mana', 'cdr'],
    gloves: ['attack', 'attackSpeed', 'hp', 'defense'],
    belt: ['hp', 'defense', 'lifesteal', 'hpRegen'],
    chest: ['defense', 'hp', 'mana', 'dodgeChance'],
    boots: ['attackSpeed', 'hp', 'defense', 'dodgeChance'],
    amulet: ['attack', 'hp', 'critDamage', 'manaRegen'],
    ring: ['attack', 'attackSpeed', 'critChance', 'critDamage'],
    wand: ['attack', 'manaRegen', 'critChance', 'cdr'],
    dagger: ['attack', 'attackSpeed', 'critChance', 'lifesteal'],
    greatsword: ['attack', 'hp', 'defense', 'lifesteal'],
    staff: ['attack', 'mana', 'manaRegen', 'cdr'],
    bow: ['attack', 'attackSpeed', 'critChance', 'critDamage'],
    warhammer: ['attack', 'hp', 'mana', 'lifesteal']
};

                // Number of stats based on rarity
const statCount = {
    common: 1,
    uncommon: 2,
    rare: 3,
    epic: 4,
    legendary: 4,
    mythic: 4
};

// Stat value ranges (base values that scale with level)
                // Lower bases and slower scaling for longer progression
                // Weapon-specific ranges will override these defaults
                const statRanges = {
    // Core stats - slower growth
    attack: { min: 0.5, max: 3 },
    hp: { min: 4, max: 12.5 },
    mana: { min: 2.5, max: 7.5 },
    defense: { min: 1, max: 4 },

    // Secondary stats - moderate growth
    attackSpeed: { min: 0.025, max: 0.09 },
    critChance: { min: 0.5, max: 3 },

    // Late-game stats - slow growth
    critDamage: { min: 2, max: 8 },
    dodgeChance: { min: 1, max: 3 },
    lifesteal: { min: 0.5, max: 2 },
    cdr: { min: 0.5, max: 3 },

    // Regen stats - flat values (stat √∑ 2 = regen per 3 seconds)
    hpRegen: { min: 2.5, max: 15 },         // 1.25-7.5 HP per 3 seconds
    manaRegen: { min: 5, max: 25 }        // 2.5-12.5 mana per 3 seconds
};

                // Get appropriate stat pool
                let pool = statPools[type] || statPools.ring;

                // Select random stats from pool - only pick stats that have valid ranges
                const numStats = statCount[rarity];
                const validPool = pool.filter(stat => statRanges[stat]);

                // Shuffle and take the required number
                const shuffled = [...validPool].sort(() => Math.random() - 0.5);
                const selectedStats = shuffled.slice(0, Math.min(numStats, validPool.length));

                // If we still need more stats, allow duplicates from valid pool
                while (selectedStats.length < numStats && validPool.length > 0) {
                    const randomStat = validPool[Math.floor(Math.random() * validPool.length)];
                    if (!selectedStats.includes(randomStat)) {
                        selectedStats.push(randomStat);
                    }
                }

                // Assign stat values
selectedStats.forEach(stat => {
    let range = statRanges[stat];

    // Weapon-specific stat range overrides - ALL weapons get attack bonuses
    if (stat === 'attack') {
        if (type === 'dagger') {
            range = { min: 1, max: 9 }; // High attack (80% bonus) - Fast assassin
        } else if (type === 'greatsword') {
            range = { min: 1, max: 7 }; // Decent attack (40% bonus) - Tank weapon
        } else if (type === 'wand') {
            range = { min: 1, max: 8 }; // Good attack (60% bonus) - AOE caster
        } else if (type === 'staff') {
            range = { min: 1, max: 7 }; // Decent attack (40% bonus) - Healer weapon
        } else if (type === 'bow') {
            range = { min: 1, max: 8.5 }; // Good attack (70% bonus) - Ranged DPS
        } else if (type === 'warhammer') {
            range = { min: 1, max: 7.5 }; // Good attack (50% bonus) - Holy warrior
        }
    }

    // Keep existing special stat bonuses
    if (type === 'greatsword' && stat === 'hp') {
        range = { min: 8, max: 40 }; // +60% hp ceiling
    }
    if (type === 'warhammer' && stat === 'hp') {
        range = { min: 7, max: 35 }; // +40% hp ceiling - Slightly less tanky than greatsword
    }
    if (type === 'staff' && stat === 'mana') {
        range = { min: 5, max: 25 }; // +67% mana ceiling
    }
    if (type === 'warhammer' && stat === 'mana') {
        range = { min: 3.5, max: 12.5 }; // +25% mana ceiling - Helps with keystones
    }

    // Mana regen nerf - 60% reduction for staffs, wands, and amulets
    if (stat === 'manaRegen' && (type === 'staff' || type === 'wand' || type === 'amulet')) {
        range = { min: 4, max: 20 }; // 60% nerf from 10-50
    }

    // EXPONENTIAL SCALING: Level is now the DOMINANT factor
    // 1.018^level = ~1.8% compound growth per level
    // 59 level difference = 2.87x more powerful (not 1.6x)
    const levelScaling = Math.pow(1.018, level);

    if (rarity === 'legendary') {
        // Legendary = perfect max values
        this[stat] = Math.round(range.max * levelScaling * 100) / 100;
    } else if (rarity === 'mythic') {
        // Mythic = perfect max values (200% will be applied to one stat after loop)
        this[stat] = Math.round(range.max * levelScaling * 100) / 100;
    } else {
        // Random value in range with rarity-based minimum guarantees
        const rangeSize = range.max - range.min;

        // Rarity guarantees - minimum % of max roll
        let minRollPercent = 0; // Common/Uncommon: 0-100% of range
        if (rarity === 'rare') {
            minRollPercent = 0.50; // Rare: 50-100% of range
        } else if (rarity === 'epic') {
            minRollPercent = 0.70; // Epic: 70-100% of range
        }

        const guaranteedMin = range.min + (rangeSize * minRollPercent);
        const guaranteedRange = range.max - guaranteedMin;
        const value = guaranteedMin + Math.random() * guaranteedRange;

        this[stat] = Math.round(value * levelScaling * 100) / 100;
    }
});

// Mythic: Double random stat(s) based on weighted chances (200% instead of 100%)
if (rarity === 'mythic' && selectedStats.length > 0) {
    const roll = Math.random() * 100;
    let numMythicStats = 1; // Default: 1 stat at 200%

    if (roll < 1) {
        // 1% chance: ALL 4 stats at 200%
        numMythicStats = 4;
    } else if (roll < 5) {
        // 4% chance: 3 stats at 200%
        numMythicStats = 3;
    } else if (roll < 15) {
        // 10% chance: 2 stats at 200%
        numMythicStats = 2;
    }
    // else 85% chance: 1 stat at 200%

    // Randomly select which stats to make mythic
    const shuffledStats = [...selectedStats].sort(() => Math.random() - 0.5);
    const mythicStats = shuffledStats.slice(0, numMythicStats);

    // Double the selected stats
    mythicStats.forEach(stat => {
        this[stat] = Math.round(this[stat] * 2 * 100) / 100;
    });

    // Track which stats are mythic (for tooltip display)
    if (mythicStats.length === 1) {
        this.mythicStat = mythicStats[0]; // Single stat - keep old property for compatibility
    } else {
        this.mythicStats = mythicStats; // Multiple stats - use array
    }
}



                // Set name: "Lvl X [Rarity] [Slot]"
                const slotNames = {
                    helmet: 'Helmet',
                    gloves: 'Gloves',
                    belt: 'Belt',
                    chest: 'Chestplate',
                    boots: 'Boots',
                    amulet: 'Amulet',
                    ring: 'Ring',
                    wand: 'Wand',
                    dagger: 'Dagger',
                    greatsword: 'Greatsword',
                    staff: 'Staff',
                    bow: 'Bow',
                    warhammer: 'Warhammer',
                    weapon: 'Weapon'
                };

                const rarityNames = {
    common: 'Common',
    uncommon: 'Uncommon',
    rare: 'Rare',
    epic: 'Epic',
    legendary: 'Legendary',
    mythic: 'Mythic'
};

// Check if this is a Perfect Mythic (all 4 stats at 200%)
let rarityDisplayName = rarityNames[rarity];
if (rarity === 'mythic' && this.mythicStats && this.mythicStats.length === 4) {
    rarityDisplayName = 'Perfect Mythic';
    this.isPerfectMythic = true; // Flag for special handling
}

this.name = `Lvl ${level} ${rarityDisplayName} ${slotNames[type]}`;

                this.name = `Lvl ${level} ${rarityNames[rarity]} ${slotNames[type]}`;

                // Normalize weapon type to 'weapon' for equipment slot
                if (['wand', 'dagger', 'greatsword', 'staff', 'bow', 'warhammer'].includes(type)) {
                    this.type = 'weapon';
                    this.weaponType = type;
                }
            }

getStatsDisplay() {
                const stats = [];
                if (this.attack) stats.push(`ATK +${this.attack}`);
                if (this.attackSpeed) stats.push(`ATK SPD +${this.attackSpeed}`);
                if (this.hp) stats.push(`HP +${this.hp}`);
                if (this.mana) stats.push(`MANA +${this.mana}`);
                if (this.defense) stats.push(`DEF +${this.defense}`);
                if (this.critChance) stats.push(`CRIT +${this.critChance}%`);
                if (this.critDamage) stats.push(`CRIT DMG +${this.critDamage}%`);
                if (this.dodgeChance) stats.push(`DODGE +${this.dodgeChance}%`);
                if (this.lifesteal) stats.push(`LIFESTEAL +${this.lifesteal}%`);
                if (this.hpRegen) stats.push(`HP REGEN +${this.hpRegen}`);
if (this.manaRegen) stats.push(`MANA REGEN +${this.manaRegen}`);
                if (this.cdr) stats.push(`CDR +${this.cdr}%`);

                // Add blessed status
                if (this.blessed) {
                    stats.push(`‚ú® BLESSED`);
                }

                return stats.join(', ');
            }
        }

        window.Item = Item;

        // Keystone Item Class (duplicate removed)
        class KeystoneItem {
            constructor(type, rarity, level) {
                this.type = type; // 'tank', 'healer', 'mage', 'rogue'
                this.rarity = rarity;
                this.level = level;

                // Randomly select one of 3 keystones per class
                const keystoneVariants = {
                    tank: [
                        {
                            internalName: 'wardens-aegis',
                            name: "Warden's Aegis",
                            abilityName: 'Invulnerability',
                            description: 'Become immune to all damage for 3 seconds',
                            cooldown: 55,
                            manaCost: 40
                        },
                        {
                            internalName: 'berserkers-pact',
                            name: "Berserker's Pact",
                            abilityName: 'Blood Frenzy',
                            description: 'Sacrifice 30% current HP to gain +100% attack speed and +50% lifesteal for 8 seconds',
                            cooldown: 40,
                            manaCost: 40
                        },
                        {
                            internalName: 'earthshakers-resolve',
                            name: "Earthshaker's Resolve",
                            abilityName: 'Seismic Slam',
                            description: 'Slam the ground, stunning all enemies for 2.5 seconds and reducing their attack by 40% for 5 seconds',
                            cooldown: 45,
                            manaCost: 40
                        }
                    ],
                    healer: [
                        {
                            internalName: 'arcanists-conduit',
                            name: "Arcanist's Conduit",
                            abilityName: 'Mana Feed',
                            description: 'Restore 75% max mana to lowest mana ally',
                            cooldown: 25,
                            manaCost: 40
                        },
                        {
                            internalName: 'martyrs-blessing',
                            name: "Martyr's Blessing",
                            abilityName: 'Sacrificial Surge',
                            description: 'Convert 40% of your current HP into healing, distributing it equally among all allies (heals for 200% of HP sacrificed)',
                            cooldown: 30,
                            manaCost: 40
                        },
                        {
                            internalName: 'phoenix-heart',
                            name: "Phoenix Heart",
                            abilityName: 'Resurrection',
                            description: 'Revive the most recently fallen ally with 40% HP and 30% mana',
                            cooldown: 45,
                            manaCost: 40
                        }
                    ],
                    mage: [
                        {
                            internalName: 'winters-wrath',
                            name: "Winter's Wrath",
                            abilityName: 'Blizzard',
                            description: 'Freeze all enemies for 2s + deal 120% attack damage',
                            cooldown: 40,
                            manaCost: 40
                        },
                        {
                            internalName: 'voidwalkers-gift',
                            name: "Voidwalker's Gift",
                            abilityName: 'Void Surge',
                            description: 'Next 5 attacks ignore 100% of enemy defense and have +50% crit chance (costs 15% max mana per attack)',
                            cooldown: 35,
                            manaCost: 40
                        },
                        {
                            internalName: 'timeweavers-paradox',
                            name: "Timeweaver's Paradox",
                            abilityName: 'Temporal Rewind',
                            description: 'Reset all party cooldowns and restore 25% HP to all allies',
                            cooldown: 85,
                            manaCost: 40
                        }
                    ],
                    rogue: [
                        {
                            internalName: 'assassins-mark',
                            name: "Assassin's Mark",
                            abilityName: 'Cripple',
                            description: 'Deal 150% attack damage + reduce enemy defense by 20 for 5s',
                            cooldown: 25,
                            manaCost: 0
                        },
                        {
                            internalName: 'shadow-dancer',
                            name: "Shadow Dancer",
                            abilityName: 'Shadow Step',
                            description: 'Next 3 attacks deal +120% damage and heal you for 50% of damage dealt',
                            cooldown: 30,
                            manaCost: 0
                        },
                        {
                            internalName: 'serpents-venom',
                            name: "Serpent's Venom",
                            abilityName: 'Toxic Cascade',
                            description: 'Your attacks poison the target for 10s, dealing 40% of your attack as damage per second (stacks 3x, -15% enemy attack speed)',
                            cooldown: 20,
                            manaCost: 0
                        }
                    ],
                    archer: [
                        {
                            internalName: 'hawkeyes-precision',
                            name: "Hawkeye's Precision",
                            abilityName: 'Perfect Shot',
                            description: 'Fire a perfect shot dealing 250% attack damage with 100% crit chance, ignores defense',
                            cooldown: 30,
                            manaCost: 0
                        },
                        {
                            internalName: 'rapid-quiver',
                            name: "Rapid Quiver",
                            abilityName: 'Arrow Storm',
                            description: 'Fire 8 rapid arrows each dealing 60% attack damage over 2 seconds',
                            cooldown: 35,
                            manaCost: 0
                        },
                        {
                            internalName: 'hunters-focus',
                            name: "Hunter's Focus",
                            abilityName: 'Marked for Death',
                            description: 'Mark an enemy for 6s, all attacks against it deal +80% damage and heal you for 30% of damage dealt',
                            cooldown: 28,
                            manaCost: 0
                        }
                    ],
                    paladin: [
                        {
                            internalName: 'holy-avenger',
                            name: "Holy Avenger",
                            abilityName: 'Divine Wrath',
                            description: 'Smite all enemies for 160% attack damage and heal all allies for 15% of their max HP',
                            cooldown: 38,
                            manaCost: 40
                        },
                        {
                            internalName: 'divine-guardian',
                            name: "Divine Guardian",
                            abilityName: 'Sacred Barrier',
                            description: 'Grant all allies a shield for 20% of their max HP for 6 seconds, +30% defense during shield',
                            cooldown: 42,
                            manaCost: 40
                        },
                        {
                            internalName: 'righteous-fury',
                            name: "Righteous Fury",
                            abilityName: 'Holy Fire',
                            description: 'Deal 150% attack damage to all enemies and grant all allies +35% attack speed for 5 seconds',
                            cooldown: 33,
                            manaCost: 40
                        }
                    ]
                };

                // Randomly pick one of the 3 variants for this class
                const variants = keystoneVariants[type];
                const chosenVariant = variants[Math.floor(Math.random() * variants.length)];

                this.internalName = chosenVariant.internalName;
                this.keystoneName = chosenVariant.name;
                this.ability = {
                    name: chosenVariant.abilityName,
                    description: chosenVariant.description,
                    cooldown: chosenVariant.cooldown,
                    manaCost: chosenVariant.manaCost
                };

                // ability is already set above from chosenVariant

                // Stat count based on rarity
                const statCounts = {
                    common: 1,
                    uncommon: 2,
                    rare: 3,
                    epic: 4,
                    legendary: 4
                };

                const statCount = statCounts[rarity];

                // All possible stats
                const allStats = [
                    'attack', 'attackSpeed', 'critDamage', 'critChance',
                    'defense', 'cdr', 'dodge', 'hpRegen',
                    'manaRegen', 'mana', 'hp', 'lifesteal'
                ];

                // Stat scaling per level
                const statScaling = {
                    attack: { min: 0.6, max: 1.0 },
                    attackSpeed: { min: 0.3, max: 0.5 },
                    critDamage: { min: 1.2, max: 2.0 },
                    critChance: { min: 0.3, max: 0.5 },
                    defense: { min: 0.48, max: 0.8 },
                    cdr: { min: 0.3, max: 0.5 },
                    dodge: { min: 0.24, max: 0.4 },
                    hpRegen: { min: 0.18, max: 0.3 },
                    manaRegen: { min: 0.3, max: 0.5 },
                    mana: { min: 3, max: 5 },
                    hp: { min: 3, max: 5 },
                    lifesteal: { min: 0.24, max: 0.4 }
                };

                // Randomly select stats (no duplicates)
                const shuffled = allStats.sort(() => Math.random() - 0.5);
                const selectedStats = shuffled.slice(0, statCount);

                // Assign stat values
                selectedStats.forEach(stat => {
                    const scaling = statScaling[stat];
                    let multiplier;

                    if (rarity === 'legendary') {
                        multiplier = scaling.max; // Perfect roll
                    } else {
                        // Random roll between min and max
                        multiplier = scaling.min + Math.random() * (scaling.max - scaling.min);
                    }

                    this.stats = this.stats || {};
this.stats[stat] = Math.round(multiplier * level * 100) / 100;
                });

                // Set name
                const typeNames = {
                    tank: 'üõ°Ô∏è Tank',
                    healer: 'üíä Healer',
                    mage: 'üîÆ Mage',
                    rogue: 'üó°Ô∏è Rogue'
                };

                const rarityNames = {
                    common: 'Common',
                    uncommon: 'Uncommon',
                    rare: 'Rare',
                    epic: 'Epic',
                    legendary: 'Legendary'
                };

                this.name = `Lvl ${level} ${rarityNames[rarity]} ${this.keystoneName}`;
            }

            getStatsDisplay() {
                if (!this.stats) return 'No stats';

                const statNames = {
                    attack: 'ÊîªÂáª',
                    attackSpeed: 'ÊîªÂáªÈÄüÂ∫¶',
                    critDamage: 'Êö¥Âáª‰º§ÂÆ≥',
                    critChance: 'Êö¥Âáª',
                    defense: 'Èò≤Âæ°',
                    cdr: 'CDR',
                    dodge: 'Èó™ÈÅø',
                    hpRegen: 'ÁîüÂëΩÂõûÂ§ç',
                    manaRegen: 'Ê≥ïÂäõÂõûÂ§ç',
                    mana: 'Ê≥ïÂäõ',
                    hp: 'ÁîüÂëΩÂÄº',
                    lifesteal: 'Âê∏Ë°Ä'
                };

                const percentStats = ['attackSpeed', 'critDamage', 'critChance', 'cdr', 'dodge', 'hpRegen', 'manaRegen', 'lifesteal'];

                const stats = [];
                for (const [stat, value] of Object.entries(this.stats)) {
                    const displayName = statNames[stat] || stat;
                    const suffix = percentStats.includes(stat) ? '%' : '';
                    stats.push(`${displayName} +${value}${suffix}`);
                }
                return stats.join(', ');
            }

            getSellPrice() {
                const rarityMultipliers = {
                    common: 50,
                    uncommon: 100,
                    rare: 200,
                    epic: 400,
                    legendary: 1000
                };
                return rarityMultipliers[this.rarity] * this.level;
            }
        }

        // Rune Item Class
        class RuneItem {
            constructor(tier, runeType) {
                this.tier = tier; // 1-5
                this.runeType = runeType;

                // Determine if this is an ability rune or stat rune
                const abilityRunes = ['taunt', 'heal', 'fireball', 'doublestrike', 'multishot', 'divineshield'];
                this.isAbilityRune = abilityRunes.includes(runeType);

                if (this.isAbilityRune) {
                    // Ability Rune
                    const abilityData = {
                        taunt: {
    name: 'Taunt',
    emoji: 'üõ°Ô∏è',
    baseEffectiveness: 50,
    getDescription: (bonus) => {
        const baseDef = 10;
        const newDef = baseDef + (baseDef * bonus / 100);
        return `Taunt grants +${newDef.toFixed(1)} flat defense (up from +${baseDef})`;
    }
                        },
                        heal: {
    name: 'Heal',
    emoji: 'üíä',
    baseEffectiveness: 15,
    getDescription: (bonus) => {
        const tier = bonus / 15; // 15% per tier
        const basePercent = 5;
        const newPercent = basePercent * (1 + (tier * 0.15));
        const baseManaScaling = 0.4;
        const newManaScaling = baseManaScaling + (tier * 0.1);
        return `Heals ${newPercent.toFixed(1)}% max HP + (Bonus Mana √ó ${newManaScaling.toFixed(1)}) + 10 (up from ${basePercent}% + √ó ${baseManaScaling})`;
    }
                        },
                        fireball: {
                            name: 'Fireball',
                            emoji: 'üî•',
                            baseEffectiveness: 30,
                            getDescription: (bonus) => {
                                const baseDmg = 80;
                                const newDmg = baseDmg + (baseDmg * bonus / 100);
                                return `Fireball deals ${newDmg.toFixed(0)}% attack damage AOE (up from ${baseDmg}%)`;
                            }
                        },
                        doublestrike: {
                            name: 'Double Strike',
                            emoji: '‚öîÔ∏è',
                            baseEffectiveness: 30,
                            getDescription: (bonus) => {
                                const baseDmg = 150;
                                const newDmg = baseDmg + (baseDmg * bonus / 100);
                                return `Double Strike deals ${newDmg.toFixed(0)}% attack damage (up from ${baseDmg}%)`;
                            }
                        },
                        multishot: {
                            name: 'Multi-Shot',
                            emoji: 'üèπ',
                            baseEffectiveness: 15,
                            getDescription: (bonus) => {
                                const baseDmg = 70;
                                const newDmg = baseDmg + bonus;
                                return `Multi-Shot arrows deal ${newDmg.toFixed(0)}% attack damage each (up from ${baseDmg}%) - 3 arrows`;
                            }
                        },
                        divineshield: {
                            name: 'Divine Shield',
                            emoji: 'üõ°Ô∏è',
                            baseEffectiveness: 5,
                            getDescription: (bonus) => {
                                const baseShield = 15;
                                const newShield = baseShield + bonus;
                                return `Divine Shield grants ${newShield.toFixed(0)}% max HP shields (up from ${baseShield}%)`;
                            }
                        }
                    };

                    const data = abilityData[runeType];
                    const tierNames = ['Advanced', 'Expert', 'Elite', 'Master', 'Grandmaster'];

                    this.abilityName = data.name;
                    this.emoji = data.emoji;
                    this.effectivenessBonus = data.baseEffectiveness * tier; // 30%, 60%, 100%, 150%, 200%
                    this.name = `${tierNames[tier - 1]} ${data.name} (T${tier})`;
                    this.description = data.getDescription(this.effectivenessBonus);

                } else {
                    // Stat Rune - percentage-based only
                    const statData = {
                        attack: { name: 'Attack', emoji: '‚öîÔ∏è', perTier: 4 },
                        attackspeed: { name: 'Attack Speed', emoji: '‚ö°', perTier: 1 },
                        defense: { name: 'Defense', emoji: 'üõ°Ô∏è', perTier: 4 },
                        crit: { name: 'Crit', emoji: 'üí•', perTier: 2, secondaryStat: 'critDamage', secondaryPerTier: 5 },
                        dodge: { name: 'Dodge', emoji: 'üí®', perTier: 3 },
                        lifesteal: { name: 'Lifesteal', emoji: 'ü©∏', perTier: 3 },
                        time: { name: 'Time', emoji: '‚è±Ô∏è', perTier: 3 },
                        health: { name: 'Health', emoji: '‚ù§Ô∏è', perTier: 4 },
                        mana: { name: 'Mana', emoji: 'üíô', perTier: 4 }
                    };

                    const data = statData[runeType];
                    this.emoji = data.emoji;
                    this.statName = data.name;
                    this.percentBonus = data.perTier * tier;
                    this.name = `Rune of ${data.name} (T${tier})`;

                    // Store as percentage bonus (will be applied to character's total stats)
                    this.statType = runeType;
                    if (runeType === 'crit') {
                        this.secondaryStatType = 'critDamage';
                        this.secondaryPercentBonus = data.secondaryPerTier * tier;
                        this.description = `+${this.percentBonus}% Crit Chance, +${this.secondaryPercentBonus}% Crit Damage`;
                    } else if (runeType === 'time') {
                        this.statType = 'cdr';
                        this.description = `+${this.percentBonus}% CDR`;
                    } else {
                        this.description = `+${this.percentBonus}% ${data.name}`;
                    }
                }

                // No rarity for runes
            }

            getStatsDisplay() {
                return this.description;
            }

            getDisplayName() {
                return this.name; // Just the name, no level or rarity
            }

            getSellPrice() {
                // Sell price based on tier only
                return this.tier * 200;
            }
        }


// ============================================
// MEMORY LEAK FIX: RESOURCE MANAGERS
// ============================================

class EventListenerManager {
    constructor() {
        this.listeners = [];
    }

    add(element, event, handler, options) {
        element.addEventListener(event, handler, options);
        this.listeners.push({ element, event, handler, options });
    }

    remove(element, event, handler) {
        element.removeEventListener(event, handler);
        this.listeners = this.listeners.filter(
            l => !(l.element === element && l.event === event && l.handler === handler)
        );
    }

    removeAll() {
        this.listeners.forEach(({ element, event, handler }) => {
            try {
                element.removeEventListener(event, handler);
            } catch (e) {
                // Element might be gone, that's ok
            }
        });
        this.listeners = [];
    }
}

class AnimationManager {
    constructor() {
        this.activeFrames = new Set();
    }

    request(callback) {
        const id = requestAnimationFrame(callback);
        this.activeFrames.add(id);
        return id;
    }

    cancel(id) {
        if (id) {
            cancelAnimationFrame(id);
            this.activeFrames.delete(id);
        }
    }

    cancelAll() {
        this.activeFrames.forEach(id => {
            try {
                cancelAnimationFrame(id);
            } catch (e) {}
        });
        this.activeFrames.clear();
    }
}

class TimerManager {
    constructor() {
        this.intervals = new Set();
        this.timeouts = new Set();
    }

    setInterval(callback, delay) {
        const id = setInterval(callback, delay);
        this.intervals.add(id);
        return id;
    }

    setTimeout(callback, delay) {
        const id = setTimeout(() => {
            callback();
            this.timeouts.delete(id);
        }, delay);
        this.timeouts.add(id);
        return id;
    }

    clearInterval(id) {
        if (id) {
            clearInterval(id);
            this.intervals.delete(id);
        }
    }

    clearTimeout(id) {
        if (id) {
            clearTimeout(id);
            this.timeouts.delete(id);
        }
    }

    clearAll() {
        this.intervals.forEach(id => {
            try { clearInterval(id); } catch (e) {}
        });
        this.timeouts.forEach(id => {
            try { clearTimeout(id); } catch (e) {}
        });
        this.intervals.clear();
        this.timeouts.clear();
    }
}

// ============================================

// Main game class - PART 2 CONTINUES
        class Game {
            constructor() {
                this.canvas = document.getElementById('dungeon-canvas');

                // Initialize resource managers for memory leak prevention
                this.eventManager = new EventListenerManager();
                this.animationManager = new AnimationManager();
                this.timerManager = new TimerManager();
                this.destroyed = false;
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;

                // Delta time for real-time combat
                this.lastFrameTime = performance.now();
                this.deltaTime = 0;

                this.mapCanvas = document.getElementById('map-canvas');
                this.mapCtx = this.mapCanvas.getContext('2d');

                this.lootSortBy = [];
                this.inventorySortBy = [];

                // Make game instance globally accessible for position change tracking
window.game = this;

// Skill tree integration
                this.skillTreeOpen = false;
                this.currentSkillTreeCharacter = null;
                this.skillTreeFrame = null;

                this.party = [];
                this.enemies = [];
                this.room = null;
                this.dungeonLayout = null;
                this.dungeonFloor = 1;
                this.currentDungeon = null;
                this.gold = 0;
                this.blessingCurrency = 0; // Blessing currency for endgame upgrades
                this.loot = [];
                this.inventory = [];

                // Keystone system
this.keystones = [];
this.equippedKeystones = {
    tank: null,
    healer: null,
    mage: null,
    rogue: null,
    archer: null,
    paladin: null
};
this.keystoneSlots = {
    tank: true,
    healer: true,
    mage: true,
    rogue: true,
    archer: true,
    paladin: true
};

                // Rune system
                this.runes = [];
                this.equippedRunes = {
                    tank: [null, null, null, null, null],
                    healer: [null, null, null, null, null],
                    mage: [null, null, null, null, null],
                    rogue: [null, null, null, null, null],
                    archer: [null, null, null, null, null],
                    paladin: [null, null, null, null, null]
                };
                this.runeSlots = {
                    tank: [false, false, false, false, false],
                    healer: [false, false, false, false, false],
                    mage: [false, false, false, false, false],
                    rogue: [false, false, false, false, false],
                    archer: [false, false, false, false, false],
                    paladin: [false, false, false, false, false]
                };

                // Rune Trial Keys
                this.runeTrialKeys = [];
                this.nextRuneTrialKeyId = 1;

                // Pet system - each character has their own pet slot
                this.pets = [];
                this.equippedPets = {
                    tank: null,
                    healer: null,
                    mage: null,
                    rogue: null,
                    archer: null,
                    paladin: null
                };

// Chest system
                this.playerChests = [];
                this.nextChestId = 1;
                this.successfulRuns = 0;

                // Vault Key system
                this.vaultKeys = [];
                this.nextVaultKeyId = 1;

                // Keystone system
                this.keystones = [];
                this.nextKeystoneId = 1;

                // Loot filter settings - all enabled by default
                this.lootFilter = {
                    common: true,
                    uncommon: true,
                    rare: true,
                    epic: true,
                    legendary: true,
                    minLevel: 1  // Minimum item level to keep
                };

// Dungeon loot tables
                this.dungeonLootTables = {
                    umbral: ['amulet', 'ring'],
                    everfall: ['helmet', 'gloves', 'belt', 'boots', 'chest'],
                    stoneforge: ['wand', 'dagger', 'greatsword', 'staff', 'bow', 'warhammer'],
                    vault: ['helmet', 'chest', 'gloves', 'boots', 'belt', 'amulet', 'ring', 'wand', 'dagger', 'greatsword', 'staff', 'bow', 'warhammer']
                };

                // Weapon mapping for filtering loot by party composition
                this.weaponClassMapping = {
                    'greatsword': 'Tank',
                    'staff': 'Healer',
                    'wand': 'Mage',
                    'dagger': 'Rogue',
                    'bow': 'Archer',
                    'warhammer': 'Paladin'
                };

                this.paused = false;
                this.speed = 1;
                this.inBattle = false;
                this.battleTimer = 0;
                this.movingToNextRoom = false;
                this.transitioningFloor = false;  // Prevent race conditions during floor transitions

                // Summary duration setting (in seconds)
                this.summaryDuration = 4;

                // Dungeon change cooldown
                this.lastDungeonChangeTime = 0;
                this.dungeonChangeCooldown = 30000; // 30 seconds in milliseconds

// Floor statistics tracking
this.floorStats = {
    startTime: null,
    damageDealt: 0,
    enemiesKilled: 0,
    goldEarned: 0,
    lootObtained: 0
};

// Global statistics tracking
this.globalStats = {
                    farthestFloor: 1,
                    legendariesFound: 0,
                    chestsFound: 0,
                    mythicChestsFound: 0,
                    fastestFloorTime: null,
                    totalFloorsCleared: 0,
                    totalGoldEarned: 0,
                    totalDeaths: 0
                };

// Dungeon-specific progress
this.dungeonProgress = {
    everfall: { startFloor: 1, farthestFloor: 1 },
    stoneforge: { startFloor: 1, farthestFloor: 1 },
    umbral: { startFloor: 1, farthestFloor: 1 }
};

this.offsetX = this.canvas.width / 2;
this.offsetY = this.canvas.height / 3;

// Object pooling for floating texts
this.floatingTextPool = [];
this.maxPoolSize = 20;

// Minimap debounce
this._lastMinimapUpdate = 0;

                this.init();

                // Add mouse tracking for enemy tooltips
                this.canvas.addEventListener('mousemove', (e) => this.handleCanvasMouseMove(e));
                this.canvas.addEventListener('mouseleave', () => {
                    document.getElementById('enemy-tooltip').classList.remove('show');
                });

                this.gameLoop();

                // Start helpful tip timer (60 seconds)
                this.helpfulTipTimer = setTimeout(() => {
                    this.checkAndShowHelpfulTip();
                }, 60000); // 60 seconds
            }

            checkAndShowHelpfulTip() {
                // Calculate total gear score
                const totalGearScore = this.party.reduce((total, member) => {
                    let memberGearScore = 0;
                    for (const slot in member.equipment) {
                        if (member.equipment[slot]) {
                            memberGearScore += this.calculateGearScore(member.equipment[slot]);
                        }
                    }
                    return total + memberGearScore;
                }, 0);

                // Only show if gear score is below 100
                if (totalGearScore < 100) {
                    this.showHelpfulTip();
                }
            }

            showHelpfulTip() {
    const tipHTML = `
        <div id="helpful-tip-overlay" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 5000; backdrop-filter: blur(10px); padding: 40px;">
            <img src="helpful%20tip.png" style="max-width: 90vw; max-height: 75vh; width: auto; height: auto; border-radius: 16px; box-shadow: 0 20px 80px rgba(0, 0, 0, 0.9); margin-bottom: 20px; image-rendering: -webkit-optimize-contrast; image-rendering: crisp-edges;">

            <button id="helpful-tip-ok-btn" style="padding: 8px 20px; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 6px; font-family: 'Orbitron', sans-serif; font-size: 13px; font-weight: 700; cursor: pointer; text-transform: uppercase; letter-spacing: 1px; box-shadow: 0 3px 12px rgba(16, 185, 129, 0.4); transition: all 0.3s ease; display: inline-block; width: auto;">
    Got It! üöÄ
</button>
        </div>
    `;

                const div = document.createElement('div');
                div.innerHTML = tipHTML;
                document.body.appendChild(div.firstElementChild);

                const btn = document.getElementById('helpful-tip-ok-btn');
                btn.onclick = () => {
                    document.getElementById('helpful-tip-overlay').remove();
                };

                // Add hover effect
                btn.addEventListener('mouseenter', () => {
                    btn.style.transform = 'translateY(-3px)';
                    btn.style.boxShadow = '0 8px 30px rgba(16, 185, 129, 0.6)';
                });
                btn.addEventListener('mouseleave', () => {
                    btn.style.transform = 'translateY(0)';
                    btn.style.boxShadow = '0 6px 20px rgba(16, 185, 129, 0.4)';
                });
            }

            init() {
                // Get selected party (4 characters)
                let selectedParty = ['tank', 'healer', 'mage', 'rogue']; // Default party (4 only)
                const savedParty = localStorage.getItem('selectedParty');
                if (savedParty) {
                    try {
                        const parsed = JSON.parse(savedParty);
                        if (parsed.length === 4 && parsed.every(c => c !== null)) {
                            selectedParty = parsed;
                        }
                    } catch (e) {
                        console.error('Error loading party selection:', e);
                    }
                }

                // Create party based on selected characters
                const classConstructors = {
                    'tank': Tank,
                    'healer': Healer,
                    'mage': Mage,
                    'rogue': Rogue,
                    'archer': Archer,
                    'paladin': Paladin
                };

                this.party = selectedParty.map(charClass => new classConstructors[charClass]());
                const charNames = selectedParty; // Use the party selection as character names

// Load and apply skill tree data if it exists
const savedSkillData = localStorage.getItem('skillTreeData');
if (savedSkillData) {
    try {
        const data = JSON.parse(savedSkillData);
        this.party.forEach((member, idx) => {
            const charKey = charNames[idx];
            if (data.characters && data.characters[charKey]) {
                member.skillTreeData = {
                    allocatedNodes: new Set(data.characters[charKey].allocatedNodes || [0]),
                    usedPoints: data.characters[charKey].usedPoints || 0
                };
                member.skillPoints = data.characters[charKey].availablePoints || 0;

                // Apply skill tree stats
                this.applySkillTreeStats(member);

                // Count and unlock rune slots based on allocated nodes
                let runeSlotCount = 0;
                if (data.characters[charKey].totalStats) {
                    runeSlotCount = data.characters[charKey].totalStats.runeSlots || 0;
                }

                // Update rune slots for this character
                for (let i = 0; i < 5; i++) {
                    if (i < runeSlotCount) {
                        this.runeSlots[charKey][i] = true;
                    } else {
                        this.runeSlots[charKey][i] = false;
                    }
                }

                // HP and Mana already set correctly by applySkillTreeStats()
            }
        });
    } catch (e) {
        console.error('Error loading initial skill tree data:', e);
    }
}

// Add starter chest (level 1)
this.playerChests.push({
    id: this.nextChestId++,
    level: 1,
    isMythic: false,
    openCost: CHEST_CONFIG.OPEN_COST_MULTIPLIER * 1,
    sellValue: CHEST_CONFIG.SELL_VALUE_MULTIPLIER * 1,
    sourceDungeon: 'everfall',
    foundAtFloor: 1,
    rarityOdds: { ...CHEST_CONFIG.RARITY_DISTRIBUTION }
});




                // Create sprites with formation positions
                const colorMap = {
                    'Tank': '#6b7280',
                    'Healer': '#10b981',
                    'Mage': '#52525b',
                    'Rogue': '#ef4444',
                    'Archer': '#f59e0b',
                    'Paladin': '#3b82f6'
                };

                const symbolMap = {
                    'Tank': 'üõ°',
                    'Healer': 'üíä',
                    'Mage': 'üîÆ',
                    'Rogue': 'üó°',
                    'Archer': 'üèπ',
                    'Paladin': '‚öîÔ∏è'
                };

                // Set up initial formation positions - bottom center of room
                const formations = {
                    0: {x: 5, y: 7}, // Position 0 - front line center bottom
                    1: {x: 3, y: 7}, // Position 1 - back line left
                    2: {x: 4, y: 8}, // Position 2 - back line center
                    3: {x: 6, y: 8}  // Position 3 - back line right
                };

                this.party.forEach((member, i) => {
                    const pos = formations[i];
                    const color = colorMap[member.className] || '#6b7280';
                    const symbol = symbolMap[member.className] || 'üõ°';
                    member.sprite = new CharacterSprite(pos.x, pos.y, color, 'party');
                    member.sprite.classSymbol = symbol;
                    member.sprite.setCombatPosition(pos.x, pos.y);
                });

                // Show dungeon selector
                this.showDungeonSelector();

// Setup controls
document.getElementById('pause-btn').onclick = () => this.togglePause();

// Setup damage stats display toggle
const damageStatsDisplay = document.getElementById('damage-stats-display');
const combatStatsContainer = document.getElementById('combat-stats-container');

if (damageStatsDisplay && combatStatsContainer) {
    // Load saved position from localStorage
    const savedPos = localStorage.getItem('combatStatsPosition');
    if (savedPos) {
        try {
            const pos = JSON.parse(savedPos);
            combatStatsContainer.style.left = pos.left;
            combatStatsContainer.style.top = pos.top;
            combatStatsContainer.style.right = 'auto';
            combatStatsContainer.style.bottom = 'auto';
        } catch (e) {
            console.warn('Failed to restore combat stats position:', e);
        }
    }

    // Drag functionality
    let isDragging = false;
    let dragStarted = false;
    let startX, startY, startLeft, startTop;

    const onMouseDown = (e) => {
        isDragging = true;
        dragStarted = false;

        const rect = combatStatsContainer.getBoundingClientRect();
        startX = e.clientX;
        startY = e.clientY;
        startLeft = rect.left;
        startTop = rect.top;

        // Remove transform and convert to left/top positioning
        combatStatsContainer.style.transform = 'none';
        combatStatsContainer.style.left = startLeft + 'px';
        combatStatsContainer.style.top = startTop + 'px';
        combatStatsContainer.style.right = 'auto';
        combatStatsContainer.style.bottom = 'auto';

        e.preventDefault();
    };

    const onMouseMove = (e) => {
        if (!isDragging) return;

        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;

        // If moved more than 5 pixels, consider it a drag
        if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
            if (!dragStarted) {
                dragStarted = true;
                combatStatsContainer.classList.add('dragging');
            }
        }

        if (dragStarted) {
            const newLeft = startLeft + deltaX;
            const newTop = startTop + deltaY;

            // Keep within window bounds
            const maxLeft = window.innerWidth - combatStatsContainer.offsetWidth;
            const maxTop = window.innerHeight - combatStatsContainer.offsetHeight;

            combatStatsContainer.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
            combatStatsContainer.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';
        }
    };

    const onMouseUp = (e) => {
        if (isDragging) {
            isDragging = false;
            combatStatsContainer.classList.remove('dragging');

            // Save position to localStorage
            if (dragStarted) {
                localStorage.setItem('combatStatsPosition', JSON.stringify({
                    left: combatStatsContainer.style.left,
                    top: combatStatsContainer.style.top
                }));

                // Prevent click event from firing after drag
                e.stopPropagation();
            } else {
                // It was a click, not a drag - toggle stats display
                this.toggleCharacterStatsDisplay();
            }
        }
    };

    damageStatsDisplay.addEventListener('mousedown', onMouseDown);
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);

    // Double-click to reset position
    damageStatsDisplay.addEventListener('dblclick', (e) => {
        e.stopPropagation();
        localStorage.removeItem('combatStatsPosition');
        combatStatsContainer.style.left = '50%';
        combatStatsContainer.style.top = '50%';
        combatStatsContainer.style.right = 'auto';
        combatStatsContainer.style.bottom = 'auto';
        combatStatsContainer.style.transform = 'translate(-50%, -50%)';

        // Show feedback
        const originalText = damageStatsDisplay.innerHTML;
        damageStatsDisplay.innerHTML = '<span style="opacity: 0.5; margin-right: 4px;">‚ãÆ‚ãÆ</span>üìç Reset!';
        setTimeout(() => {
            damageStatsDisplay.innerHTML = originalText;
        }, 1000);
    });
}

// Setup collapse all button
document.getElementById('collapse-all-btn').onclick = () => {
    const sections = document.querySelectorAll('.collapsible-section');
    const allCollapsed = Array.from(sections).every(s => s.classList.contains('collapsed'));

    sections.forEach(section => {
        if (allCollapsed) {
            section.classList.remove('collapsed');
        } else {
            section.classList.add('collapsed');
        }
    });

    document.getElementById('collapse-all-btn').textContent = allCollapsed ? 'Collapse All' : 'Expand All';
};

// Setup reset account button in controls tab
document.getElementById('reset-account-controls-btn').onclick = () => {
    resetAccount();
};

// Add keyboard handlers
document.addEventListener('keydown', (e) => {
    if (e.repeat) return;

    if (e.key === 'Escape') {
        if (this.skillTreeOpen) {
            this.closeSkillTree();
        } else if (this.currentDungeon === 'vault' && this.inBattle) {
            if (confirm('Forfeit and leave the Vault?')) {
                this.endBattle(false);
            }
        }
    } else if (e.key === 'k' || e.key === 'K') {
        if (!this.skillTreeOpen && !this._skillTreeTransitioning) {
            this._skillTreeTransitioning = true;
            this.openSkillTree(0);
            setTimeout(() => {
                this._skillTreeTransitioning = false;
            }, 500);
        }
    }
});

document.addEventListener('keyup', (e) => {
    if (e.key === 'k' || e.key === 'K') {
        this._skillTreeKeyPressed = false;
    }
});


// Setup fountain popup toggle
                const fountainPopupToggle = document.getElementById('show-fountain-popup');
                this.fountainPopupEnabled = fountainPopupToggle.checked; // Read initial state from checkbox
                fountainPopupToggle.addEventListener('change', (e) => {
                    this.fountainPopupEnabled = e.target.checked;
                });

                // Setup treasure popup toggle
                const treasurePopupToggle = document.getElementById('show-treasure-popup');
                this.treasurePopupEnabled = treasurePopupToggle.checked;
                treasurePopupToggle.addEventListener('change', (e) => {
                    this.treasurePopupEnabled = e.target.checked;
                });

                // Setup summary duration slider
                const slider = document.getElementById('summary-duration-slider');
                const valueDisplay = document.getElementById('summary-duration-value');
                slider.addEventListener('input', (e) => {
                    this.summaryDuration = parseInt(e.target.value);
                    valueDisplay.textContent = `${this.summaryDuration}s`;
                });

                // Setup loot filter checkboxes
                document.querySelectorAll('.filter-checkbox').forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => {
                        const rarity = checkbox.getAttribute('data-rarity');
                        this.lootFilter[rarity] = checkbox.checked;

                        // Log the change
                        if (checkbox.checked) {
                            this.addLog(`Loot filter: ${rarity} items will be collected`, 'room');
                        } else {
                            this.addLog(`Loot filter: ${rarity} items will auto-sell`, 'room');
                        }
                    });
                });

                // Setup level filter input
                const levelFilter = document.getElementById('min-level-filter');
                if (levelFilter) {
                    levelFilter.addEventListener('input', (e) => {
                        const value = parseInt(e.target.value) || 1;
                        this.lootFilter.minLevel = Math.max(1, Math.min(999, value));
                        this.addLog(`Loot filter: Auto-selling items below level ${this.lootFilter.minLevel}`, 'room');
                    });
                }

// Setup party name inputs - dynamically match to party members by class
const nameInputs = {
    'tank': 'name-tank',
    'healer': 'name-healer',
    'mage': 'name-mage',
    'rogue': 'name-rogue',
    'archer': 'name-archer',
    'paladin': 'name-paladin'
};

Object.entries(nameInputs).forEach(([className, inputId]) => {
    const input = document.getElementById(inputId);
    if (input) {
        input.addEventListener('input', (e) => {
            // Find the party member with this class
            const member = this.party.find(m => m.className.toLowerCase() === className);
            if (member) {
                member.name = e.target.value || member.className;
                this.rebuildUI();
            }
        });
    }
});

                // Setup tab navigation
                document.querySelectorAll('.tab-button').forEach(button => {
                    button.addEventListener('click', () => {
                        const tabName = button.getAttribute('data-tab');
                        this.switchTab(tabName);
                    });
                });

                // Setup keystone/rune sub-tab switching - INITIALIZE ON LOAD
                document.querySelectorAll('.keystone-sub-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        // Remove active from all tabs
                        document.querySelectorAll('.keystone-sub-tab').forEach(t => t.classList.remove('active'));
                        document.querySelectorAll('.keystone-section').forEach(s => s.style.display = 'none');

                        // Activate clicked tab
                        tab.classList.add('active');
                        const targetSection = tab.getAttribute('data-keystone-tab');
                        document.getElementById(`keystone-${targetSection}-section`).style.display = 'block';

                        // If switching to runes, generate tabs and show the first party character
                        if (targetSection === 'runes') {
                            this.generateRuneTabs();
                            const firstChar = this.party[0].className.toLowerCase();
                            this.showRunesForCharacter(firstChar);
                        }
                    });
                });

                // Setup cache sub-tab switching - INITIALIZE ON LOAD
                document.querySelectorAll('.cache-sub-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        // Remove active from all tabs
                        document.querySelectorAll('.cache-sub-tab').forEach(t => t.classList.remove('active'));
                        document.querySelectorAll('.cache-section').forEach(s => s.style.display = 'none');

                        // Activate clicked tab
                        tab.classList.add('active');
                        const targetSection = tab.getAttribute('data-cache-tab');
                        document.getElementById(`cache-${targetSection}-section`).style.display = 'block';

                        // Refresh display when switching tabs
                        this.showChests();
                    });
                });
                // Setup loot filter buttons
                document.querySelectorAll('.loot-filter-btn').forEach(btn => {
                    btn.onclick = () => {
                        const filter = btn.getAttribute('data-filter');
                        const index = this.lootSortBy.indexOf(filter);

                        if (index === -1) {
                            this.lootSortBy.push(filter);
                            btn.classList.add('active');
                        } else {
                            this.lootSortBy.splice(index, 1);
                            btn.classList.remove('active');
                        }

                        this.showLoot();
                    };
                });

                // Setup inventory filter buttons
                document.querySelectorAll('.inventory-filter-btn').forEach(btn => {
                    btn.onclick = () => {
                        const filter = btn.getAttribute('data-filter');
                        const index = this.inventorySortBy.indexOf(filter);

                        if (index === -1) {
                            this.inventorySortBy.push(filter);
                            btn.classList.add('active');
                        } else {
                            this.inventorySortBy.splice(index, 1);
                            btn.classList.remove('active');
                        }

                        this.showInventory();
                    };
                });

                // Setup loot sub-tab switching
                document.querySelectorAll('.loot-sub-tab').forEach(tab => {
                    tab.onclick = () => {
                        const targetTab = tab.getAttribute('data-loot-tab');

                        // Hide any visible tooltips when switching loot sub-tabs
                        const lootTooltip = document.getElementById('loot-tooltip');
                        if (lootTooltip) lootTooltip.classList.remove('show');

                        // Update active states
                        document.querySelectorAll('.loot-sub-tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');

                        // Show correct section
                        document.querySelectorAll('.loot-section').forEach(s => s.style.display = 'none');
                        document.getElementById(`loot-${targetTab}-section`).style.display = 'block';
                    };
                });
                // Setup dungeon selection (both modal and tab versions)
                document.querySelectorAll('.dungeon-option, .dungeon-card').forEach(option => {
                    option.onclick = () => {
                        const dungeonType = option.getAttribute('data-dungeon');

                        // Prevent changing dungeons while in Divine Arena
                        if (this.currentDungeon === 'endlessblessings') {
                            this.addLog('‚ö†Ô∏è Cannot change dungeons during Divine Arena run! Use End Run button.', 'damage');
                            return;
                        }

                        this.selectDungeon(dungeonType);
                    };
                });

                // Hide tooltips on scroll in loot/inventory containers
                const lootContainer = document.getElementById('loot-container');
                const inventoryContainer = document.getElementById('inventory-container');
                const keystonesContainer = document.getElementById('keystones-collection-container');

                [lootContainer, inventoryContainer, keystonesContainer].forEach(container => {
                    if (container) {
                        container.addEventListener('scroll', () => {
                            const lootTooltip = document.getElementById('loot-tooltip');
                            if (lootTooltip) lootTooltip.classList.remove('show');
                            const equipTooltip = document.getElementById('equipment-tooltip');
                            if (equipTooltip) equipTooltip.classList.remove('show');
                        });
                    }
                });
            }

            switchTab(tabName) {
                // Hide any visible tooltips when switching tabs
                const lootTooltip = document.getElementById('loot-tooltip');
                if (lootTooltip) lootTooltip.classList.remove('show');
                const equipTooltip = document.getElementById('equipment-tooltip');
                if (equipTooltip) equipTooltip.classList.remove('show');

                // Remove active class from all buttons and panels
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));

                // Add active class to selected button and panel
                const button = document.querySelector(`.tab-button[data-tab="${tabName}"]`);
                const panel = document.getElementById(`${tabName}-tab`);

                if (button) button.classList.add('active');
                if (panel) panel.classList.add('active');

// Update displays when switching to certain tabs
                if (tabName === 'inventory') {
                    this.showInventory();
                } else if (tabName === 'loot') {
                    this.showLoot();
                } else if (tabName === 'chests') {
                    this.showChests();
                } else if (tabName === 'keystones') {
                    this.showKeystones();
                } else if (tabName === 'pets') {
                    this.showPetsCollection();
                }
            }

            getFilteredLootTable(baseLootTable) {
                // Filter the loot table to only include items that can be equipped by party members
                const validWeaponTypes = new Set();

                // Get all weapon types that party members can use
                this.party.forEach(member => {
                    for (const [weaponType, className] of Object.entries(this.weaponClassMapping)) {
                        if (member.className === className) {
                            validWeaponTypes.add(weaponType);
                        }
                    }
                });

                // Filter the loot table
                return baseLootTable.filter(itemType => {
                    // If it's a weapon, only include it if someone can use it
                    if (this.weaponClassMapping[itemType]) {
                        return validWeaponTypes.has(itemType);
                    }
                    // Non-weapon items (armor, accessories) are always valid
                    return true;
                });
            }

            showStartupTip() {
                const tipHTML = `
                    <div id="startup-tip-overlay" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.95); display: flex; justify-content: center; align-items: center; z-index: 5000; backdrop-filter: blur(10px);">
                        <div style="background: linear-gradient(135deg, rgba(30, 41, 59, 0.98) 0%, rgba(15, 23, 42, 0.98) 100%); border: 3px solid rgba(99, 102, 241, 0.5); border-radius: 20px; padding: 40px; max-width: 1200px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9); position: relative;">
                            <div style="text-align: center; margin-bottom: 30px;">
                                <h2 style="font-family: 'Orbitron', sans-serif; font-size: 32px; color: #f59e0b; text-shadow: 0 4px 20px rgba(245, 158, 11, 0.5); margin-bottom: 10px;">üí° Helpful Tip üí°</h2>
                                <div style="width: 100px; height: 3px; background: linear-gradient(90deg, transparent, #f59e0b, transparent); margin: 0 auto;"></div>
                            </div>

                            <div style="text-align: center; margin-bottom: 30px;">
                                <img src="helpful%20tip.png" style="max-width: 100%; height: auto; border-radius: 12px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);">
                            </div>

                            <button id="startup-tip-ok-btn" style="width: 100%; padding: 18px; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 12px; font-family: 'Orbitron', sans-serif; font-size: 18px; font-weight: 700; cursor: pointer; text-transform: uppercase; letter-spacing: 2px; box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4); transition: all 0.3s ease;">
                                Got It! Let's Go! üöÄ
                            </button>
                        </div>
                    </div>
                `;

                const div = document.createElement('div');
                div.innerHTML = tipHTML;
                document.body.appendChild(div.firstElementChild);

                document.getElementById('startup-tip-ok-btn').onclick = () => {
                    document.getElementById('startup-tip-overlay').remove();
                    this.showDungeonSelector();
                };

                // Add hover effect
                const btn = document.getElementById('startup-tip-ok-btn');
                btn.addEventListener('mouseenter', () => {
                    btn.style.transform = 'translateY(-3px)';
                    btn.style.boxShadow = '0 8px 30px rgba(16, 185, 129, 0.6)';
                });
                btn.addEventListener('mouseleave', () => {
                    btn.style.transform = 'translateY(0)';
                    btn.style.boxShadow = '0 6px 20px rgba(16, 185, 129, 0.4)';
                });
            }

            showDungeonSelector() {
                // CRITICAL FIX: Hide any visible tooltips when showing dungeon selector
                const lootTooltip = document.getElementById('loot-tooltip');
                if (lootTooltip) {
                    lootTooltip.classList.remove('show');
                    lootTooltip.style.display = 'none';
                }

                // CLEANUP: Clear any leftover state from previous dungeon
                this.enemies = [];
                this.inBattle = false;

                // Clear enemy health bars
                const healthBarContainer = document.getElementById('enemy-health-bars');
                if (healthBarContainer) {
                    healthBarContainer.innerHTML = '';
                }

                // Show minimap (it may have been hidden in endless mode)
                const minimapCanvas = document.getElementById('map-canvas');
                if (minimapCanvas) {
                    minimapCanvas.style.display = 'block';
                }

                // Hide kill counter (it's only for endless mode)
                const killCounter = document.getElementById('kill-counter');
                if (killCounter) {
                    killCounter.style.display = 'none';
                }

                // Hide End Run button when returning to dungeon selector
                const endRunBtn = document.getElementById('end-run-btn');
                if (endRunBtn) {
                    endRunBtn.style.display = 'none';
                }

                // Hide combat stats container when returning to dungeon selector
                const combatStatsContainer = document.getElementById('combat-stats-container');
                if (combatStatsContainer) {
                    combatStatsContainer.style.display = 'none';
                }

                // Create the banner selector using individual banner images
                const selectorHTML = `
                    <div id="dungeon-banner-selector">
                        <div id="select-dungeon-title">SELECT YOUR DUNGEON</div>
                        <div id="dungeon-banner-container">
                            <div class="dungeon-banner everfall" data-dungeon="everfall" style="background: url('everfall%20banner.png') center/cover;"></div>
                            <div class="dungeon-banner stoneforge" data-dungeon="stoneforge" style="background: url('stoneforge%20banner.png') center/cover;"></div>
                            <div class="dungeon-banner umbral" data-dungeon="umbral" style="background: url('umbral%20depths.png') center/cover;"></div>
                            <div class="dungeon-banner vault" data-dungeon="vault" style="background: url('the%20vault.png') center/cover; ${this.vaultKeys.length === 0 ? 'filter: grayscale(100%) brightness(0.5); opacity: 0.6;' : ''}"></div>
                            <div class="dungeon-banner runetrial" data-dungeon="runetrial" style="background: url('rune%20trials.png') center/cover; ${this.runeTrialKeys.length === 0 ? 'filter: grayscale(100%) brightness(0.5); opacity: 0.6;' : ''}"></div>
                        </div>
                    </div>
                `;

                // Add to document
                const div = document.createElement('div');
                div.innerHTML = selectorHTML;
                document.body.appendChild(div.firstElementChild);

               // Setup click handlers
document.querySelectorAll('.dungeon-banner').forEach(banner => {
    banner.onclick = () => {
        const dungeonType = banner.getAttribute('data-dungeon');

        // Check for required keys before closing selector
        if (dungeonType === 'vault' && this.vaultKeys.length === 0) {
            this.addLog('üîí You need a Vault Key to enter! Keys drop from clearing floors (10% chance).', 'room');
            return;
        }

        if (dungeonType === 'runetrial' && this.runeTrialKeys.length === 0) {
            this.addLog('üîí You need a Rune Trial Key to enter! Keys drop from floor 45+ (10% chance).', 'room');
            return;
        }

        document.getElementById('dungeon-banner-selector').remove();
        this.selectDungeon(dungeonType);
    };
});

                this.paused = true;
            }

            endDivineArenaRun() {
                // Only allow ending if we're actually in Divine Arena
                if (this.currentDungeon !== 'endlessblessings') {
                    return;
                }

                // Show the Divine Arena summary screen
                this.showEndlessSummary();
            }

            showEndlessSummary() {
                // CRITICAL FIX: Hide any visible tooltips immediately when showing summary
                const lootTooltip = document.getElementById('loot-tooltip');
                if (lootTooltip) {
                    lootTooltip.classList.remove('show');
                    lootTooltip.style.display = 'none';
                }

                const killCount = this.endlessKillCount || 0;
                const wave = this.endlessWave || 1;

                // Calculate blessings earned during this run
                const blessingsEarned = (this.blessingCurrency || 0) - (this.endlessRunStartBlessings || 0);

                // Get loot collected during this run
                const lootCollected = this.endlessRunLoot || [];

                // Calculate time taken (if tracking exists)
                let timeString = 'N/A';
                if (this.floorStats && this.floorStats.startTime) {
                    const timeElapsed = Math.floor((Date.now() - this.floorStats.startTime) / 1000);
                    const minutes = Math.floor(timeElapsed / 60);
                    const seconds = timeElapsed % 60;
                    timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }

                // Determine performance tier based on kills
                let performanceTier = '';
                let tierColor = '';
                let tierGlow = '';
                if (killCount >= 200) {
                    performanceTier = 'üåå TRANSCENDENT';
                    tierColor = '#c084fc';
                    tierGlow = 'rgba(168, 85, 247, 0.6)';
                } else if (killCount >= 180) {
                    performanceTier = 'üëë ULTIMATE';
                    tierColor = '#fbbf24';
                    tierGlow = 'rgba(251, 191, 36, 0.6)';
                } else if (killCount >= 160) {
                    performanceTier = '‚ú® GODLY';
                    tierColor = '#f472b6';
                    tierGlow = 'rgba(244, 114, 182, 0.6)';
                } else if (killCount >= 140) {
                    performanceTier = 'üîÆ MYTHIC';
                    tierColor = '#ec4899';
                    tierGlow = 'rgba(236, 72, 153, 0.6)';
                } else if (killCount >= 120) {
                    performanceTier = 'üíé LEGENDARY';
                    tierColor = '#8b5cf6';
                    tierGlow = 'rgba(139, 92, 246, 0.6)';
                } else if (killCount >= 100) {
                    performanceTier = 'üåü MASTERWORK';
                    tierColor = '#6366f1';
                    tierGlow = 'rgba(99, 102, 241, 0.6)';
                } else if (killCount >= 80) {
                    performanceTier = '‚≠ê EXCEPTIONAL';
                    tierColor = '#fbbf24';
                    tierGlow = 'rgba(251, 191, 36, 0.5)';
                } else if (killCount >= 60) {
                    performanceTier = 'üí´ ELITE';
                    tierColor = '#ec4899';
                    tierGlow = 'rgba(236, 72, 153, 0.5)';
                } else if (killCount >= 40) {
                    performanceTier = 'üî• SUPERIOR';
                    tierColor = '#f59e0b';
                    tierGlow = 'rgba(245, 158, 11, 0.5)';
                } else if (killCount >= 20) {
                    performanceTier = '‚ö° ENHANCED';
                    tierColor = '#a855f7';
                    tierGlow = 'rgba(168, 85, 247, 0.5)';
                } else {
                    performanceTier = '‚öîÔ∏è WARRIOR';
                    tierColor = '#10b981';
                    tierGlow = 'rgba(16, 185, 129, 0.5)';
                }

                // Build character stats HTML
                let characterStatsHTML = '';
                if (this.characterStats) {
                    const sortedByDamage = Object.entries(this.characterStats)
                        .sort((a, b) => b[1].damageDealt - a[1].damageDealt);

                    characterStatsHTML = `
                        <div style="background: rgba(15, 23, 42, 0.5); border-radius: 12px; padding: 20px; margin-bottom: 20px; border: 1px solid rgba(99, 102, 241, 0.2);">
                            <div style="font-size: 18px; color: #e2e8f0; font-weight: 700; margin-bottom: 15px; text-align: center; font-family: 'Orbitron', sans-serif;">Character Performance</div>
                            ${sortedByDamage.map(([name, stats]) => `
                                <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(99, 102, 241, 0.1);">
                                    <span style="color: #94a3b8; font-weight: 500;">${name}:</span>
                                    <div style="text-align: right;">
                                        <div style="color: #ef4444; font-weight: 700; font-family: 'Orbitron', sans-serif; font-size: 13px;">
                                            üí• ${stats.damageDealt.toLocaleString()}
                                        </div>
                                        <div style="color: #10b981; font-weight: 700; font-family: 'Orbitron', sans-serif; font-size: 13px;">
                                            üíö ${stats.healingDone.toLocaleString()}
                                        </div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }

                // Build loot HTML
                let lootHTML = '';
                if (lootCollected.length > 0) {
                    const rarityColors = {
                        common: '#9ca3af',
                        uncommon: '#10b981',
                        rare: '#3b82f6',
                        epic: '#a855f7',
                        legendary: '#f59e0b',
                        mythic: '#ec4899'
                    };

                    lootHTML = `
                        <div style="background: rgba(15, 23, 42, 0.5); border-radius: 12px; padding: 20px; margin-bottom: 20px; border: 1px solid rgba(99, 102, 241, 0.2);">
                            <div style="font-size: 18px; color: #f59e0b; font-weight: 700; margin-bottom: 15px; text-align: center; font-family: 'Orbitron', sans-serif; text-transform: uppercase; letter-spacing: 2px;">
                                Bonus Loot (${lootCollected.length} Items)
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 10px;">
                                ${lootCollected.map(item => `
                                    <div style="background: linear-gradient(135deg, rgba(30, 41, 59, 0.9), rgba(15, 23, 42, 0.9)); border: 2px solid ${rarityColors[item.rarity]}; border-radius: 8px; padding: 12px; text-align: center; box-shadow: 0 0 15px ${rarityColors[item.rarity]}40;">
                                        <div style="color: ${rarityColors[item.rarity]}; font-weight: 700; font-size: 11px; text-transform: uppercase; margin-bottom: 4px;">${item.rarity}</div>
                                        <div style="color: #e2e8f0; font-weight: 600; font-size: 13px; margin-bottom: 2px;">${item.name}</div>
                                        <div style="color: #94a3b8; font-size: 11px;">Lvl ${item.level}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }

                // Create custom Divine Arena summary overlay
                const overlay = document.createElement('div');
                overlay.id = 'divine-arena-summary-overlay';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: radial-gradient(ellipse at center, ${tierGlow} 0%, rgba(0, 0, 0, 0.95) 70%);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 2000;
                    backdrop-filter: blur(20px);
                    animation: fadeIn 0.3s ease;
                `;

                const panel = document.createElement('div');
                panel.style.cssText = `
                    background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(6, 9, 23, 0.98) 100%);
                    border: 3px solid ${tierColor};
                    border-radius: 20px;
                    padding: 40px;
                    max-width: 700px;
                    width: 90%;
                    box-shadow: 0 30px 80px rgba(0, 0, 0, 0.9), 0 0 60px ${tierGlow}, inset 0 1px 0 rgba(255, 255, 255, 0.1);
                    animation: slideUp 0.4s ease;
                `;

                panel.innerHTML = `
                    <div style="font-family: 'Orbitron', sans-serif; font-size: 48px; font-weight: 800; text-align: center; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 4px; color: ${tierColor}; text-shadow: 0 0 40px ${tierGlow}; animation: titlePulse 2s ease-in-out infinite;">
                        DIVINE ARENA
                    </div>

                    <div style="text-align: center; font-size: 28px; color: ${tierColor}; font-weight: 800; margin-bottom: 25px; font-family: 'Orbitron', sans-serif; text-shadow: 0 0 20px ${tierGlow};">
                        ${performanceTier}
                    </div>

                    <div style="background: rgba(15, 23, 42, 0.5); border-radius: 12px; padding: 25px; margin-bottom: 25px; border: 1px solid rgba(99, 102, 241, 0.2);">
                        <div style="display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid rgba(99, 102, 241, 0.1);">
                            <span style="color: #94a3b8; font-weight: 500;">Total Kills:</span>
                            <span style="color: ${tierColor}; font-weight: 700; font-family: 'Orbitron', sans-serif; font-size: 20px;">${killCount}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid rgba(99, 102, 241, 0.1);">
                            <span style="color: #94a3b8; font-weight: 500;">Waves Completed:</span>
                            <span style="color: #a855f7; font-weight: 700; font-family: 'Orbitron', sans-serif;">${wave}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid rgba(99, 102, 241, 0.1);">
                            <span style="color: #94a3b8; font-weight: 500;">Final Enemy Level:</span>
                            <span style="color: #ef4444; font-weight: 700; font-family: 'Orbitron', sans-serif;">${this.endlessEnemyLevel || 60}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid rgba(99, 102, 241, 0.1);">
                            <span style="color: #94a3b8; font-weight: 500;">Blessings Earned:</span>
                            <span style="color: #fbbf24; font-weight: 700; font-family: 'Orbitron', sans-serif;">${blessingsEarned.toLocaleString()} ‚ú®</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 10px 0;">
                            <span style="color: #94a3b8; font-weight: 500;">Time Survived:</span>
                            <span style="color: #e2e8f0; font-weight: 700; font-family: 'Orbitron', sans-serif;">${timeString}</span>
                        </div>
                    </div>

                    ${lootHTML}

                    ${characterStatsHTML}

                    <button id="divine-arena-summary-btn" style="width: 100%; padding: 18px; background: linear-gradient(135deg, ${tierColor}, rgba(99, 102, 241, 0.8)); color: white; border: none; border-radius: 12px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 16px; font-weight: 700; text-transform: uppercase; letter-spacing: 2px; transition: all 0.3s ease; box-shadow: 0 4px 20px ${tierGlow}; position: relative; overflow: hidden;">
                        Return to Dungeon Selector
                    </button>
                `;

                overlay.appendChild(panel);
                document.body.appendChild(overlay);

                // Add animations via style tag
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes fadeIn {
                        from { opacity: 0; }
                        to { opacity: 1; }
                    }
                    @keyframes slideUp {
                        from { transform: translateY(50px); opacity: 0; }
                        to { transform: translateY(0); opacity: 1; }
                    }
                    @keyframes titlePulse {
                        0%, 100% { opacity: 1; }
                        50% { opacity: 0.8; }
                    }
                `;
                document.head.appendChild(style);

                // Button click handler
                const button = document.getElementById('divine-arena-summary-btn');
                button.onclick = () => {
                    overlay.remove();
                    style.remove();

                    // Clear Divine Arena specific state
                    this.endlessKillCount = 0;
                    this.endlessWave = 1;
                    this.endlessEnemyLevel = 60;
                    this.endlessEnemiesKilledThisWave = 0;

                    // Clear current dungeon
                    this.currentDungeon = null;
                    this.dungeonFloor = 1;

                    // Show dungeon selector (this will handle all cleanup)
                    this.showDungeonSelector();
                };
            }


            setDungeonBackground(dungeonType, imageUrl) {
    console.log('üé® setDungeonBackground called with:', dungeonType, imageUrl);
    console.log('üé® Current dungeon:', this.currentDungeon);

    const mainView = document.getElementById('main-view');
    if (!mainView) {
        console.error('‚ùå main-view element not found!');
        return;
    }

    // Built-in backgrounds
    const backgrounds = {
    everfall: 'everfall.png',
    stoneforge: 'stoneforge.png',
    umbral: 'umbral%20depths1.png', // <- Change this line
    vault: 'vault.png',
    runetrial: 'runetrial.png'
};

    // Use provided imageUrl or fall back to dungeon-specific background
    const finalImageUrl = imageUrl || backgrounds[dungeonType];

    if (!finalImageUrl) {
        // No background - use default gradient
        console.log('‚ÑπÔ∏è No background image, using default gradient');
        mainView.style.backgroundImage = '';
        mainView.style.backgroundColor = 'linear-gradient(135deg, #0a0e27 0%, #151935 100%)';
        return;
    }

    // Set the background with dark overlay
    console.log('üñºÔ∏è Setting background to:', finalImageUrl);
    console.log('üéÆ Dungeon type:', dungeonType);
    mainView.style.backgroundColor = '#0a0e27';

    // Special divine golden overlay for Divine Arena (toned down)
    if (dungeonType === 'endlessblessings') {
        mainView.style.backgroundImage = `
            linear-gradient(180deg,
                rgba(184, 134, 11, 0.25) 0%,    /* Darker goldenrod at top */
                rgba(218, 165, 32, 0.2) 25%,    /* Muted goldenrod */
                rgba(160, 130, 50, 0.25) 50%,   /* Subdued gold middle */
                rgba(139, 115, 45, 0.3) 75%,    /* Dark muted gold */
                rgba(80, 70, 40, 0.4) 100%      /* Very dark gold-brown bottom */
            ),
            radial-gradient(ellipse at center, rgba(200, 160, 50, 0.15) 0%, transparent 70%),  /* Subtle golden glow from center */
            url('${finalImageUrl}')
        `;
        // Add gentle pulsing animation for divine effect (6s for better performance)
        mainView.style.animation = 'endlessBlessingsPulse 6s ease-in-out infinite';
    } else {
        mainView.style.backgroundImage = `
            linear-gradient(180deg, rgba(6, 9, 23, 0.5) 0%, rgba(15, 23, 42, 0.7) 100%),
            url('${finalImageUrl}')
        `;
        mainView.style.animation = '';
    }

    mainView.style.backgroundSize = 'cover';
    mainView.style.backgroundPosition = 'center';
    mainView.style.backgroundRepeat = 'no-repeat';

    console.log('‚úÖ Background set successfully!');
    console.log('üì∏ Final background image style:', mainView.style.backgroundImage);
}
openSkillTree(characterIndex) {
    if (this.skillTreeOpen) return;

    this.skillTreeOpen = true;
    this.currentSkillTreeCharacter = characterIndex;
    this.paused = true;

    // Store current game data
    // FIX: Use member.className.toLowerCase() instead of hardcoded party order
    const gameData = {
        characters: {},
        partyComposition: [] // NEW: Store which characters are in the party
    };

    this.party.forEach((member, idx) => {
        const charKey = member.className.toLowerCase();
        gameData.characters[charKey] = {
            allocatedNodes: Array.from(member.skillTreeData.allocatedNodes),
            usedPoints: member.skillTreeData.usedPoints,
            availablePoints: member.skillPoints
        };
        // Store the character class name and display info
        gameData.partyComposition.push({
            index: idx,
            key: charKey,
            name: member.className,
            classSymbol: member.classSymbol
        });
    });

    localStorage.setItem('gameSkillTreeData', JSON.stringify(gameData));
    localStorage.setItem('currentCharacterIndex', characterIndex.toString());

    // Create iframe with skill tree HTML
    const container = document.createElement('div');
    container.id = 'skill-tree-container';
    container.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 3000; background: #000;';

    this.skillTreeFrame = document.createElement('iframe');
    this.skillTreeFrame.style.cssText = 'width: 100%; height: 100%; border: none;';

    // Load the skill tree HTML as a data URL
    const skillTreeHTML = this.getSkillTreeHTML();
    const blob = new Blob([skillTreeHTML], { type: 'text/html' });
    const dataUrl = URL.createObjectURL(blob);
    this.skillTreeFrame.src = dataUrl;

    // Clean up blob URL after load and monitor for close
    this.skillTreeFrame.onload = () => {
        URL.revokeObjectURL(dataUrl);

        // Poll for close request since postMessage doesn't work with blob URLs
        this._closeCheckInterval = setInterval(() => {
            if (localStorage.getItem('skillTreeCloseRequested') === 'true') {
                localStorage.removeItem('skillTreeCloseRequested');
                clearInterval(this._closeCheckInterval);
                this.closeSkillTree();
            }
        }, 100);
    };

    container.appendChild(this.skillTreeFrame);
    document.body.appendChild(container);

    // Listen for close messages (remove old listener first to prevent duplicates)
    if (this._skillTreeMessageHandler) {
        window.removeEventListener('message', this._skillTreeMessageHandler);
    }
    this._skillTreeMessageHandler = (e) => this.handleSkillTreeMessage(e);
    window.addEventListener('message', this._skillTreeMessageHandler);
}

            getSkillTreeHTML() {
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skill Tree Viewer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght=400;600;800&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #151935 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #header {
            background: linear-gradient(180deg, rgba(15, 23, 42, 0.98) 0%, rgba(6, 9, 23, 0.98) 100%);
            border-bottom: 2px solid rgba(99, 102, 241, 0.3);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(10px);
            position: relative;
            z-index: 100;
        }

        #header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        #header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #character-tabs {
            display: flex;
            gap: 5px;
            background: rgba(30, 41, 59, 0.5);
            padding: 5px;
            border-radius: 12px;
        }

        .character-tab {
            padding: 10px 20px;
            background: transparent;
            color: #94a3b8;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            position: relative;
        }

        .character-tab:hover {
            background: rgba(99, 102, 241, 0.1);
            color: #e2e8f0;
        }

        .character-tab.active {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: #fff;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
        }

        .character-tab .points-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #f59e0b;
            color: #000;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 800;
        }

        #skill-points {
            font-size: 18px;
            color: #f59e0b;
            text-shadow: 0 2px 10px rgba(245, 158, 11, 0.5);
            min-width: 180px;
            text-align: center;
        }

        #stats-panel {
    background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(6, 9, 23, 0.98) 100%);
    border: 2px solid rgba(99, 102, 241, 0.5);
    padding: 20px 24px;
    border-radius: 16px;
    width: 320px;
    min-height: 200px;
    max-height: 400px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(20px);
    position: relative;
}

#rune-inventory-panel {
    background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(6, 9, 23, 0.98) 100%);
    border: 2px solid rgba(168, 85, 247, 0.5);
    padding: 20px 24px;
    border-radius: 16px;
    width: 320px;
    min-height: 200px;
    max-height: 400px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    box-shadow: 0 20px 60px rgba(168, 85, 247, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(20px);
    position: relative;
    margin-left: 15px;
}

#rune-inventory-title {
    color: #a855f7;
    font-weight: 700;
    font-size: 16px;
    border-bottom: 1px solid rgba(168, 85, 247, 0.3);
    padding-bottom: 8px;
    margin-bottom: 6px;
    text-align: center;
    text-shadow: 0 2px 10px rgba(168, 85, 247, 0.3);
}

#rune-inventory-content {
    overflow-y: auto;
    flex: 1;
}

#no-runes {
    color: #64748b;
    font-style: italic;
    font-size: 12px;
    text-align: center;
    padding: 10px 0;
}

.rune-inventory-item {
    background: rgba(168, 85, 247, 0.1);
    border: 2px solid rgba(168, 85, 247, 0.3);
    border-radius: 8px;
    padding: 10px;
    margin-bottom: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.rune-inventory-item:hover {
    background: rgba(168, 85, 247, 0.2);
    border-color: rgba(168, 85, 247, 0.5);
    transform: translateX(3px);
}

.rune-inventory-item.selected {
    background: rgba(168, 85, 247, 0.3);
    border-color: #a855f7;
    box-shadow: 0 0 15px rgba(168, 85, 247, 0.4);
}

.rune-name {
    font-weight: 700;
    font-size: 13px;
    color: #c4b5fd;
    margin-bottom: 4px;
}

.rune-stats {
    font-size: 11px;
    color: #e2e8f0;
    line-height: 1.4;
}

.rune-level {
    font-size: 10px;
    color: #f59e0b;
    margin-top: 4px;
}

.rune-equipped-indicator {
    display: inline-block;
    background: #10b981;
    color: #fff;
    font-size: 9px;
    padding: 2px 6px;
    border-radius: 4px;
    margin-left: 6px;
    font-weight: 600;
}

        #stats-title {
            color: #f59e0b;
            font-weight: 700;
            font-size: 16px;
            border-bottom: 1px solid rgba(99, 102, 241, 0.3);
            padding-bottom: 8px;
            margin-bottom: 6px;
            text-align: center;
            text-shadow: 0 2px 10px rgba(245, 158, 11, 0.3);
        }

        #stats-content {
            overflow-y: auto;
            flex: 1;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            margin-bottom: 6px;
            background: rgba(99, 102, 241, 0.05);
            border-radius: 8px;
            border-left: 3px solid transparent;
            transition: all 0.3s ease;
            font-size: 13px;
            color: #94a3b8;
        }

        .stat-row:hover {
            background: rgba(99, 102, 241, 0.1);
            border-left-color: #6366f1;
            transform: translateX(5px);
        }

        .stat-name {
            color: #cbd5e1;
            font-weight: 500;
        }

        .stat-value {
            color: #10b981;
            font-weight: 700;
            text-shadow: 0 1px 5px rgba(16, 185, 129, 0.3);
        }

        .stat-value.negative {
            color: #ef4444;
            text-shadow: 0 1px 5px rgba(239, 68, 68, 0.3);
        }

        #no-stats {
            color: #64748b;
            font-style: italic;
            font-size: 12px;
            text-align: center;
            padding: 10px 0;
        }

        .header-btn {
            padding: 14px 28px;
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 14px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(16, 185, 129, 0.4);
            position: relative;
            overflow: hidden;
        }

        .header-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .header-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 30px rgba(16, 185, 129, 0.6);
        }

        .header-btn:hover::before {
            left: 100%;
        }

        .header-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 15px rgba(16, 185, 129, 0.4);
        }

        .header-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
        }


#close-circle-btn:hover {
    background: rgba(239, 68, 68, 0.25);
    border-color: rgba(239, 68, 68, 0.7);
    box-shadow: 0 4px 20px rgba(239, 68, 68, 0.5);
    transform: scale(1.1);
}

#close-circle-btn:active {
    transform: scale(0.95);
}

        .save-notification {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            padding: 15px 30px;
            border-radius: 12px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 600;
            box-shadow: 0 10px 30px rgba(16, 185, 129, 0.5);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 2000;
        }

        .save-notification.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #skill-tree-canvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #skill-tree-canvas:active {
            cursor: grabbing;
        }

        #tooltip {
            position: absolute;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(6, 9, 23, 0.98) 100%);
            border: 2px solid rgba(99, 102, 241, 0.5);
            border-radius: 12px;
            padding: 16px;
            font-size: 14px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
            min-width: 200px;
        }

        #tooltip.show {
            display: block;
        }

        .tooltip-header {
            font-weight: 700;
            margin-bottom: 8px;
            font-size: 16px;
        }

        .tooltip-stats {
            color: #94a3b8;
            line-height: 1.6;
        }

        .tooltip-cost {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(99, 102, 241, 0.3);
            color: #f59e0b;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.95);
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid rgba(99, 102, 241, 0.3);
            display: flex;
            gap: 15px;
            backdrop-filter: blur(10px);
        }

        .control-info {
            font-size: 12px;
            color: #94a3b8;
        /* DELETE THESE - NOT NEEDED
@keyframes pulse-purple { ... }
@keyframes pulse-gold { ... }
*/
    </style>
</head>
<body>
    <div id="header">
        <div id="header-left">
            <div id="character-tabs">
                <!-- Character tabs will be dynamically generated based on party composition -->
            </div>
            <div id="skill-points">Skill Points: 1 / 1</div>
        </div>

<div id="header-right">
    <div id="stats-panel">
        <div id="stats-title">Ëé∑ÂæóÂ±ûÊÄß</div>
        <div id="stats-content"><div id="no-stats">ÊöÇÊó†Â∑≤ÂàÜÈÖçÂ±ûÊÄß</div></div>
    </div>
    <div id="rune-stats-panel" style="background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(6, 9, 23, 0.98) 100%); border: 2px solid rgba(168, 85, 247, 0.5); padding: 20px 24px; border-radius: 16px; width: 320px; min-height: 200px; max-height: 400px; display: flex; flex-direction: column; gap: 8px; box-shadow: 0 20px 60px rgba(168, 85, 247, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1); backdrop-filter: blur(20px); position: relative; margin-left: 15px;">
        <div id="rune-stats-title" style="color: #a855f7; font-weight: 700; font-size: 16px; border-bottom: 1px solid rgba(168, 85, 247, 0.3); padding-bottom: 8px; margin-bottom: 6px; text-align: center; text-shadow: 0 2px 10px rgba(168, 85, 247, 0.3);">Á¨¶ÊñáÂ±ûÊÄß</div>
        <div id="rune-stats-content" style="overflow-y: auto; flex: 1;"></div>
    </div>
    <button id="save-btn" class="header-btn">‰øùÂ≠òÊ†ë</button>
</div>
    </div>
    <div id="canvas-container">
        <canvas id="skill-tree-canvas"></canvas>
        <div id="tooltip"></div>
    </div>
    <div id="controls">
        <span class="control-info">üñ±Ô∏è Â∑¶ÈîÆÁÇπÂáª: ÂàÜÈÖçËäÇÁÇπ</span>
        <span class="control-info">üñ±Ô∏è Âè≥ÈîÆÁÇπÂáª: ÈáäÊîæËäÇÁÇπ</span>
        <span class="control-info">üñ±Ô∏è ÊãñÂä®: ÂÖ®ÊôØËßÜÂõæ</span>
        <span class="control-info">üñ±Ô∏è ÊªöÂä®: Áº©Êîæ</span>
    </div>
    <div class="save-notification" id="save-notification">Ê†ëÂ∑≤‰øùÂ≠ò!</div>

    <script>` +
    // The entire skill tree JavaScript code goes here - I'll continue in next part due to length
    `
        class SkillTreeViewer {
            constructor() {
                this.canvas = document.getElementById('skill-tree-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.tooltip = document.getElementById('tooltip');

                // Set canvas size after DOM is fully ready
                this.resizeCanvas();
                // Force another resize after a short delay to ensure proper sizing
                setTimeout(() => {
                    this.resizeCanvas();
                }, 50);
                setTimeout(() => {
                    this.resizeCanvas();
                }, 200);

                // Camera controls
                this.camera = {
                    x: 0,
                    y: 0,
                    zoom: 0.7
                };

                // Mouse state
                this.mouse = {
                    x: 0,
                    y: 0,
                    worldX: 0,
                    worldY: 0,
                    dragging: false,
                    dragStartX: 0,
                    dragStartY: 0
                };

                // Character data storage - initialize all possible characters
                this.characters = {
                    tank: {
                        allocatedNodes: new Set([0]),
                        usedPoints: 0,
                        availablePoints: 1
                    },
                    healer: {
                        allocatedNodes: new Set([0]),
                        usedPoints: 0,
                        availablePoints: 1
                    },
                    mage: {
                        allocatedNodes: new Set([0]),
                        usedPoints: 0,
                        availablePoints: 1
                    },
                    rogue: {
                        allocatedNodes: new Set([0]),
                        usedPoints: 0,
                        availablePoints: 1
                    },
                    archer: {
                        allocatedNodes: new Set([0]),
                        usedPoints: 0,
                        availablePoints: 1
                    },
                    paladin: {
                        allocatedNodes: new Set([0]),
                        usedPoints: 0,
                        availablePoints: 1
                    }
                };

                // Current character
                this.currentCharacter = 'tank';

                // Skill tree data
                this.nodes = [];
                this.connections = [];
                this.skillPoints = 1; // Default to 1 skill point

                // Initialize immediately to prevent display issues
                this.updatePointsDisplay();

                // Load from game data first if available
                const gameData = localStorage.getItem('gameSkillTreeData');
                const currentCharIndex = localStorage.getItem('currentCharacterIndex');

                if (gameData) {
                    const data = JSON.parse(gameData);

                    // Override default characters data with real game data
                    for (const char in data.characters) {
                        if (data.characters[char]) {
                            // Recalculate used points to avoid counting bugs
                            const allocatedSet = new Set(data.characters[char].allocatedNodes || [0]);
                            let recalculatedPoints = 0;
                            allocatedSet.forEach(nodeId => {
                                if (nodeId !== 0) { // Don't count the start node
                                    recalculatedPoints += 1; // Each non-start node costs 1 point
                                }
                            });

                            this.characters[char] = {
                                allocatedNodes: allocatedSet,
                                usedPoints: recalculatedPoints
                            };
                        }
                    }

                    // Set initial character based on who opened the tree - FIX: Use partyComposition
                    if (currentCharIndex !== null && data.partyComposition) {
                        const charIndex = parseInt(currentCharIndex);
                        const charKey = data.partyComposition[charIndex] ? data.partyComposition[charIndex].key : null;
                        this.currentCharacter = charKey;

                        // Use that character's level for total skill points
                        if (data.characters[charKey] && data.characters[charKey].level) {
                            this.skillPoints = data.characters[charKey].level; // Total skill points = level
                            // Ensure skill points is reasonable
                            if (this.skillPoints > 100 || this.skillPoints < 1) {
                                this.skillPoints = 1; // Reset to 1 if corrupted
                            }
                        }
                    }
                } else {
                    // Fall back to saved skillTreeData if no game data
                    const savedData = localStorage.getItem('skillTreeData');
                if (savedData) {
                    try {
                        const data = JSON.parse(savedData);
                        // Convert Arrays back to Sets
                        for (const char in data.characters) {
                            if (data.characters[char]) {
                                this.characters[char] = {
                                    allocatedNodes: new Set(data.characters[char].allocatedNodes || [0]),
                                    usedPoints: data.characters[char].usedPoints || 0
                                };
                                // If we have level data in saved data, use it to set skill points
                                if (char === this.currentCharacter && data.characters[char].level) {
                                    this.skillPoints = data.characters[char].level;
                                }
                            }
                        }
                    } catch (e) {
                        console.log('Could not load saved data');
                    }
                }
                }

                // Set current character's data
                this.allocatedNodes = this.characters[this.currentCharacter].allocatedNodes;
                this.usedPoints = this.characters[this.currentCharacter].usedPoints;

                // Final sanity check on skill points
                const gameDataValidation = localStorage.getItem('gameSkillTreeData');
                if (gameDataValidation) {
                    const dataValidation = JSON.parse(gameDataValidation);
                    if (dataValidation.characters[this.currentCharacter] && dataValidation.characters[this.currentCharacter].level) {
                        const maxAllowed = dataValidation.characters[this.currentCharacter].level;
                        if (this.skillPoints > maxAllowed) {
                            this.skillPoints = maxAllowed; // Cap at character's level
                        }
                    }
                }

                if (this.skillPoints > 100 || this.skillPoints < 1) {
                    this.skillPoints = Math.max(1, this.usedPoints + 1); // At least enough for allocated nodes + 1
                }

                this.updatePointsDisplay(); // Update display first
                this.generateTree();
                this.setupEventListeners();
                this.setupCharacterTabs();
                this.updateAllCharacterIndicators();
                this.updateStatsPanel();
                this.animate();
            }

            setupCharacterTabs() {
                // Generate character tabs dynamically based on party composition
                const gameData = localStorage.getItem('gameSkillTreeData');
                const tabsContainer = document.getElementById('character-tabs');

                if (gameData && tabsContainer) {
                    const data = JSON.parse(gameData);

                    // Clear existing tabs
                    tabsContainer.innerHTML = '';

                    // Generate tabs for each character in the party
                    if (data.partyComposition && data.partyComposition.length > 0) {
                        data.partyComposition.forEach((char, index) => {
                            const tab = document.createElement('button');
                            tab.className = 'character-tab' + (char.key === this.currentCharacter ? ' active' : '');
                            tab.setAttribute('data-character', char.key);
                            tab.innerHTML = \`
                                \${char.name}
                                <span class="points-indicator" style="display: none;">0</span>
                            \`;
                            tabsContainer.appendChild(tab);
                        });
                    } else {
                        // Fallback to original 4 characters if no party composition data
                        const defaultChars = [
                            { key: 'tank', name: 'Âù¶ÂÖã' },
                            { key: 'healer', name: 'Ê≤ªÁñóÂ∏à' },
                            { key: 'mage', name: 'Ê≥ïÂ∏à' },
                            { key: 'rogue', name: 'Âà∫ÂÆ¢' }
                        ];
                        defaultChars.forEach(char => {
                            const tab = document.createElement('button');
                            tab.className = 'character-tab' + (char.key === this.currentCharacter ? ' active' : '');
                            tab.setAttribute('data-character', char.key);
                            tab.innerHTML = \`
                                \${char.name}
                                <span class="points-indicator" style="display: none;">0</span>
                            \`;
                            tabsContainer.appendChild(tab);
                        });
                    }
                }

                // Setup click listeners for the generated tabs
                document.querySelectorAll('.character-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        const character = tab.getAttribute('data-character');
                        this.switchCharacter(character);
                    });
                });
            }

            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }

            generateTree() {
                // Color schemes for different node types
                const nodeTypes = {
                    start: {
                        size: 20,
                        color: '#f59e0b',
                        activeColor: '#fbbf24',
                        borderColor: '#92400e'
                    },
                    small: {
                        size: 10,
                        color: '#4a5568',
                        activeColor: '#10b981',
                        borderColor: '#1f2937'
                    },
                    medium: {
                        size: 14,
                        color: '#6366f1',
                        activeColor: '#3b82f6',
                        borderColor: '#312e81'
                    },
                    large: {
                        size: 18,
                        color: '#8b5cf6',
                        activeColor: '#a855f7',
                        borderColor: '#581c87'
                    },
                    keystone: {
                        size: 24,
                        color: '#dc2626',
                        activeColor: '#ef4444',
                        borderColor: '#7f1d1d'
                    },
                    legendary: {
                        size: 16,
                        color: '#f59e0b',
                        activeColor: '#fbbf24',
                        borderColor: '#92400e'
                    }
                };

                // Stat definitions
                const smallStats = [
                    { stats: { dodge: 0.5 }, display: '+0.5% Èó™ÈÅø' },
                    { stats: { hp: 5 }, display: '+5 ÁîüÂëΩÂÄº' },
                    { stats: { attack: 1 }, display: '+1 ÊîªÂáª' },
                    { stats: { defense: 1 }, display: '+1 Èò≤Âæ°' },
                    { stats: { mana: 5 }, display: '+5 Ê≥ïÂäõ' }
                ];

                const mediumStats = [
                    { stats: { attackSpeed: 2 }, display: '+2% ÊîªÂáªÈÄüÂ∫¶' },
                    { stats: { attack: 5 }, display: '+5 ÊîªÂáª' },
                    { stats: { hp: 25 }, display: '+25 ÁîüÂëΩÂÄº' },
                    { stats: { defense: 2.5 }, display: '+2.5 Èò≤Âæ°' },
                    { stats: { mana: 25 }, display: '+25 Ê≥ïÂäõ' },
                    { stats: { manaRegen: 2 }, display: '+2% Ê≥ïÂäõÂõûÂ§ç' },
                    { stats: { hpRegen: 2 }, display: '+2% ÁîüÂëΩÂÄºÂõûÂ§ç' },
                    { stats: { lifesteal: 3 }, display: '+3% Âê∏Ë°Ä' },
                    { stats: { cdr: 2 }, display: '+2% CDR' },
                    { stats: { dodge: 1 }, display: '+1% Èó™ÈÅø' }
                ];

                const largeStats = [
                    { stats: { critChance: 5, critDamage: 6 }, display: '+5% Êö¥Âáª & +6% Êö¥Âáª‰º§ÂÆ≥' },
                    { stats: { hp: 100, defense: 10 }, display: '+100 ÁîüÂëΩÂÄº & +10 Èò≤Âæ°' },
                    { stats: { mana: 100, manaRegen: 5 }, display: '+100 Ê≥ïÂäõ & +5% Ê≥ïÂäõÂõûÂ§ç' },
                    { stats: { attack: 10, attackSpeed: 5 }, display: '+10 ÊîªÂáª & +5% ÊîªÂáªÈÄüÂ∫¶' },
                    { stats: { hp: 250 }, display: '+250 ÁîüÂëΩÂÄº' },
                    { stats: { defense: 20 }, display: '+20 Èò≤Âæ°' },
                    { stats: { dodge: 5 }, display: '+5% Èó™ÈÅø' },
                    { stats: { attack: 35 }, display: '+35 ÊîªÂáª' },
                    { stats: { critDamage: 25 }, display: '+25% Êö¥Âáª‰º§ÂÆ≥' },
                    { stats: { critChance: 10 }, display: '+10% Êö¥ÂáªÂá†Áéá' },
                    { stats: { cdr: 10 }, display: '+10% CDR' },
                    { stats: { lifesteal: 8, attackSpeed: 8 }, display: '+8% Âê∏Ë°Ä & +8% ÊîªÂáªÈÄüÂ∫¶' }
                ];

                const keystoneStats = [
                    { name: 'Tank Keystone Slot', stats: {}, display: 'Ëß£ÈîÅ Âù¶ÂÖã Èí•ÂåôÁü≥ ÊßΩ‰Ωç' },
                    { name: 'Healer Keystone Slot', stats: {}, display: 'Ëß£ÈîÅ Ê≤ªÁñóÂ∏à Èí•ÂåôÁü≥ ÊßΩ‰Ωç' },
                    { name: 'Mage Keystone Slot', stats: {}, display: 'Ëß£ÈîÅ Ê≥ïÂ∏à Èí•ÂåôÁü≥ ÊßΩ‰Ωç' },
                    { name: 'Rogue Keystone Slot', stats: {}, display: 'Ëß£ÈîÅ Âà∫ÂÆ¢ Èí•ÂåôÁü≥ ÊßΩ‰Ωç' }
                ];

                const legendaryStats = [
                    { name: 'Defensive Mastery', stats: { defPerEpic: 5 }, display: '+5 Èò≤Âæ° ÊØè Âè≤ËØó+ Áâ©ÂìÅ' },
                    { name: 'Offensive Mastery', stats: { attPerEpic: 5 }, display: '+5 ÊîªÂáª ÊØè Âè≤ËØó+ Áâ©ÂìÅ' },
                    { name: 'Critical Mastery', stats: { critDmgPerEpic: 5 }, display: '+5% Êö¥Âáª‰º§ÂÆ≥ ÊØè Âè≤ËØó+ Áâ©ÂìÅ' },
                    { name: 'Vitality Mastery', stats: { hpPerEpic: 25 }, display: '+25 ÁîüÂëΩÂÄº ÊØè Âè≤ËØó+ Áâ©ÂìÅ' },
                    { name: 'Arcane Mastery', stats: { manaPerEpic: 25 }, display: '+25 Ê≥ïÂäõ ÊØè Âè≤ËØó+ Áâ©ÂìÅ' }
                ];

                let nodeId = 0;

                // Create center start node
                this.nodes.push({
                    id: nodeId++,
                    x: 0,
                    y: 0,
                    type: 'start',
                    display: 'ÂºÄÂßã',
                    stats: {},
                    cost: 0,
                    ...nodeTypes.start
                });

                // Create 5 main branches with specific themes:
                // Branch 0 (Top): Balanced/Tank path
                // Branch 1 (Top-Right): Attack/DPS path
                // Branch 2 (Bottom-Right): Speed/Crit path
                // Branch 3 (Bottom-Left): Defense/HP path
                // Branch 4 (Top-Left): Magic/Utility path

                const branches = 5;
                const branchAngleStep = (Math.PI * 2) / branches;
                const nodeSpacing = 50;

                for (let branch = 0; branch < branches; branch++) {
                    const baseAngle = branch * branchAngleStep - Math.PI / 2;
                    let currentRadius = 0;
                    let lastNodeId = 0;

                    // First path: 5 small nodes from center - themed per branch
                    for (let i = 1; i <= 5; i++) {
                        currentRadius = i * nodeSpacing;
                        const x = Math.cos(baseAngle) * currentRadius;
                        const y = Math.sin(baseAngle) * currentRadius;

                        // Branch-specific small stat progression
                        let stat;
                        if (branch === 0) { // Balanced
                            stat = [smallStats[2], smallStats[3], smallStats[1], smallStats[0], smallStats[2]][i-1]; // hp, def, atk, dodge, hp
                        } else if (branch === 1) { // Attack
                            stat = [smallStats[2], smallStats[2], smallStats[3], smallStats[2], smallStats[1]][i-1]; // atk, atk, def, atk, hp
                        } else if (branch === 2) { // Speed/Crit
                            stat = [smallStats[0], smallStats[2], smallStats[0], smallStats[3], smallStats[2]][i-1]; // dodge, atk, dodge, def, atk
                        } else if (branch === 3) { // Defense
                            stat = [smallStats[3], smallStats[1], smallStats[3], smallStats[1], smallStats[3]][i-1]; // def, hp, def, hp, def
                        } else { // Magic
                            stat = [smallStats[4], smallStats[1], smallStats[4], smallStats[2], smallStats[4]][i-1]; // mana, hp, mana, atk, mana
                        }

                        const node = {
                            id: nodeId++,
                            x: x,
                            y: y,
                            type: 'small',
                            display: stat.display,
                            stats: stat.stats,
                            cost: 1,
                            ...nodeTypes.small
                        };
                        this.nodes.push(node);
                        this.connections.push({ from: lastNodeId, to: node.id });
                        lastNodeId = node.id;
                    }

                    // Blue (medium) node at fork point - branch-themed
                    currentRadius += nodeSpacing;
                    let mediumStat;
                    if (branch === 0) mediumStat = mediumStats[2]; // hp+25
                    else if (branch === 1) mediumStat = mediumStats[1]; // attack+5
                    else if (branch === 2) mediumStat = mediumStats[0]; // attackSpeed+2%
                    else if (branch === 3) mediumStat = mediumStats[3]; // defense+2.5
                    else mediumStat = mediumStats[4]; // mana+25

                    const forkMedium = {
                        id: nodeId++,
                        x: Math.cos(baseAngle) * currentRadius,
                        y: Math.sin(baseAngle) * currentRadius,
                        type: 'medium',
                        display: mediumStat.display,
                        stats: mediumStat.stats,
                        cost: 1,
                        ...nodeTypes.medium
                    };
                    this.nodes.push(forkMedium);
                    this.connections.push({ from: lastNodeId, to: forkMedium.id });

                    // Left path (purple at end)
                    let leftLastId = forkMedium.id;
                    const leftAngle = baseAngle - 0.4;
                    for (let i = 1; i <= 5; i++) {
                        const radius = currentRadius + (i * nodeSpacing);
                        const x = Math.cos(leftAngle) * radius;
                        const y = Math.sin(leftAngle) * radius;

                        // Left path small nodes - defensive focus
                        let stat;
                        if (branch === 0) stat = smallStats[i % 2 === 0 ? 3 : 1]; // def/hp alternating
                        else if (branch === 1) stat = smallStats[i % 2 === 0 ? 0 : 2]; // dodge/atk
                        else if (branch === 2) stat = smallStats[0]; // all dodge
                        else if (branch === 3) stat = smallStats[1]; // all hp
                        else stat = smallStats[4]; // all mana

                        const node = {
                            id: nodeId++,
                            x: x,
                            y: y,
                            type: 'small',
                            display: stat.display,
                            stats: stat.stats,
                            cost: 1,
                            ...nodeTypes.small
                        };
                        this.nodes.push(node);
                        this.connections.push({ from: leftLastId, to: node.id });
                        leftLastId = node.id;
                    }

                    // Left large node - branch-specific powerful node
                    let leftLargeStat;
                    if (branch === 0) leftLargeStat = largeStats[1]; // hp+100, def+10
                    else if (branch === 1) leftLargeStat = largeStats[11]; // lifesteal+10%, atkspd+10%
                    else if (branch === 2) leftLargeStat = largeStats[0]; // crit+5%, critdmg+10%
                    else if (branch === 3) leftLargeStat = largeStats[4]; // hp+250
                    else leftLargeStat = largeStats[2]; // mana+100, manaregen+5%

                    const leftLarge = {
                        id: nodeId++,
                        x: Math.cos(leftAngle) * (currentRadius + 6 * nodeSpacing),
                        y: Math.sin(leftAngle) * (currentRadius + 6 * nodeSpacing),
                        type: 'large',
                        display: leftLargeStat.display,
                        stats: leftLargeStat.stats,
                        cost: 1,
                        ...nodeTypes.large
                    };
                    this.nodes.push(leftLarge);
                    this.connections.push({ from: leftLastId, to: leftLarge.id });

                    // Middle path (keystone at end)
                    let middleLastId = forkMedium.id;
                    for (let i = 1; i <= 5; i++) {
                        const radius = currentRadius + (i * nodeSpacing);
                        const x = Math.cos(baseAngle) * radius;
                        const y = Math.sin(baseAngle) * radius;

                        // Middle path - balanced progression
                        let stat = smallStats[(branch + i) % smallStats.length];

                        const node = {
                            id: nodeId++,
                            x: x,
                            y: y,
                            type: 'small',
                            display: stat.display,
                            stats: stat.stats,
                            cost: 1,
                            ...nodeTypes.small
                        };
                        this.nodes.push(node);
                        this.connections.push({ from: middleLastId, to: node.id });
                        middleLastId = node.id;
                    }

                    // Rune Slot - all 5 branches get one
const keystone = {
    id: nodeId++,
    x: Math.cos(baseAngle) * (currentRadius + 6 * nodeSpacing),
    y: Math.sin(baseAngle) * (currentRadius + 6 * nodeSpacing),
    type: 'keystone',
    name: 'Rune Slot',
    display: 'Ëß£ÈîÅÁ¨¶ÊñáÊßΩ‰Ωç',
    stats: {},
    cost: 1,
    isRuneSlot: true,
    runeSlotIndex: branch,
    keystoneType: branch < 6 ? ['tank', 'healer', 'mage', 'rogue', 'archer', 'paladin'][branch] : 'universal',
    ...nodeTypes.keystone
};
this.nodes.push(keystone);
this.connections.push({ from: middleLastId, to: keystone.id });

                    // Right path (purple at end)
                    let rightLastId = forkMedium.id;
                    const rightAngle = baseAngle + 0.4;
                    for (let i = 1; i <= 5; i++) {
                        const radius = currentRadius + (i * nodeSpacing);
                        const x = Math.cos(rightAngle) * radius;
                        const y = Math.sin(rightAngle) * radius;

                        // Right path small nodes - offensive focus
                        let stat;
                        if (branch === 0) stat = smallStats[i % 2 === 0 ? 2 : 0]; // atk/dodge
                        else if (branch === 1) stat = smallStats[2]; // all attack
                        else if (branch === 2) stat = smallStats[i % 2 === 0 ? 2 : 0]; // atk/dodge
                        else if (branch === 3) stat = smallStats[3]; // all defense
                        else stat = smallStats[i % 2 === 0 ? 4 : 2]; // mana/atk

                        const node = {
                            id: nodeId++,
                            x: x,
                            y: y,
                            type: 'small',
                            display: stat.display,
                            stats: stat.stats,
                            cost: 1,
                            ...nodeTypes.small
                        };
                        this.nodes.push(node);
                        this.connections.push({ from: rightLastId, to: node.id });
                        rightLastId = node.id;
                    }

                    // Right large node - branch-specific powerful node
                    let rightLargeStat;
                    if (branch === 0) rightLargeStat = largeStats[3]; // atk+25, atkspd+5%
                    else if (branch === 1) rightLargeStat = largeStats[7]; // atk+40
                    else if (branch === 2) rightLargeStat = largeStats[9]; // crit+10%
                    else if (branch === 3) rightLargeStat = largeStats[5]; // def+20
                    else rightLargeStat = largeStats[10]; // cdr+10%

                    const rightLarge = {
                        id: nodeId++,
                        x: Math.cos(rightAngle) * (currentRadius + 6 * nodeSpacing),
                        y: Math.sin(rightAngle) * (currentRadius + 6 * nodeSpacing),
                        type: 'large',
                        display: rightLargeStat.display,
                        stats: rightLargeStat.stats,
                        cost: 1,
                        ...nodeTypes.large
                    };
                    this.nodes.push(rightLarge);
                    this.connections.push({ from: rightLastId, to: rightLarge.id });
                }

                // Connect the keystones in a ring with consistent stats
                const keystones = this.nodes.filter(n => n.type === 'keystone');

                for (let i = 0; i < keystones.length; i++) {
                    const currentKeystone = keystones[i];
                    const nextKeystone = keystones[(i + 1) % keystones.length];

                    const angle1 = Math.atan2(currentKeystone.y, currentKeystone.x);
                    const angle2 = Math.atan2(nextKeystone.y, nextKeystone.x);
                    let angleDiff = angle2 - angle1;
                    if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                    let lastId = currentKeystone.id;
                    const outerRadius = 700;

                    // 5 gray nodes - consistent pattern
                    for (let j = 1; j <= 5; j++) {
                        const t = j / 12;
                        const angle = angle1 + angleDiff * t;
                        const x = Math.cos(angle) * outerRadius;
                        const y = Math.sin(angle) * outerRadius;

                        // Outer ring uses simple pattern
                        const stat = smallStats[j % smallStats.length];

                        const node = {
                            id: nodeId++,
                            x: x,
                            y: y,
                            type: 'small',
                            display: stat.display,
                            stats: stat.stats,
                            cost: 1,
                            ...nodeTypes.small
                        };
                        this.nodes.push(node);
                        this.connections.push({ from: lastId, to: node.id });
                        lastId = node.id;
                    }

                    // Legendary orange node in middle
                    const midAngle = angle1 + angleDiff * 0.5;
                    const legendaryNode = {
                        id: nodeId++,
                        x: Math.cos(midAngle) * 750,
                        y: Math.sin(midAngle) * 750,
                        type: 'legendary',
                        name: legendaryStats[i].name,
                        display: legendaryStats[i].display,
                        stats: legendaryStats[i].stats,
                        cost: 1,
                        ...nodeTypes.legendary
                    };
                    this.nodes.push(legendaryNode);
                    this.connections.push({ from: lastId, to: legendaryNode.id });
                    lastId = legendaryNode.id;

                    // 5 more gray nodes
                    for (let j = 7; j <= 11; j++) {
                        const t = j / 12;
                        const angle = angle1 + angleDiff * t;
                        const x = Math.cos(angle) * outerRadius;
                        const y = Math.sin(angle) * outerRadius;

                        // Mirror the first set pattern
                        const stat = smallStats[(6 - j + 11) % smallStats.length];

                        const node = {
                            id: nodeId++,
                            x: x,
                            y: y,
                            type: 'small',
                            display: stat.display,
                            stats: stat.stats,
                            cost: 1,
                            ...nodeTypes.small
                        };
                        this.nodes.push(node);
                        this.connections.push({ from: lastId, to: node.id });
                        lastId = node.id;
                    }

                    this.connections.push({ from: lastId, to: nextKeystone.id });
                }
            }

            calculateStats() {
                const stats = {};
                let runeSlotCount = 0;

                for (const nodeId of this.allocatedNodes) {
                    const node = this.nodes.find(n => n.id === nodeId);
                    if (node) {
                        // Count rune slots
                        if (node.isRuneSlot) {
                            runeSlotCount++;
                        }

                        // Add regular stats
                        if (node.stats) {
                            for (const [stat, value] of Object.entries(node.stats)) {
                                if (!stats[stat]) {
                                    stats[stat] = 0;
                                }
                                stats[stat] += value;
                            }
                        }
                    }
                }

                // Add rune slot count to stats
                if (runeSlotCount > 0) {
                    stats.runeSlots = runeSlotCount;
                }

                return stats;
            }

            updateStatsPanel() {
                const stats = this.calculateStats();
                const statsContent = document.getElementById('stats-content');

                statsContent.innerHTML = '';

                const statNames = {
                    hp: 'ÁîüÂëΩÂÄº',
                    mana: 'Ê≥ïÂäõÂÄº',
                    attack: 'ÊîªÂáª',
                    defense: 'Èò≤Âæ°',
                    attackSpeed: 'ÊîªÂáªÈÄüÂ∫¶',
                    critChance: 'Êö¥ÂáªÁéá',
                    critDamage: 'Êö¥Âáª‰º§ÂÆ≥',
                    dodge: 'Èó™ÈÅø',
                    lifesteal: 'Âê∏Ë°Ä',
                    manaRegen: 'Ê≥ïÂäõÂõûÂ§ç',
                    hpRegen: 'ÁîüÂëΩÂÄºÂõûÂ§ç',
                    cdr: 'CDR',
                    defPerEpic: 'Èò≤Âæ° ÊØè Âè≤ËØó+',
                    attPerEpic: 'ÊîªÂáª ÊØè Âè≤ËØó+',
                    critDmgPerEpic: 'Êö¥Âáª‰º§ÂÆ≥ ÊØè Âè≤ËØó+',
                    hpPerEpic: 'ÁîüÂëΩÂÄº ÊØè Âè≤ËØó+',
                    manaPerEpic: 'Ê≥ïÂäõÂÄº ÊØè Âè≤ËØó+'
                };

                const hasStats = Object.keys(stats).length > 0;

                if (!hasStats) {
                    statsContent.innerHTML = '<div id="no-stats">Êú™ÂàÜÈÖçÂ±ûÊÄß</div>';
                } else {
                    const sortedStats = Object.entries(stats).sort((a, b) => {
                        if (a[1] < 0 && b[1] >= 0) return 1;
                        if (a[1] >= 0 && b[1] < 0) return -1;
                        return 0;
                    });

                    for (const [stat, value] of sortedStats) {
                        if (value === 0) continue;

                        const row = document.createElement('div');
                        row.className = 'stat-row';

                        const nameSpan = document.createElement('span');
                        nameSpan.className = 'stat-name';
                        nameSpan.textContent = statNames[stat] || stat;

                        const valueSpan = document.createElement('span');
                        valueSpan.className = 'stat-value';
                        if (value < 0) {
                            valueSpan.classList.add('negative');
                        }

                        let displayValue = '';
                        if (stat.includes('PerEpic')) {
                            displayValue = '+' + value;
                        } else if (['attackSpeed', 'critChance', 'critDamage', 'dodge', 'lifesteal', 'manaRegen', 'hpRegen', 'cdr'].includes(stat)) {
                            displayValue = value > 0 ? '+' + value + '%' : value + '%';
                        } else {
                            displayValue = value > 0 ? '+' + value : '' + value;
                        }

                        valueSpan.textContent = displayValue;

                        row.appendChild(nameSpan);
                        row.appendChild(valueSpan);
                        statsContent.appendChild(row);
                    }
                }

                requestAnimationFrame(() => {
                    this.resizeCanvas();
                });

                // Update rune stats panel
                this.updateRuneStatsPanel();
            }

            updateRuneStatsPanel() {
                // Removed - rune slots tracked separately
            }

            canAllocate(nodeId) {
                if (this.allocatedNodes.has(nodeId)) return false;
                const node = this.nodes.find(n => n.id === nodeId);
                if (!node) return false;
                if (this.usedPoints + node.cost > this.skillPoints) return false;

                const hasPath = this.connections.some(c =>
                    (c.from === nodeId && this.allocatedNodes.has(c.to)) ||
                    (c.to === nodeId && this.allocatedNodes.has(c.from))
                );

                return hasPath;
            }

            allocateNode(nodeId) {
                if (!this.canAllocate(nodeId)) return false;

                const node = this.nodes.find(n => n.id === nodeId);
                this.allocatedNodes.add(nodeId);
                this.usedPoints += node.cost;
                this.updatePointsDisplay();
                this.updateStatsPanel();
                return true;
            }

            deallocateNode(nodeId) {
                if (nodeId === 0) return false;
                if (!this.allocatedNodes.has(nodeId)) return false;

                const tempAllocated = new Set(this.allocatedNodes);
                tempAllocated.delete(nodeId);

                const visited = new Set();
                const queue = [0];
                visited.add(0);

                while (queue.length > 0) {
                    const current = queue.shift();
                    this.connections.forEach(c => {
                        let neighbor = null;
                        if (c.from === current && tempAllocated.has(c.to)) neighbor = c.to;
                        if (c.to === current && tempAllocated.has(c.from)) neighbor = c.from;

                        if (neighbor && !visited.has(neighbor)) {
                            visited.add(neighbor);
                            queue.push(neighbor);
                        }
                    });
                }

                if (visited.size === tempAllocated.size) {
                    const node = this.nodes.find(n => n.id === nodeId);

                    // Check if this is a rune slot node being deallocated
                    if (node.isRuneSlot) {
                        // Get game data to unequip runes
                        const gameData = localStorage.getItem('gameSkillTreeData');
                        if (gameData) {
                            const data = JSON.parse(gameData);

                            // FIX: Use partyComposition to get correct character class
                            const currentCharIndex = parseInt(localStorage.getItem('currentCharacterIndex') || '0');
                            const charKey = data.partyComposition && data.partyComposition[currentCharIndex]
                                ? data.partyComposition[currentCharIndex].key
                                : null;

                            if (!charKey) {
                                console.error('Could not determine character class from party composition');
                                return;
                            }

                            // Count how many rune slot nodes will remain allocated after this deallocation
                            let remainingRuneSlots = 0;
                            tempAllocated.forEach(allocNodeId => {
                                const allocNode = this.nodes.find(n => n.id === allocNodeId);
                                if (allocNode && allocNode.isRuneSlot) {
                                    remainingRuneSlots++;
                                }
                            });

                            // Store info about which rune slots should be locked
                            const runeSlotLockInfo = {
                                character: charKey,
                                remainingSlots: remainingRuneSlots
                            };
                            localStorage.setItem('runeSlotLockInfo', JSON.stringify(runeSlotLockInfo));
                        }
                    }

                    this.allocatedNodes.delete(nodeId);
                    this.usedPoints -= node.cost;
                    this.updatePointsDisplay();
                    this.updateStatsPanel();
                    return true;
                }

                return false;
            }

            switchCharacter(character) {
                // Save current character's data including available points
                this.characters[this.currentCharacter] = {
                    allocatedNodes: new Set(this.allocatedNodes),
                    usedPoints: this.usedPoints,
                    availablePoints: this.skillPoints - this.usedPoints
                };

                // Load new character's data
                this.currentCharacter = character;
                this.allocatedNodes = new Set(this.characters[character].allocatedNodes);
                this.usedPoints = this.characters[character].usedPoints;

                // Load the correct skill points for this character from game data
                const gameData = localStorage.getItem('gameSkillTreeData');
                if (gameData) {
                    const data = JSON.parse(gameData);
                    if (data.characters[character] && data.characters[character].level) {
                        // Total skill points should equal the character's level
                        this.skillPoints = data.characters[character].level;
                    } else {
                        // Fallback: if no level data, calculate from available + used (but cap it)
                        this.skillPoints = Math.min(100, (data.characters[character].availablePoints || 0) + this.usedPoints);
                    }
                }

                document.querySelectorAll('.character-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelector('[data-character="' + character + '"]').classList.add('active');

                this.updatePointsDisplay();
                this.updateStatsPanel();
                this.updateAllCharacterIndicators();
            }

            updateAllCharacterIndicators() {
                document.querySelectorAll('.character-tab').forEach(tab => {
                    const char = tab.getAttribute('data-character');
                    const indicator = tab.querySelector('.points-indicator');
                    const points = this.characters[char].usedPoints;

                    if (points > 0) {
                        indicator.style.display = 'flex';
                        indicator.textContent = points;
                    } else {
                        indicator.style.display = 'none';
                    }
                });
            }

            saveToLocalStorage() {
                this.characters[this.currentCharacter] = {
                    allocatedNodes: new Set(this.allocatedNodes),
                    usedPoints: this.usedPoints,
                    availablePoints: this.skillPoints - this.usedPoints
                };

                // Get level data from game data
                const gameData = localStorage.getItem('gameSkillTreeData');
                let levelData = {};
                if (gameData) {
                    const data = JSON.parse(gameData);
                    for (const char in data.characters) {
                        if (data.characters[char] && data.characters[char].level) {
                            levelData[char] = data.characters[char].level;
                        }
                    }
                }

                const saveData = {
                    characters: {}
                };

                for (const char in this.characters) {
                    // Calculate the total stats for this character
const totalStats = {};
let runeSlotCount = 0;
for (const nodeId of this.characters[char].allocatedNodes) {
    const node = this.nodes.find(n => n.id === nodeId);
    if (node) {
        // Count rune slots
        if (node.isRuneSlot) {
            runeSlotCount++;
        }
        // Count regular stats
        if (node.stats) {
            for (const [stat, value] of Object.entries(node.stats)) {
                totalStats[stat] = (totalStats[stat] || 0) + value;
            }
        }
    }
}
totalStats.runeSlots = runeSlotCount;

                    saveData.characters[char] = {
                        allocatedNodes: Array.from(this.characters[char].allocatedNodes),
                        usedPoints: this.characters[char].usedPoints,
                        availablePoints: this.characters[char].availablePoints || (this.skillPoints - this.characters[char].usedPoints),
                        totalStats: totalStats, // Store the calculated stats
                        level: levelData[char] || null // Store character level
                    };
                }

                localStorage.setItem('skillTreeData', JSON.stringify(saveData));

                const notification = document.getElementById('save-notification');
                notification.classList.add('show');
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 2000);
            }

            updatePointsDisplay() {
                document.getElementById('skill-points').textContent =
                    'ÊäÄËÉΩÁÇπÊï∞: ' + (this.skillPoints - this.usedPoints) + ' / ' + this.skillPoints;
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;

                    this.mouse.worldX = (this.mouse.x - this.canvas.width/2) / this.camera.zoom - this.camera.x;
                    this.mouse.worldY = (this.mouse.y - this.canvas.height/2) / this.camera.zoom - this.camera.y;

                    if (this.mouse.dragging) {
                        this.camera.x = (this.mouse.x - this.mouse.dragStartX) / this.camera.zoom + this.camera.startX;
                        this.camera.y = (this.mouse.y - this.mouse.dragStartY) / this.camera.zoom + this.camera.startY;
                    } else {
                        let hoveredNode = null;
                        for (const node of this.nodes) {
                            const dist = Math.sqrt(
                                Math.pow(node.x - this.mouse.worldX, 2) +
                                Math.pow(node.y - this.mouse.worldY, 2)
                            );
                            if (dist < node.size) {
                                hoveredNode = node;
                                break;
                            }
                        }

                        if (hoveredNode) {
                            this.showTooltip(hoveredNode, e.clientX, e.clientY);
                        } else {
                            this.tooltip.classList.remove('show');
                        }
                    }
                });

                this.canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 0) {
                        let clickedNode = null;
                        for (const node of this.nodes) {
                            const dist = Math.sqrt(
                                Math.pow(node.x - this.mouse.worldX, 2) +
                                Math.pow(node.y - this.mouse.worldY, 2)
                            );
                            if (dist < node.size) {
                                clickedNode = node;
                                break;
                            }
                        }

                        if (clickedNode) {
                            this.allocateNode(clickedNode.id);
                        } else {
                            this.mouse.dragging = true;
                            this.mouse.dragStartX = this.mouse.x;
                            this.mouse.dragStartY = this.mouse.y;
                            this.camera.startX = this.camera.x;
                            this.camera.startY = this.camera.y;
                            this.canvas.style.cursor = 'grabbing';
                        }
                    }
                });

                this.canvas.addEventListener('mouseup', (e) => {
                    if (e.button === 0) {
                        this.mouse.dragging = false;
                        this.canvas.style.cursor = 'grab';
                    }
                });

                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();

                    for (const node of this.nodes) {
                        const dist = Math.sqrt(
                            Math.pow(node.x - this.mouse.worldX, 2) +
                            Math.pow(node.y - this.mouse.worldY, 2)
                        );
                        if (dist < node.size) {
                            this.deallocateNode(node.id);
                            break;
                        }
                    }
                });

                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomSpeed = 0.1;
                    const delta = e.deltaY > 0 ? -zoomSpeed : zoomSpeed;
                    this.camera.zoom = Math.max(0.3, Math.min(2, this.camera.zoom + delta));
                });

               document.getElementById('save-btn').addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    viewer.saveToLocalStorage();

                    // Show save notification
                    const notification = document.getElementById('save-notification');
                    if (notification) {
                        notification.classList.add('show');
                        setTimeout(() => {
                            notification.classList.remove('show');
                        }, 2000);
                    }
                });

                // Use direct onclick instead of addEventListener for reliability
                const closeButton = document.getElementById('close-circle-btn');
if (closeButton) {
    closeButton.onclick = function(e) {
        e.preventDefault();
        e.stopPropagation();
        viewer.saveToLocalStorage();
        localStorage.setItem('skillTreeCloseRequested', 'true');
        return false;
    };
}

                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                });
            }

            showTooltip(node, clientX, clientY) {
                let html = '<div class="tooltip-header" style="color: ' + node.activeColor + '">' + (node.name || node.display) + '</div>';
                html += '<div class="tooltip-stats">' + node.display + '</div>';
                if (node.cost > 0) {
                    html += '<div class="tooltip-cost">ÊàêÊú¨: ' + node.cost + ' ÁÇπÊï∞' + (node.cost > 1 ? 's' : '') + '</div>';
                }

                this.tooltip.innerHTML = html;
                this.tooltip.classList.add('show');

                // Get canvas position to calculate relative coordinates
                const canvasRect = this.canvas.getBoundingClientRect();
                const tooltipRect = this.tooltip.getBoundingClientRect();

                // Calculate position relative to the canvas container
                const x = clientX - canvasRect.left;
                const y = clientY - canvasRect.top;

                const maxX = canvasRect.width - tooltipRect.width - 10;
                const maxY = canvasRect.height - tooltipRect.height - 10;

                this.tooltip.style.left = Math.min(Math.max(x + 10, 10), maxX) + 'px';
                this.tooltip.style.top = Math.min(Math.max(y + 10, 10), maxY) + 'px';
            }

            draw() {
                const ctx = this.ctx;
                const width = this.canvas.width;
                const height = this.canvas.height;

                ctx.fillStyle = '#0a0e27';
                ctx.fillRect(0, 0, width, height);

                ctx.save();
                ctx.translate(width/2, height/2);
                ctx.scale(this.camera.zoom, this.camera.zoom);
                ctx.translate(this.camera.x, this.camera.y);

                ctx.strokeStyle = 'rgba(99, 102, 241, 0.05)';
                ctx.lineWidth = 1;
                for (let x = -1000; x <= 1000; x += 100) {
                    ctx.beginPath();
                    ctx.moveTo(x, -1000);
                    ctx.lineTo(x, 1000);
                    ctx.stroke();
                }
                for (let y = -1000; y <= 1000; y += 100) {
                    ctx.beginPath();
                    ctx.moveTo(-1000, y);
                    ctx.lineTo(1000, y);
                    ctx.stroke();
                }

                ctx.lineCap = 'round';
                this.connections.forEach(conn => {
                    const fromNode = this.nodes.find(n => n.id === conn.from);
                    const toNode = this.nodes.find(n => n.id === conn.to);

                    if (!fromNode || !toNode) return;

                    const fromAllocated = this.allocatedNodes.has(fromNode.id);
                    const toAllocated = this.allocatedNodes.has(toNode.id);
                    const pathActive = fromAllocated && toAllocated;

                    ctx.strokeStyle = pathActive ? 'rgba(16, 185, 129, 0.8)' : 'rgba(71, 85, 105, 0.3)';
                    ctx.lineWidth = pathActive ? 3 : 2;

                    ctx.beginPath();
                    ctx.moveTo(fromNode.x, fromNode.y);
                    ctx.lineTo(toNode.x, toNode.y);
                    ctx.stroke();
                });

                this.nodes.forEach(node => {
                    const allocated = this.allocatedNodes.has(node.id);
                    const canAllocate = this.canAllocate(node.id);

                    if (allocated || canAllocate) {
                        const gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, node.size * 2);
                        gradient.addColorStop(0, allocated ? node.activeColor + '40' : 'rgba(99, 102, 241, 0.2)');
                        gradient.addColorStop(1, 'transparent');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, node.size * 2, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.strokeStyle = allocated ? node.activeColor : node.borderColor;
                    ctx.lineWidth = allocated ? 3 : 2;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.size, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.fillStyle = allocated ? node.activeColor : node.color;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.size - 2, 0, Math.PI * 2);
                    ctx.fill();

                    if (node.type === 'keystone') {
                        ctx.strokeStyle = allocated ? '#fff' : 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, node.size - 6, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                });

                ctx.restore();
            }

            animate() {
                if (this.destroyed) return;
                this.draw();
                this._animFrameId = requestAnimationFrame(() => this.animate());
            }

            stopAnimation() {
                this.destroyed = true;
                if (this._animFrameId) {
                    cancelAnimationFrame(this._animFrameId);
                    this._animFrameId = null;
                }
            }
        }

        const viewer = new SkillTreeViewer();

        // Position the invisible overlay button exactly over the close button
        setTimeout(() => {
            const closeBtn = document.getElementById('close-btn');
            const overlay = document.getElementById('close-overlay');

            if (closeBtn && overlay) {
                const rect = closeBtn.getBoundingClientRect();
                overlay.style.position = 'fixed';
                overlay.style.left = rect.left + 'px';
                overlay.style.top = rect.top + 'px';
                overlay.style.width = rect.width + 'px';
                overlay.style.height = rect.height + 'px';
                overlay.style.border = 'none';
                overlay.style.background = 'transparent';

                // Add the working close function to the overlay
                overlay.onclick = function(e) {
                    e.preventDefault();
                    viewer.saveToLocalStorage();
                    localStorage.setItem('skillTreeCloseRequested', 'true');
                };
            }
        }, 100);

        // Update position if window resizes
        window.addEventListener('resize', () => {
            const closeBtn = document.getElementById('close-btn');
            const overlay = document.getElementById('close-overlay');

            if (closeBtn && overlay) {
                const rect = closeBtn.getBoundingClientRect();
                overlay.style.left = rect.left + 'px';
                overlay.style.top = rect.top + 'px';
                overlay.style.width = rect.width + 'px';
                overlay.style.height = rect.height + 'px';
            }
        });

        // Ensure DOM is fully loaded before attaching events
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupButtonEvents);
        } else {
            setupButtonEvents();
        }

        function setupButtonEvents() {
            const saveBtn = document.getElementById('save-btn');
            const closeBtn = document.getElementById('close-btn');

            if (saveBtn) {
                saveBtn.onclick = function(e) {
                    e.preventDefault();
                    viewer.saveToLocalStorage();

                    const notification = document.getElementById('save-notification');
                    if (notification) {
                        notification.classList.add('show');
                        setTimeout(() => {
                            notification.classList.remove('show');
                        }, 2000);
                    }
                };
            }

            const closeCircleBtn = document.getElementById('close-circle-btn');
if (closeCircleBtn) {
    closeCircleBtn.onclick = function(e) {
        e.preventDefault();
        e.stopPropagation();
        viewer.saveToLocalStorage();
        localStorage.setItem('skillTreeCloseRequested', 'true');
    };
}
        }
    </` + `script>
</body>
</html>`;
}

            handleSkillTreeMessage(event) {
                if (event.data && event.data.action === 'closeSkillTree') {
                    this.closeSkillTree();
                }
            }

            openSkillTree(characterIndex) {
    if (this.skillTreeOpen) return;

    this.skillTreeOpen = true;
    this.currentSkillTreeCharacter = characterIndex;
    this.paused = true;

    // Create overlay container
    const overlay = document.createElement('div');
    overlay.id = 'skill-tree-overlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.95);
        z-index: 3000;
        display: flex;
        justify-content: center;
        align-items: center;
    `;

    // Create modal container
    const modal = document.createElement('div');
    modal.style.cssText = `
        width: 90%;
        height: 90%;
        max-width: 1400px;
        max-height: 900px;
        background: linear-gradient(135deg, #0a0e27 0%, #151935 100%);
        border-radius: 20px;
        border: 2px solid rgba(99, 102, 241, 0.5);
        overflow: hidden;
        display: flex;
        flex-direction: column;
        position: relative;
    `;

    // Create close button
const closeBtn = document.createElement('button');
closeBtn.textContent = '‚úï';
closeBtn.style.cssText = `
    position: absolute;
    top: 20px;
    right: 20px;
    width: 54px;
    height: 54px;
    background: rgba(239, 68, 68, 0.2);
    border: 2px solid #ef4444;
    border-radius: 50%;
    color: #ef4444;
    font-size: 28px;
    cursor: pointer;
    z-index: 3001;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
`;
    closeBtn.onmouseover = () => {
        closeBtn.style.background = 'rgba(239, 68, 68, 0.4)';
        closeBtn.style.transform = 'scale(1.1)';
    };
    closeBtn.onmouseout = () => {
        closeBtn.style.background = 'rgba(239, 68, 68, 0.2)';
        closeBtn.style.transform = 'scale(1)';
    };
    closeBtn.onclick = () => this.closeSkillTree();

    modal.appendChild(closeBtn);

// Create iframe for the actual skill tree
    const iframe = document.createElement('iframe');
    iframe.id = 'skill-tree-iframe';
    iframe.style.cssText = `
        width: 100%;
        height: 100%;
        border: none;
        background: #0a0e27;
    `;

    // Store game data for skill tree
    // FIX: Use member.className.toLowerCase() instead of hardcoded party order
    const charDisplayNames = {
        tank: 'Tank',
        healer: 'Healer',
        mage: 'Mage',
        rogue: 'Rogue',
        archer: 'Archer',
        paladin: 'Paladin'
    };

    const gameData = {
        characters: {},
        partyComposition: []
    };

    this.party.forEach((member, idx) => {
        const charKey = member.className.toLowerCase();
        gameData.characters[charKey] = {
            allocatedNodes: Array.from(member.skillTreeData?.allocatedNodes || new Set([0])),
            usedPoints: member.skillTreeData?.usedPoints || 0,
            availablePoints: member.skillPoints,
            level: member.level // Add character level for proper skill point calculation
        };

        // Add to party composition with proper display name
        gameData.partyComposition.push({
            key: charKey,
            name: member.name || charDisplayNames[charKey] || member.className
        });
    });

    localStorage.setItem('gameSkillTreeData', JSON.stringify(gameData));
    localStorage.setItem('currentCharacterIndex', characterIndex.toString());

    // Set up message handler for iframe communication
    this._messageHandler = (event) => {
        if (event.data === 'closeSkillTree') {
            this.closeSkillTree();
        } else if (event.data && event.data.type === 'updateSkillTree') {
            // Update character data from skill tree
            const updatedData = JSON.parse(localStorage.getItem('skillTreeData'));
            if (updatedData && updatedData.characters) {
                this.party.forEach((member, idx) => {
                    const charKey = charNames[idx];
                    if (updatedData.characters[charKey]) {
                        member.skillTreeData = {
                            allocatedNodes: new Set(updatedData.characters[charKey].allocatedNodes || [0]),
                            usedPoints: updatedData.characters[charKey].usedPoints || 0
                        };
                        member.skillPoints = updatedData.characters[charKey].availablePoints || 0;
                    }
                });
            }
        }
    };
    window.addEventListener('message', this._messageHandler);

    // Add iframe to modal first
    modal.appendChild(iframe);

    // Add modal to overlay and overlay to document
    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    // Now write the content after iframe is in the DOM
    setTimeout(() => {
        const doc = iframe.contentDocument || iframe.contentWindow.document;
        doc.open();
        doc.write(this.getSkillTreeHTML());
        doc.close();

        // Set up close monitoring after content is loaded
        this._closeCheckInterval = setInterval(() => {
            if (localStorage.getItem('skillTreeCloseRequested') === 'true') {
                localStorage.removeItem('skillTreeCloseRequested');
                this.closeSkillTree();
            }
        }, 100);
    }, 10);



    // Add ESC key listener
    this._escKeyHandler = (e) => {
        if (e.key === 'Escape') {
            this.closeSkillTree();
        }
    };
    document.addEventListener('keydown', this._escKeyHandler);
}

            closeSkillTree() {
    const overlay = document.getElementById('skill-tree-overlay');
    if (overlay) {
        // Clean up iframe properly to prevent memory leak
        const iframe = overlay.querySelector('iframe');
        if (iframe && iframe.contentWindow) {
            try {
                iframe.contentWindow.document.write('');
                iframe.contentWindow.close();
            } catch (e) {
                // Cross-origin restriction, just remove
            }
        }
        overlay.remove();
    }

    this.skillTreeOpen = false;
    this.paused = false;

    // Load updated skill tree data and apply stats
    // FIX: Use member.className.toLowerCase() instead of hardcoded party order
    const savedData = localStorage.getItem('skillTreeData');
    if (savedData) {
        try {
            const data = JSON.parse(savedData);
            this.party.forEach((member, idx) => {
                const charKey = member.className.toLowerCase();
                if (data.characters && data.characters[charKey]) {
                    member.skillTreeData = {
                        allocatedNodes: new Set(data.characters[charKey].allocatedNodes || [0]),
                        usedPoints: data.characters[charKey].usedPoints || 0
                    };
                    member.skillPoints = data.characters[charKey].availablePoints || 0;

                    // Apply skill tree stats - this now properly recalculates max HP/Mana
                    this.applySkillTreeStats(member);

                    // Count and unlock rune slots based on allocated nodes
                    let runeSlotCount = 0;
                    if (data.characters[charKey].totalStats) {
                        runeSlotCount = data.characters[charKey].totalStats.runeSlots || 0;
                    }

                    // Update rune slots for this character
                    for (let i = 0; i < 5; i++) {
                        if (i < runeSlotCount) {
                            this.runeSlots[charKey][i] = true;
                        } else {
                            // Lock slot and unequip if needed
                            if (this.runeSlots[charKey][i] && this.equippedRunes[charKey][i]) {
                                const rune = this.equippedRunes[charKey][i];
                                this.equippedRunes[charKey][i] = null;
                                this.runes.push(rune);
                                this.addLog(`${rune.name} unequipped due to skill tree change`, 'loot');

                                // Remove rune stats from character
                                if (rune.stats) {
                                    const hpPercent = member.hp / member.maxHp;
                                    const manaPercent = member.mana / member.maxMana;

                                    for (const [stat, value] of Object.entries(rune.stats)) {
                                        if (stat === 'hp') member.maxHp -= value;
                                        else if (stat === 'mana') member.maxMana -= value;
                                        else if (stat === 'attack') member.attack -= value;
                                        else if (stat === 'defense') member.defense -= value;
                                        else if (stat === 'attackSpeed') member.attackSpeed -= value / 100;
                                        else if (stat === 'critChance') member.critChance -= value;
                                        else if (stat === 'critDamage') member.critDamage -= value;
                                        else if (stat === 'dodge') member.dodgeChance -= value;
                                        else if (stat === 'lifesteal') member.lifesteal -= value;
                                        else if (stat === 'hpRegen') member.hpRegen -= value;
                                        else if (stat === 'manaRegen') member.manaRegen -= value;
                                        else if (stat === 'cdr') member.cdr -= value;
                                    }

                                    member.hp = Math.floor(member.maxHp * hpPercent);
                                    member.mana = Math.floor(member.maxMana * manaPercent);
                                }
                            }
                            this.runeSlots[charKey][i] = false;
                        }
                    }
                }
            });
        } catch (e) {
            console.error('Error loading skill tree data:', e);
        }
    }

                // Remove ESC key listener
                if (this._escKeyHandler) {
                    document.removeEventListener('keydown', this._escKeyHandler);
                    this._escKeyHandler = null;
                }

                // Remove message handler
                if (this._messageHandler) {
                    window.removeEventListener('message', this._messageHandler);
                    this._messageHandler = null;
                }

                // Clear any intervals
                if (this._closeCheckInterval) {
                    clearInterval(this._closeCheckInterval);
                    this._closeCheckInterval = null;
                }

                // Clean up localStorage
                localStorage.removeItem('skillTreeCloseRequested');
                localStorage.removeItem('gameSkillTreeData');
                localStorage.removeItem('currentCharacterIndex');

                // Update UI to reflect any changes
                this.updateUI();
                this.rebuildUI();
            }

            initializeSkillTree(canvas, tooltip, characterIndex) {
                const ctx = canvas.getContext('2d');
                const member = this.party[characterIndex];

                // Set canvas size
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;

                // Camera state
                const camera = {
                    x: 0,
                    y: 0,
                    zoom: 0.8
                };

                // Mouse state
                const mouse = {
                    x: 0,
                    y: 0,
                    worldX: 0,
                    worldY: 0,
                    dragging: false,
                    dragStartX: 0,
                    dragStartY: 0
                };

                // Initialize allocated nodes from member
                if (!member.allocatedNodes) {
                    member.allocatedNodes = new Set([0]);
                }
                const allocatedNodes = member.allocatedNodes;

                // Generate skill tree structure
                const nodes = [];
                const connections = [];

                // Node types with visual properties
                const nodeTypes = {
                    start: { size: 20, color: '#f59e0b', activeColor: '#fbbf24', borderColor: '#92400e' },
                    small: { size: 12, color: '#4a5568', activeColor: '#10b981', borderColor: '#1f2937' },
                    medium: { size: 16, color: '#6366f1', activeColor: '#3b82f6', borderColor: '#312e81' },
                    large: { size: 20, color: '#8b5cf6', activeColor: '#a855f7', borderColor: '#581c87' },
                    keystone: { size: 24, color: '#dc2626', activeColor: '#ef4444', borderColor: '#7f1d1d' }
                };

                // Create center start node
                nodes.push({
                    id: 0,
                    x: 0,
                    y: 0,
                    type: 'start',
                    display: 'ÂºÄÂßã',
                    stats: {},
                    cost: 0,
                    ...nodeTypes.start
                });

                // Generate branches
                const branches = 5;
                const angleStep = (Math.PI * 2) / branches;
                let nodeId = 1;

                for (let branch = 0; branch < branches; branch++) {
                    const angle = branch * angleStep - Math.PI / 2;
                    let lastNodeId = 0;

                    // Create branch path
                    for (let i = 1; i <= 8; i++) {
                        const radius = i * 60;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;

                        let nodeType = 'small';
                        let stats = {};
                        let display = '';

                        if (i === 4) {
                            nodeType = 'medium';
                            stats = { attack: 5 };
                            display = '+5 Attack';
                        } else if (i === 8) {
                            nodeType = 'keystone';
                            stats = { attack: 10, defense: -5 };
                            display = '+10 Atk, -5 Def';
                        } else {
                            stats = { hp: 10 };
                            display = '+10 HP';
                        }

                        const node = {
                            id: nodeId++,
                            x: x,
                            y: y,
                            type: nodeType,
                            display: display,
                            stats: stats,
                            cost: 1,
                            ...nodeTypes[nodeType]
                        };

                        nodes.push(node);
                        connections.push({ from: lastNodeId, to: node.id });
                        lastNodeId = node.id;
                    }
                }

                // Draw function
                const draw = () => {
                    ctx.fillStyle = '#0a0e27';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    ctx.save();
                    ctx.translate(canvas.width/2, canvas.height/2);
                    ctx.scale(camera.zoom, camera.zoom);
                    ctx.translate(camera.x, camera.y);

                    // Draw connections
                    connections.forEach(conn => {
                        const fromNode = nodes.find(n => n.id === conn.from);
                        const toNode = nodes.find(n => n.id === conn.to);

                        if (!fromNode || !toNode) return;

                        const fromAllocated = allocatedNodes.has(fromNode.id);
                        const toAllocated = allocatedNodes.has(toNode.id);
                        const pathActive = fromAllocated && toAllocated;

                        ctx.strokeStyle = pathActive ? 'rgba(16, 185, 129, 0.8)' : 'rgba(71, 85, 105, 0.3)';
                        ctx.lineWidth = pathActive ? 3 : 2;

                        ctx.beginPath();
                        ctx.moveTo(fromNode.x, fromNode.y);
                        ctx.lineTo(toNode.x, toNode.y);
                        ctx.stroke();
                    });

                    // Draw nodes
                    nodes.forEach(node => {
                        const allocated = allocatedNodes.has(node.id);
                        const canAllocate = member.skillPoints > 0 && connections.some(c =>
                            (c.from === node.id && allocatedNodes.has(c.to)) ||
                            (c.to === node.id && allocatedNodes.has(c.from))
                        ) && !allocated;

                        // Glow effect
                        if (allocated || canAllocate) {
                            const gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, node.size * 2);
                            gradient.addColorStop(0, allocated ? node.activeColor + '40' : 'rgba(99, 102, 241, 0.2)');
                            gradient.addColorStop(1, 'transparent');
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(node.x, node.y, node.size * 2, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // Node border
                        ctx.strokeStyle = allocated ? node.activeColor : node.borderColor;
                        ctx.lineWidth = allocated ? 3 : 2;
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, node.size, 0, Math.PI * 2);
                        ctx.stroke();

                        // Node fill
                        ctx.fillStyle = allocated ? node.activeColor : node.color;
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, node.size - 2, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    ctx.restore();
                };

                // Update stats display
                const updateStatsDisplay = () => {
                    const statsEl = document.getElementById('stats-list');
                    const pointsEl = document.getElementById('skill-points-display');

                    pointsEl.textContent = member.skillPoints;

                    const totalStats = {};
                    allocatedNodes.forEach(nodeId => {
                        const node = nodes.find(n => n.id === nodeId);
                        if (node && node.stats) {
                            Object.entries(node.stats).forEach(([stat, value]) => {
                                totalStats[stat] = (totalStats[stat] || 0) + value;
                            });
                        }
                    });

                    if (Object.keys(totalStats).length === 0) {
                        statsEl.innerHTML = 'No nodes allocated';
                    } else {
                        const statNames = { hp: 'HP', attack: 'Attack', defense: 'Defense' };
                        statsEl.innerHTML = Object.entries(totalStats)
                            .map(([stat, value]) => `
                                <div style="display: flex; justify-content: space-between; margin: 2px 0;">
                                    <span>${statNames[stat] || stat}:</span>
                                    <span style="color: ${value >= 0 ? '#10b981' : '#ef4444'}; font-weight: 600;">
                                        ${value >= 0 ? '+' : ''}${value}
                                    </span>
                                </div>
                            `).join('');
                    }
                };

                // Mouse event handlers
                canvas.addEventListener('mousemove', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    mouse.x = e.clientX - rect.left;
                    mouse.y = e.clientY - rect.top;

                    mouse.worldX = (mouse.x - canvas.width/2) / camera.zoom - camera.x;
                    mouse.worldY = (mouse.y - canvas.height/2) / camera.zoom - camera.y;

                    if (mouse.dragging) {
                        camera.x = (mouse.x - mouse.dragStartX) / camera.zoom + camera.startX;
                        camera.y = (mouse.y - mouse.dragStartY) / camera.zoom + camera.startY;
                        canvas.style.cursor = 'grabbing';
                    } else {
                        // Check for hovered node
                        let hoveredNode = null;
                        for (const node of nodes) {
                            const dist = Math.sqrt(
                                Math.pow(node.x - mouse.worldX, 2) +
                                Math.pow(node.y - mouse.worldY, 2)
                            );
                            if (dist < node.size) {
                                hoveredNode = node;
                                break;
                            }
                        }

                        if (hoveredNode) {
                            tooltip.innerHTML = `
                                <div style="font-weight: 700; margin-bottom: 8px; color: ${hoveredNode.activeColor}">
                                    ${hoveredNode.display}
                                </div>
                                ${hoveredNode.cost > 0 ? `<div style="color: #f59e0b;">Cost: ${hoveredNode.cost} point</div>` : ''}
                            `;
                            tooltip.style.display = 'block';
                            tooltip.style.left = `${mouse.x + 15}px`;
                            tooltip.style.top = `${mouse.y + 15}px`;
                            canvas.style.cursor = 'pointer';
                        } else {
                            tooltip.style.display = 'none';
                            canvas.style.cursor = 'grab';
                        }
                    }
                });

                canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // Left click
                        let clickedNode = null;
                        for (const node of nodes) {
                            const dist = Math.sqrt(
                                Math.pow(node.x - mouse.worldX, 2) +
                                Math.pow(node.y - mouse.worldY, 2)
                            );
                            if (dist < node.size) {
                                clickedNode = node;
                                break;
                            }
                        }

                        if (clickedNode) {
                            // Try to allocate node
                            if (!allocatedNodes.has(clickedNode.id) && member.skillPoints >= clickedNode.cost) {
                                const hasPath = connections.some(c =>
                                    (c.from === clickedNode.id && allocatedNodes.has(c.to)) ||
                                    (c.to === clickedNode.id && allocatedNodes.has(c.from))
                                );

                                if (hasPath) {
                                    allocatedNodes.add(clickedNode.id);
                                    member.skillPoints -= clickedNode.cost;

                                    // Apply stats to member
                                    if (clickedNode.stats) {
                                        Object.entries(clickedNode.stats).forEach(([stat, value]) => {
                                            if (stat === 'hp') member.maxHp += value;
                                            else if (stat === 'attack') member.attack += value;
                                            else if (stat === 'defense') member.defense += value;
                                        });
                                    }

                                    updateStatsDisplay();
                                }
                            }
                        } else {
                            // Start dragging
                            mouse.dragging = true;
                            mouse.dragStartX = mouse.x;
                            mouse.dragStartY = mouse.y;
                            camera.startX = camera.x;
                            camera.startY = camera.y;
                        }
                    }
                });

                canvas.addEventListener('mouseup', () => {
                    mouse.dragging = false;
                    canvas.style.cursor = 'grab';
                });

                canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();

                    // Right click to deallocate
                    for (const node of nodes) {
                        const dist = Math.sqrt(
                            Math.pow(node.x - mouse.worldX, 2) +
                            Math.pow(node.y - mouse.worldY, 2)
                        );
                        if (dist < node.size) {
                            if (node.id !== 0 && allocatedNodes.has(node.id)) {
                                // Check if removing would break the tree
                                const tempAllocated = new Set(allocatedNodes);
                                tempAllocated.delete(node.id);

                                // Simple connectivity check
                                let canRemove = true;
                                tempAllocated.forEach(nodeId => {
                                    if (nodeId === 0) return;
                                    const hasConnection = connections.some(c =>
                                        (c.from === nodeId && tempAllocated.has(c.to)) ||
                                        (c.to === nodeId && tempAllocated.has(c.from))
                                    );
                                    if (!hasConnection) canRemove = false;
                                });

                                if (canRemove) {
                                    allocatedNodes.delete(node.id);
                                    member.skillPoints += node.cost;

                                    // Remove stats from member
                                    if (node.stats) {
                                        Object.entries(node.stats).forEach(([stat, value]) => {
                                            if (stat === 'hp') member.maxHp -= value;
                                            else if (stat === 'attack') member.attack -= value;
                                            else if (stat === 'defense') member.defense -= value;
                                        });
                                    }

                                    updateStatsDisplay();
                                }
                            }
                            break;
                        }
                    }
                });

                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomSpeed = 0.1;
                    const delta = e.deltaY > 0 ? -zoomSpeed : zoomSpeed;
                    camera.zoom = Math.max(0.3, Math.min(2, camera.zoom + delta));
                });

                canvas.addEventListener('mouseleave', () => {
                    tooltip.style.display = 'none';
                });

                // Animation loop
                const animate = () => {
                    draw();
                    this._skillTreeAnimationFrame = requestAnimationFrame(animate);
                };

                updateStatsDisplay();
                animate();
            }

            checkKeystoneSlots() {
                // Sync rune slots from skill tree data
                // FIX: Use party member classes instead of hardcoded array
                const savedData = localStorage.getItem('skillTreeData');

                if (savedData) {
                    const data = JSON.parse(savedData);

                    this.party.forEach((member, idx) => {
                        const charKey = member.className.toLowerCase();
                        if (data.characters && data.characters[charKey] && data.characters[charKey].totalStats) {
                            const runeSlotCount = data.characters[charKey].totalStats.runeSlots || 0;

                            console.log(`${charKey} has ${runeSlotCount} rune slots from skill tree`);

                            // Update slots based on skill tree count
                            for (let i = 0; i < 5; i++) {
                                const shouldBeUnlocked = i < runeSlotCount;
                                const wasUnlocked = this.runeSlots[charKey][i];

                                if (shouldBeUnlocked && !wasUnlocked) {
                                    // Unlock slot
                                    this.runeSlots[charKey][i] = true;
                                    console.log(`Unlocked ${charKey} rune slot ${i + 1}`);
                                } else if (!shouldBeUnlocked && wasUnlocked) {
                                    // Lock slot and unequip if needed
                                    if (this.equippedRunes[charKey][i]) {
                                        const rune = this.equippedRunes[charKey][i];
                                        this.equippedRunes[charKey][i] = null;
                                        this.runes.push(rune);
                                        this.addLog(`${rune.name} unequipped due to skill tree change`, 'loot');

                                        // Remove rune stats
                                        const member = this.party[idx];
                                        if (member && rune.stats) {
                                            const hpPercent = member.hp / member.maxHp;
                                            const manaPercent = member.mana / member.maxMana;

                                            for (const [stat, value] of Object.entries(rune.stats)) {
                                                if (stat === 'hp') member.maxHp -= value;
                                                else if (stat === 'mana') member.maxMana -= value;
                                                else if (stat === 'attack') member.attack -= value;
                                                else if (stat === 'defense') member.defense -= value;
                                                else if (stat === 'attackSpeed') member.attackSpeed -= value / 100;
                                                else if (stat === 'critChance') member.critChance -= value;
                                                else if (stat === 'critDamage') member.critDamage -= value;
                                                else if (stat === 'dodge') member.dodgeChance -= value;
                                                else if (stat === 'lifesteal') member.lifesteal -= value;
                                                else if (stat === 'hpRegen') member.hpRegen -= value;
                                                else if (stat === 'manaRegen') member.manaRegen -= value;
                                                else if (stat === 'cdr') member.cdr -= value;
                                            }

                                            member.hp = Math.floor(member.maxHp * hpPercent);
                                            member.mana = Math.floor(member.maxMana * manaPercent);
                                        }
                                    }
                                    this.runeSlots[charKey][i] = false;
                                    console.log(`Locked ${charKey} rune slot ${i + 1}`);
                                }
                            }
                        }
                    });
                }

                console.log('Final rune slots state:', this.runeSlots);
            }

            applySkillTreeStats(member) {
                if (!member.skillTreeData || !member.skillTreeData.allocatedNodes) return;

                // Store current HP/Mana percentages BEFORE changing maxHp/maxMana
                const oldMaxHp = member.getTotalMaxHp();
                const oldMaxMana = member.getTotalMaxMana();
                const hpPercent = member.hp / oldMaxHp;
                const manaPercent = member.mana / oldMaxMana;

                // Reset skill tree bonuses to base
                member.skillTreeAttack = 0;
                member.skillTreeDefense = 0;
                member.skillTreeHP = 0;
                member.skillTreeMana = 0;
                member.skillTreeAttackSpeed = 0;
                member.skillTreeCritChance = 0;
                member.skillTreeCritDamage = 0;
                member.skillTreeDodge = 0;
                member.skillTreeLifesteal = 0;
                member.skillTreeHPRegen = 0;
                member.skillTreeManaRegen = 0;
                member.skillTreeCDR = 0;

                // Try to get stats from saved data first
                const savedData = localStorage.getItem('skillTreeData');
                if (savedData) {
                    try {
                        const data = JSON.parse(savedData);
                        // FIX: Use member.className.toLowerCase() instead of hardcoded party order
                        const charKey = member.className.toLowerCase();

                        if (data.characters && data.characters[charKey] && data.characters[charKey].totalStats) {
                            const stats = data.characters[charKey].totalStats;
                            member.skillTreeAttack = stats.attack || 0;
                            member.skillTreeDefense = stats.defense || 0;
                            member.skillTreeHP = stats.hp || 0;
                            member.skillTreeMana = stats.mana || 0;
                            member.skillTreeAttackSpeed = stats.attackSpeed || 0;
                            member.skillTreeCritChance = stats.critChance || 0;
                            member.skillTreeCritDamage = stats.critDamage || 0;
                            member.skillTreeDodge = stats.dodge || 0;
                            member.skillTreeLifesteal = stats.lifesteal || 0;
                            member.skillTreeHPRegen = stats.hpRegen || 0;
                            member.skillTreeManaRegen = stats.manaRegen || 0;
                            member.skillTreeCDR = stats.cdr || 0;

                            // Calculate bonuses from perEpic stats based on equipped epic+ items
                            const epicCount = Object.values(member.equipment).filter(item =>
                                item && (item.rarity === 'epic' || item.rarity === 'legendary')
                            ).length;

                            if (epicCount > 0) {
                                if (stats.attPerEpic) {
                                    member.skillTreeAttack += stats.attPerEpic * epicCount;
                                }
                                if (stats.defPerEpic) {
                                    member.skillTreeDefense += stats.defPerEpic * epicCount;
                                }
                                if (stats.hpPerEpic) {
                                    member.skillTreeHP += stats.hpPerEpic * epicCount;
                                }
                                if (stats.manaPerEpic) {
                                    member.skillTreeMana += stats.manaPerEpic * epicCount;
                                }
                                if (stats.critDmgPerEpic) {
                                    member.skillTreeCritDamage += stats.critDmgPerEpic * epicCount;
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Error loading skill tree stats:', e);
                    }
                }

                // Calculate base max values
                const baseMaxHP = member.className === 'Tank' ? 100 :
                                 member.className === 'Rogue' ? 80 :
                                 member.className === 'Mage' ? 70 :
                                 member.className === 'Healer' ? 75 : 100;
                const baseMaxMana = member.className === 'Tank' ? 50 :
                                   member.className === 'Rogue' ? 60 :
                                   member.className === 'Mage' ? 100 :
                                   member.className === 'Healer' ? 80 : 50;

                // Recalculate max HP and Mana (base + level scaling only - equipment handled by getTotal functions)
member.maxHp = Math.round(baseMaxHP + (10 * (member.level - 1)));
member.maxMana = Math.round(baseMaxMana);

// Restore HP/Mana based on percentage using TOTAL max values (which include equipment)
const newMaxHp = member.getTotalMaxHp();
const newMaxMana = member.getTotalMaxMana();
member.hp = Math.round(newMaxHp * hpPercent);
member.mana = Math.round(newMaxMana * manaPercent);

                // Check and unlock rune slots based on skill tree
                this.checkKeystoneSlots();
            }
hideDungeonSelector() {
                document.getElementById('dungeon-selector').style.display = 'none';
                this.paused = false;
            }



rollRuneFromTrial(tier) {
    // Step 1: Determine if ability or stat rune (40% ability, 60% stat)
    const isAbilityRune = Math.random() < RUNE_TRIAL_CONFIG.ABILITY_RUNE_CHANCE;

    let runeType;

    if (isAbilityRune) {
        // Step 2: If ability rune, pick from abilities based on party composition
        const abilityMap = {
            'tank': 'taunt',
            'healer': 'heal',
            'mage': 'fireball',
            'rogue': 'doublestrike',
            'archer': 'multishot',
            'paladin': 'divineshield'
        };

        // Get abilities for classes in party
        const partyAbilities = this.party.map(m => abilityMap[m.className.toLowerCase()]).filter(a => a);
        runeType = partyAbilities[Math.floor(Math.random() * partyAbilities.length)];
    } else {
        // Step 2: If stat rune, pick one of 9 stat types (equal ~11.1% each)
        const statTypes = ['attack', 'attackspeed', 'defense', 'crit', 'dodge', 'lifesteal', 'time', 'health', 'mana'];
        runeType = statTypes[Math.floor(Math.random() * statTypes.length)];
    }

    // Create the rune (no level or rarity for runes)
    const rune = new RuneItem(tier, runeType);
    this.runes.push(rune);

    this.addLog(`Found ${rune.name}!`, 'loot');

    return rune;
}

rollPetRarity() {
                const roll = Math.random() * 100;

                if (roll < 50) return 'common';        // 50%
                if (roll < 75) return 'uncommon';      // 25%
                if (roll < 90) return 'rare';          // 15%
                if (roll < 99) return 'epic';          // 9%
                return 'legendary';                     // 1%
            }

            showPetsCollection() {
                const container = document.getElementById('pet-collection-container');

                // Comprehensive pet image mapping for migration
                const petImageMap = {
                    // Everfall (Air)
                    'Plumee': 'Kin/Air/plumee.png',
                    'Tuffit': 'Kin/Air/tuffit.png',
                    'Zeffi': 'Kin/Air/zeffi.png',
                    'Loofin': 'Kin/Air/loofin.png',
                    'Flitta': 'Kin/Air/flitta.png',
                    'Preep': 'Kin/Air/preep.png',
                    'Skibbin': 'Kin/Air/skibbin.png',
                    'Fandrel': 'Kin/Air/fandrel.png',
                    'Yuralon': 'Kin/Air/yuralon.png',
                    'Zenth': 'Kin/Air/zenth.png',
                    'Arvent': 'Kin/Air/arvent.png',
                    'Quist': 'Kin/Air/quist.png',
                    'Whisbit': 'Kin/Air/whisbit.png',
                    'Siroth': 'Kin/Air/siroth.png',
                    // Stoneforge (Fire)
                    'Crimbee': 'Kin/Fire/crimbee.png',
                    'Pikkit': 'Kin/Fire/pikkit.png',
                    'Gritbun': 'Kin/Fire/gritbun.png',
                    'Fennix': 'Kin/Fire/fennix.png',
                    'Varnowl': 'Kin/Fire/varnowl.png',
                    'Bristlepup': 'Kin/Fire/bristlepup.png',
                    'Ignishade': 'Kin/Fire/ignishade.png',
                    'Wiskit': 'Kin/Fire/wiskit.png',
                    'Quenra': 'Kin/Fire/quenra.png',
                    'Cindor': 'Kin/Fire/cindor.png',
                    'Solmere': 'Kin/Fire/solmere.png',
                    'Moltara': 'Kin/Fire/moltara.png',
                    'Braxen': 'Kin/Fire/braxen.png',
                    'Ashkara': 'Kin/Fire/ashkara.png',
                    // Umbral Depths (Water)
                    'Pepple': 'Kin/Water/pepple.png',
                    'Nymbark': 'Kin/Water/nymbark.png',
                    'Moondra': 'Kin/Water/moondra.png',
                    'Typharos': 'Kin/Water/typharos.png'
                };

                // Fix old pets without images
                this.pets.forEach(pet => {
                    if (!pet.image) {
                        pet.image = petImageMap[pet.name] || 'Kin/Earth/chundra.png';
                    }
                });

                // Fix equipped pets without images
                ['tank', 'healer', 'mage', 'rogue', 'archer', 'paladin'].forEach(charKey => {
                    const pet = this.equippedPets[charKey];
                    if (pet && !pet.image) {
                        pet.image = petImageMap[pet.name] || 'Kin/Earth/chundra.png';
                    }
                });

                const rarityColors = {
                    common: '#94a3b8',
                    uncommon: '#10b981',
                    rare: '#3b82f6',
                    epic: '#a855f7',
                    legendary: '#f59e0b'
                };

                // FIX: Use actual party order instead of hardcoded array

                // Build compact equipped pets grid
                const equippedPetsHTML = `
                    <div style="margin-bottom: 15px;">
                        <div style="font-size: 10px; color: #94a3b8; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; text-align: center; font-weight: 600;">Equipped Pets</div>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; margin-bottom: 15px;">
                            ${this.party.map((member, idx) => {
                                const charKey = member.className.toLowerCase();
                                const pet = this.equippedPets[charKey];
                                const charName = member.name;

                                if (pet) {
                                    return `
                                        <div style="background: rgba(15, 23, 42, 0.5); border: 2px solid ${rarityColors[pet.rarity]}; border-radius: 6px; padding: 6px; text-align: center;">
                                            <img src="${pet.image}"
                                                style="width: 32px; height: 32px; border-radius: 4px; margin-bottom: 3px;">
                                            <div style="font-size: 8px; color: ${rarityColors[pet.rarity]}; font-weight: 700; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${pet.name}</div>
                                            <div style="font-size: 7px; color: #64748b;">${charName}</div>
                                        </div>
                                    `;
                                } else {
                                    return `
                                        <div style="background: rgba(30, 41, 59, 0.6); border: 1px dashed rgba(100, 116, 139, 0.3); border-radius: 6px; padding: 6px; text-align: center;">
                                            <div style="font-size: 20px; color: #475569; margin-bottom: 2px;">üêæ</div>
                                            <div style="font-size: 7px; color: #64748b;">${charName}</div>
                                        </div>
                                    `;
                                }
                            }).join('')}
                        </div>
                        <div style="height: 1px; background: linear-gradient(to right, transparent, rgba(99, 102, 241, 0.3), transparent); margin: 10px 0;"></div>
                        <div style="font-size: 10px; color: #94a3b8; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; text-align: center; font-weight: 600;">Pet Collection (${this.pets.length})</div>
                    </div>
                `;

                if (this.pets.length === 0) {
                    container.innerHTML = equippedPetsHTML + `
                        <div style="color: #64748b; font-style: italic; font-size: 12px; text-align: center; padding: 40px;">
                            No pets found yet<br>
                            <span style="font-size: 10px; color: #52525b;">Defeat enemies to collect pets!</span>
                        </div>
                    `;
                    return;
                }

                // Sort pets by rarity then level
                const rarityOrder = { legendary: 5, epic: 4, rare: 3, uncommon: 2, common: 1 };
                const sortedPets = [...this.pets].sort((a, b) => {
                    if (rarityOrder[b.rarity] !== rarityOrder[a.rarity]) {
                        return rarityOrder[b.rarity] - rarityOrder[a.rarity];
                    }
                    return b.level - a.level;
                });

                const charIcons = { tank: 'üõ°Ô∏è', healer: 'üíä', mage: 'üîÆ', rogue: 'üó°Ô∏è' };

                container.innerHTML = equippedPetsHTML + `<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">` + sortedPets.map(pet => {
                    const upgradeCost = pet.getUpgradeCost();
                    const bonus = pet.getCurrentBonus();
                    const bonusDisplay = ['attackSpeed', 'critChance', 'dodge', 'critDamage'].includes(pet.bonusType)
                        ? `+${bonus}%`
                        : `+${bonus}`;

                    // Find which character has this pet equipped - FIX: Use Object.entries
                    let equippedTo = null;
                    for (const [charType, equippedPet] of Object.entries(this.equippedPets)) {
                        if (equippedPet === pet) {
                            equippedTo = charType;
                            break;
                        }
                    }

                    return `
                        <div class="pet-collection-card" style="
                            background: linear-gradient(135deg, rgba(${pet.rarity === 'legendary' ? '245, 158, 11' :
                                            pet.rarity === 'epic' ? '168, 85, 247' :
                                            pet.rarity === 'rare' ? '59, 130, 246' :
                                            pet.rarity === 'uncommon' ? '16, 185, 129' : '148, 163, 184'}, 0.15) 0%, rgba(15, 23, 42, 0.95) 100%);
                            border: 2px solid ${rarityColors[pet.rarity]};
                            border-radius: 8px;
                            padding: 10px;
                            position: relative;
                            ${equippedTo ? 'box-shadow: 0 0 15px ' + rarityColors[pet.rarity] + ';' : ''}
                        ">
                            ${equippedTo ? `
                                <div style="position: absolute; top: 4px; right: 4px; background: rgba(99, 102, 241, 0.9);
                                    color: white; padding: 2px 6px; border-radius: 4px; font-size: 8px; font-weight: 700;">
                                    ${charIcons[equippedTo]}
                                </div>
                            ` : ''}

                            <div style="text-align: center; margin-bottom: 8px;">
                                <img src="${pet.image}"
                                    style="width: 60px; height: 60px; border-radius: 8px; border: 2px solid ${rarityColors[pet.rarity]};">
                            </div>

                            <div style="text-align: center; margin-bottom: 8px;">
                                <div style="font-weight: 700; color: ${rarityColors[pet.rarity]}; font-size: 12px; margin-bottom: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                    ${pet.name}
                                </div>
                                <div style="font-size: 9px; color: #94a3b8;">
                                    ${pet.rarity.toUpperCase()} ‚Ä¢ Lv${pet.level}
                                </div>
                            </div>

                            <div style="background: rgba(0, 0, 0, 0.3); padding: 6px; border-radius: 6px; margin-bottom: 8px;">
                                <div style="color: #10b981; font-size: 10px; text-align: center; font-weight: 600;">
                                    ${pet.bonusType === 'attackSpeed' ? 'ATK SPD' :
                                      pet.bonusType === 'critChance' ? 'CRIT' :
                                      pet.bonusType === 'critDamage' ? 'CRIT DMG' :
                                      pet.bonusType === 'lifesteal' ? 'LIFESTEAL' :
                                      pet.bonusType === 'manaRegen' ? 'MANA REGEN' :
                                      pet.bonusType === 'hpRegen' ? 'HP REGEN' :
                                      pet.bonusType === 'cdr' ? 'CDR' :
                                      pet.bonusType.toUpperCase()}: ${bonusDisplay}
                                </div>
                            </div>

                            ${equippedTo ? `
                                <button onclick="window.game.unequipPet('${equippedTo}')"
                                    style="width: 100%; padding: 6px; background: rgba(239, 68, 68, 0.2);
                                    color: #ef4444; border: 2px solid #ef4444; border-radius: 6px; cursor: pointer;
                                    font-size: 9px; font-weight: 700; margin-bottom: 4px;">
                                    UNEQUIP
                                </button>
                            ` : `
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 4px;">
                                    <button onclick="window.game.showEquipPetModal(${pet.id})"
                                        style="padding: 6px; background: linear-gradient(135deg, #6366f1, #8b5cf6);
                                        color: white; border: none; border-radius: 6px; cursor: pointer;
                                        font-size: 9px; font-weight: 700;">
                                        EQUIP
                                    </button>
                                    <button onclick="window.game.showUpgradePetModal(${pet.id})"
                                        ${pet.level >= 20 ? 'disabled' : ''}
                                        style="padding: 6px; background: linear-gradient(135deg, #f59e0b, #fbbf24);
                                        color: #000; border: none; border-radius: 6px; cursor: pointer; font-size: 9px; font-weight: 700;
                                        ${pet.level >= 20 ? 'opacity: 0.4; cursor: not-allowed;' : ''}">
                                        ${pet.level >= 20 ? 'MAX' : 'UPGRADE'}
                                    </button>
                                </div>
                            `}

                            <button onclick="window.game.showReleasePetModal(${pet.id})"
                                ${equippedTo ? 'disabled' : ''}
                                style="width: 100%; padding: 5px; background: linear-gradient(135deg, #ef4444, #dc2626);
                                color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 9px; font-weight: 700;
                                ${equippedTo ? 'opacity: 0.4; cursor: not-allowed;' : ''}">
                                RELEASE
                            </button>
                        </div>
                    `;
                }).join('') + `</div>`;
            }

            showEquipPetModal(petId) {
                const pet = this.pets.find(p => p.id === petId);
                if (!pet) return;

                // Fix pet image if missing (migration)
                if (!pet.image) {
                    const petImageMap = {
                        'Plumee': 'Kin/Air/plumee.png',
                        'Tuffit': 'Kin/Air/tuffit.png',
                        'Zeffi': 'Kin/Air/zeffi.png',
                        'Loofin': 'Kin/Air/loofin.png',
                        'Flitta': 'Kin/Air/flitta.png',
                        'Preep': 'Kin/Air/preep.png',
                        'Skibbin': 'Kin/Air/skibbin.png',
                        'Fandrel': 'Kin/Air/fandrel.png',
                        'Yuralon': 'Kin/Air/yuralon.png',
                        'Zenth': 'Kin/Air/zenth.png',
                        'Arvent': 'Kin/Air/arvent.png',
                        'Quist': 'Kin/Air/quist.png',
                        'Whisbit': 'Kin/Air/whisbit.png',
                        'Siroth': 'Kin/Air/siroth.png',
                        'Crimbee': 'Kin/Fire/crimbee.png',
                        'Pikkit': 'Kin/Fire/pikkit.png',
                        'Gritbun': 'Kin/Fire/gritbun.png',
                        'Fennix': 'Kin/Fire/fennix.png',
                        'Varnowl': 'Kin/Fire/varnowl.png',
                        'Bristlepup': 'Kin/Fire/bristlepup.png',
                        'Ignishade': 'Kin/Fire/ignishade.png',
                        'Wiskit': 'Kin/Fire/wiskit.png',
                        'Quenra': 'Kin/Fire/quenra.png',
                        'Cindor': 'Kin/Fire/cindor.png',
                        'Solmere': 'Kin/Fire/solmere.png',
                        'Moltara': 'Kin/Fire/moltara.png',
                        'Braxen': 'Kin/Fire/braxen.png',
                        'Ashkara': 'Kin/Fire/ashkara.png',
                        'Pepple': 'Kin/Water/pepple.png',
                        'Nymbark': 'Kin/Water/nymbark.png',
                        'Moondra': 'Kin/Water/moondra.png',
                        'Typharos': 'Kin/Water/typharos.png'
                    };
                    pet.image = petImageMap[pet.name] || 'Kin/Earth/chundra.png';
                }

                const overlay = document.createElement('div');
                overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.95); display: flex; justify-content: center; align-items: center; z-index: 5000;';

                const panel = document.createElement('div');
                panel.style.cssText = 'background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(6, 9, 23, 0.98) 100%); border: 3px solid #6366f1; border-radius: 20px; padding: 40px; text-align: center; box-shadow: 0 30px 80px rgba(0,0,0,0.9); max-width: 400px;';

                const rarityColors = {
                    common: '#94a3b8',
                    uncommon: '#10b981',
                    rare: '#3b82f6',
                    epic: '#a855f7',
                    legendary: '#f59e0b'
                };

                // Get only the active party members (4 characters)
                const activeCharKeys = this.party.map(member => member.className.toLowerCase());

                const charIcons = {
                    tank: '<img src="tank.png" alt="Tank" style="width: 16px; height: 16px; vertical-align: middle;">',
                    healer: '<img src="healer.png" alt="Healer" style="width: 16px; height: 16px; vertical-align: middle;">',
                    mage: '<img src="mage.png" alt="Mage" style="width: 16px; height: 16px; vertical-align: middle;">',
                    rogue: '<img src="rogue.png" alt="Rogue" style="width: 16px; height: 16px; vertical-align: middle;">',
                    archer: '<img src="archer.png" alt="Archer" style="width: 16px; height: 16px; vertical-align: middle;">',
                    paladin: '<img src="paladin.png" alt="Paladin" style="width: 16px; height: 16px; vertical-align: middle;">'
                };
                const charDisplayNames = { tank: 'Tank', healer: 'Healer', mage: 'Mage', rogue: 'Rogue', archer: 'Archer', paladin: 'Paladin' };

                panel.innerHTML = `
                    <img src="${pet.image || 'Kin/Earth/chundra.png'}"
                        style="width: 100px; height: 100px; border-radius: 16px; border: 3px solid ${rarityColors[pet.rarity]}; margin-bottom: 20px;">
                    <div style="font-family: 'Orbitron', sans-serif; font-size: 24px; font-weight: 800; color: ${rarityColors[pet.rarity]}; margin-bottom: 20px;">
                        EQUIP ${pet.name.toUpperCase()}
                    </div>
                    <div style="font-size: 14px; color: #94a3b8; margin-bottom: 30px;">Select a character:</div>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 20px;">
                        ${activeCharKeys.map(char => `
                            <button onclick="window.game.equipPetToCharacterFromModal(${pet.id}, '${char}'); this.closest('[style*=fixed]').remove();"
                                style="padding: 15px; background: linear-gradient(135deg, #6366f1, #8b5cf6);
                                color: white; border: none; border-radius: 10px; cursor: pointer;
                                font-family: 'Orbitron', sans-serif; font-size: 13px; font-weight: 700;">
                                ${charIcons[char]} ${charDisplayNames[char]}
                            </button>
                        `).join('')}
                    </div>
                    <button onclick="this.closest('[style*=fixed]').remove();"
                        style="width: 100%; padding: 12px; background: linear-gradient(135deg, #ef4444, #dc2626);
                        color: white; border: none; border-radius: 10px; cursor: pointer;
                        font-family: 'Orbitron', sans-serif; font-size: 14px; font-weight: 700;">
                        CANCEL
                    </button>
                `;

                overlay.appendChild(panel);
                document.body.appendChild(overlay);
            }
            equipPetToCharacterFromModal(petId, charKey) {
                this.equipPetToCharacter(petId, charKey);
                this.showPetsCollection();
            }

            showUpgradePetModal(petId) {
                const pet = this.pets.find(p => p.id === petId);
                if (!pet || pet.level >= 20) return;

                // Fix pet image if missing (migration)
                if (!pet.image) {
                    const petImageMap = {
                        'Plumee': 'Kin/Air/plumee.png',
                        'Tuffit': 'Kin/Air/tuffit.png',
                        'Zeffi': 'Kin/Air/zeffi.png',
                        'Loofin': 'Kin/Air/loofin.png',
                        'Flitta': 'Kin/Air/flitta.png',
                        'Preep': 'Kin/Air/preep.png',
                        'Skibbin': 'Kin/Air/skibbin.png',
                        'Fandrel': 'Kin/Air/fandrel.png',
                        'Yuralon': 'Kin/Air/yuralon.png',
                        'Zenth': 'Kin/Air/zenth.png',
                        'Arvent': 'Kin/Air/arvent.png',
                        'Quist': 'Kin/Air/quist.png',
                        'Whisbit': 'Kin/Air/whisbit.png',
                        'Siroth': 'Kin/Air/siroth.png',
                        'Crimbee': 'Kin/Fire/crimbee.png',
                        'Pikkit': 'Kin/Fire/pikkit.png',
                        'Gritbun': 'Kin/Fire/gritbun.png',
                        'Fennix': 'Kin/Fire/fennix.png',
                        'Varnowl': 'Kin/Fire/varnowl.png',
                        'Bristlepup': 'Kin/Fire/bristlepup.png',
                        'Ignishade': 'Kin/Fire/ignishade.png',
                        'Wiskit': 'Kin/Fire/wiskit.png',
                        'Quenra': 'Kin/Fire/quenra.png',
                        'Cindor': 'Kin/Fire/cindor.png',
                        'Solmere': 'Kin/Fire/solmere.png',
                        'Moltara': 'Kin/Fire/moltara.png',
                        'Braxen': 'Kin/Fire/braxen.png',
                        'Ashkara': 'Kin/Fire/ashkara.png',
                        'Pepple': 'Kin/Water/pepple.png',
                        'Nymbark': 'Kin/Water/nymbark.png',
                        'Moondra': 'Kin/Water/moondra.png',
                        'Typharos': 'Kin/Water/typharos.png'
                    };
                    pet.image = petImageMap[pet.name] || 'Kin/Earth/chundra.png';
                }

                const upgradeCost = pet.getUpgradeCost();
                const currentBonus = pet.getCurrentBonus();
                const nextBonus = pet.baseValue + (pet.upgradeValue * pet.level); // Next level bonus

                const overlay = document.createElement('div');
                overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.95); display: flex; justify-content: center; align-items: center; z-index: 5000;';

                const panel = document.createElement('div');
                panel.style.cssText = 'background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(6, 9, 23, 0.98) 100%); border: 3px solid #f59e0b; border-radius: 20px; padding: 40px; text-align: center; box-shadow: 0 30px 80px rgba(0,0,0,0.9); max-width: 400px;';

                const rarityColors = {
                    common: '#94a3b8',
                    uncommon: '#10b981',
                    rare: '#3b82f6',
                    epic: '#a855f7',
                    legendary: '#f59e0b'
                };

                const statName = pet.bonusType === 'attackSpeed' ? 'Attack Speed' :
                                pet.bonusType === 'critChance' ? 'Crit Chance' :
                                pet.bonusType === 'critDamage' ? 'Crit Damage' :
                                pet.bonusType === 'lifesteal' ? 'Lifesteal' :
                                pet.bonusType === 'manaRegen' ? 'Mana Regen' :
                                pet.bonusType === 'hpRegen' ? 'HP Regen' :
                                pet.bonusType === 'cdr' ? 'CDR' :
                                pet.bonusType.charAt(0).toUpperCase() + pet.bonusType.slice(1);

                const isPercent = ['attackSpeed', 'critChance', 'critDamage', 'dodge', 'lifesteal', 'cdr'].includes(pet.bonusType);
                const currentDisplay = isPercent ? `${currentBonus}%` : currentBonus;
                const nextDisplay = isPercent ? `${nextBonus}%` : nextBonus;

                panel.innerHTML = `
                    <img src="${pet.image || 'Kin/Earth/chundra.png'}"
                        style="width: 100px; height: 100px; border-radius: 16px; border: 3px solid ${rarityColors[pet.rarity]}; margin-bottom: 20px;">
                    <div style="font-family: 'Orbitron', sans-serif; font-size: 24px; font-weight: 800; color: #f59e0b; margin-bottom: 20px;">
                        UPGRADE ${pet.name.toUpperCase()}
                    </div>
                    <div style="font-size: 14px; color: #94a3b8; margin-bottom: 10px;">Level ${pet.level} ‚Üí ${pet.level + 1}</div>
                    <div style="background: rgba(0, 0, 0, 0.4); padding: 20px; border-radius: 12px; margin-bottom: 20px;">
                        <div style="font-size: 13px; color: #94a3b8; margin-bottom: 10px;">${statName}</div>
                        <div style="font-size: 20px; color: #10b981; font-weight: 700; font-family: 'Orbitron', sans-serif;">
                            ${currentDisplay} ‚Üí ${nextDisplay}
                        </div>
                    </div>
                    <div style="font-size: 16px; color: #fbbf24; font-weight: 700; margin-bottom: 20px; font-family: 'Orbitron', sans-serif;">
                        Cost: ${upgradeCost.toLocaleString()}g
                    </div>
                    <button onclick="window.game.upgradePetFromModal(${pet.id}); this.closest('[style*=fixed]').remove();"
                        ${this.gold < upgradeCost ? 'disabled' : ''}
                        style="width: 100%; padding: 15px; background: linear-gradient(135deg, #f59e0b, #fbbf24);
                        color: #000; border: none; border-radius: 10px; cursor: pointer;
                        font-family: 'Orbitron', sans-serif; font-size: 14px; font-weight: 700; margin-bottom: 10px;
                        ${this.gold < upgradeCost ? 'opacity: 0.4; cursor: not-allowed;' : ''}">
                        ${this.gold < upgradeCost ? 'NOT ENOUGH GOLD' : 'UPGRADE'}
                    </button>
                    <button onclick="this.closest('[style*=fixed]').remove();"
                        style="width: 100%; padding: 12px; background: linear-gradient(135deg, #ef4444, #dc2626);
                        color: white; border: none; border-radius: 10px; cursor: pointer;
                        font-family: 'Orbitron', sans-serif; font-size: 13px; font-weight: 700;">
                        CANCEL
                    </button>
                `;

                overlay.appendChild(panel);
                document.body.appendChild(overlay);
            }

            upgradePetFromModal(petId) {
                this.upgradePet(petId);
                this.showPetsCollection();
            }

            showReleasePetModal(petId) {
                const pet = this.pets.find(p => p.id === petId);
                if (!pet) return;

                // Check if equipped - don't show modal if equipped
                const equippedPetsList = Object.values(this.equippedPets);
                if (equippedPetsList.includes(pet)) {
                    this.addLog('Cannot release equipped pet!', 'damage');
                    return;
                }

                // Fix pet image if missing (migration)
                if (!pet.image) {
                    const petImageMap = {
                        'Plumee': 'Kin/Air/plumee.png',
                        'Tuffit': 'Kin/Air/tuffit.png',
                        'Zeffi': 'Kin/Air/zeffi.png',
                        'Loofin': 'Kin/Air/loofin.png',
                        'Flitta': 'Kin/Air/flitta.png',
                        'Preep': 'Kin/Air/preep.png',
                        'Skibbin': 'Kin/Air/skibbin.png',
                        'Fandrel': 'Kin/Air/fandrel.png',
                        'Yuralon': 'Kin/Air/yuralon.png',
                        'Zenth': 'Kin/Air/zenth.png',
                        'Arvent': 'Kin/Air/arvent.png',
                        'Quist': 'Kin/Air/quist.png',
                        'Whisbit': 'Kin/Air/whisbit.png',
                        'Siroth': 'Kin/Air/siroth.png',
                        'Crimbee': 'Kin/Fire/crimbee.png',
                        'Pikkit': 'Kin/Fire/pikkit.png',
                        'Gritbun': 'Kin/Fire/gritbun.png',
                        'Fennix': 'Kin/Fire/fennix.png',
                        'Varnowl': 'Kin/Fire/varnowl.png',
                        'Bristlepup': 'Kin/Fire/bristlepup.png',
                        'Ignishade': 'Kin/Fire/ignishade.png',
                        'Wiskit': 'Kin/Fire/wiskit.png',
                        'Quenra': 'Kin/Fire/quenra.png',
                        'Cindor': 'Kin/Fire/cindor.png',
                        'Solmere': 'Kin/Fire/solmere.png',
                        'Moltara': 'Kin/Fire/moltara.png',
                        'Braxen': 'Kin/Fire/braxen.png',
                        'Ashkara': 'Kin/Fire/ashkara.png',
                        'Pepple': 'Kin/Water/pepple.png',
                        'Nymbark': 'Kin/Water/nymbark.png',
                        'Moondra': 'Kin/Water/moondra.png',
                        'Typharos': 'Kin/Water/typharos.png'
                    };
                    pet.image = petImageMap[pet.name] || 'Kin/Earth/chundra.png';
                }

                const overlay = document.createElement('div');
                overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.95); display: flex; justify-content: center; align-items: center; z-index: 5000;';

                const panel = document.createElement('div');
                panel.style.cssText = 'background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(6, 9, 23, 0.98) 100%); border: 3px solid #ef4444; border-radius: 20px; padding: 40px; text-align: center; box-shadow: 0 30px 80px rgba(0,0,0,0.9); max-width: 400px;';

                const rarityColors = {
                    common: '#94a3b8',
                    uncommon: '#10b981',
                    rare: '#3b82f6',
                    epic: '#a855f7',
                    legendary: '#f59e0b'
                };

                const currentBonus = pet.getCurrentBonus();
                const statName = pet.bonusType === 'attackSpeed' ? 'Attack Speed' :
                                pet.bonusType === 'critChance' ? 'Crit Chance' :
                                pet.bonusType === 'critDamage' ? 'Crit Damage' :
                                pet.bonusType === 'lifesteal' ? 'Lifesteal' :
                                pet.bonusType === 'manaRegen' ? 'Mana Regen' :
                                pet.bonusType === 'hpRegen' ? 'HP Regen' :
                                pet.bonusType === 'cdr' ? 'CDR' :
                                pet.bonusType.charAt(0).toUpperCase() + pet.bonusType.slice(1);

                const isPercent = ['attackSpeed', 'critChance', 'critDamage', 'dodge', 'lifesteal', 'cdr'].includes(pet.bonusType);
                const bonusDisplay = isPercent ? `${currentBonus}%` : currentBonus;

                panel.innerHTML = `
                    <img src="${pet.image || 'Kin/Earth/chundra.png'}"
                        style="width: 100px; height: 100px; border-radius: 16px; border: 3px solid ${rarityColors[pet.rarity]}; margin-bottom: 20px;">
                    <div style="font-family: 'Orbitron', sans-serif; font-size: 24px; font-weight: 800; color: #ef4444; margin-bottom: 20px;">
                        RELEASE ${pet.name.toUpperCase()}?
                    </div>
                    <div style="font-size: 14px; color: #94a3b8; margin-bottom: 20px;">
                        ${pet.rarity.charAt(0).toUpperCase() + pet.rarity.slice(1)} ¬∑ Level ${pet.level}
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.4); padding: 20px; border-radius: 12px; margin-bottom: 20px;">
                        <div style="font-size: 13px; color: #94a3b8; margin-bottom: 10px;">${statName}</div>
                        <div style="font-size: 20px; color: #10b981; font-weight: 700; font-family: 'Orbitron', sans-serif;">
                            +${bonusDisplay}
                        </div>
                    </div>
                    <div style="font-size: 13px; color: #ef4444; margin-bottom: 20px; font-weight: 600;">
                        ‚ö†Ô∏è This action cannot be undone!
                    </div>
                    <button onclick="window.game.releasePetFromModal(${pet.id}); this.closest('[style*=fixed]').remove();"
                        style="width: 100%; padding: 15px; background: linear-gradient(135deg, #ef4444, #dc2626);
                        color: white; border: none; border-radius: 10px; cursor: pointer;
                        font-family: 'Orbitron', sans-serif; font-size: 14px; font-weight: 700; margin-bottom: 10px;">
                        RELEASE PET
                    </button>
                    <button onclick="this.closest('[style*=fixed]').remove();"
                        style="width: 100%; padding: 12px; background: linear-gradient(135deg, #64748b, #475569);
                        color: white; border: none; border-radius: 10px; cursor: pointer;
                        font-family: 'Orbitron', sans-serif; font-size: 13px; font-weight: 700;">
                        CANCEL
                    </button>
                `;

                overlay.appendChild(panel);
                document.body.appendChild(overlay);
            }

            releasePetFromModal(petId) {
                this.releasePet(petId);
            }

            releasePet(petId) {
                const pet = this.pets.find(p => p.id === petId);
                if (!pet) return;

                // Check if equipped - FIX: Use Object.values instead of hardcoded array
                const equippedPetsList = Object.values(this.equippedPets);
                if (equippedPetsList.includes(pet)) {
                    this.addLog('Cannot release equipped pet!', 'damage');
                    return;
                }

                // No gold given for releasing pets

                const petIndex = this.pets.indexOf(pet);
                this.pets.splice(petIndex, 1);

                this.addLog(`Released ${pet.name}`, 'loot');
                this.showPetsCollection();
                this.updateUI();
            }

            updatePetDisplay(memberIndex) {
                // FIX: Use member.className.toLowerCase() instead of hardcoded array
                const member = this.party[memberIndex];
                if (!member) return;

                const charKey = member.className.toLowerCase();

                // Find the pet view for this character
                const memberCard = document.querySelectorAll('.member-card')[memberIndex];
                if (!memberCard) return;

                const petView = memberCard.querySelector('.pet-view');
                if (!petView) return;

                const petSlotDisplay = petView.querySelector('.pet-slot-display');
                const petInventoryList = petView.querySelector('.pet-inventory-list');

                // Show equipped pet
                const equippedPet = this.equippedPets[charKey];
                if (equippedPet) {
                    const bonus = equippedPet.getCurrentBonus();
                    const bonusDisplay = ['attackSpeed', 'critChance', 'dodge', 'critDamage'].includes(equippedPet.bonusType)
                        ? `+${bonus}%`
                        : `+${bonus}`;

                    const rarityColors = {
                        common: '#94a3b8',
                        uncommon: '#10b981',
                        rare: '#3b82f6',
                        epic: '#a855f7',
                        legendary: '#f59e0b'
                    };

                    const upgradeCost = equippedPet.getUpgradeCost();
                    const canUpgrade = equippedPet.level < 20;

                    petSlotDisplay.innerHTML = `
                        <div style="background: rgba(${equippedPet.rarity === 'legendary' ? '245, 158, 11' :
                                        equippedPet.rarity === 'epic' ? '168, 85, 247' :
                                        equippedPet.rarity === 'rare' ? '59, 130, 246' :
                                        equippedPet.rarity === 'uncommon' ? '16, 185, 129' : '148, 163, 184'}, 0.15);
                            border: 2px solid ${rarityColors[equippedPet.rarity]};
                            border-radius: 8px;
                            padding: 12px;
                            box-shadow: 0 0 10px ${rarityColors[equippedPet.rarity]};">
                            <img src="Kin/Earth/chundra.png"
                                style="width: 60px; height: 60px; border-radius: 8px; display: block; margin: 0 auto 8px;">
                            <div style="font-weight: 700; font-size: 13px; text-align: center; color: ${rarityColors[equippedPet.rarity]};">
                                ${equippedPet.name}
                            </div>
                            <div style="font-size: 10px; text-align: center; color: #94a3b8; margin: 3px 0;">
                                Level ${equippedPet.level}
                            </div>
                            <div style="text-align: center; color: #10b981; font-size: 11px; margin-top: 5px;">
                                ${equippedPet.bonusType.toUpperCase()}: ${bonusDisplay}
                            </div>
                            ${canUpgrade ? `
                                <button onclick="window.game.upgradePet(${equippedPet.id})"
                                    style="width: 100%; margin-top: 8px; padding: 6px; background: rgba(245, 158, 11, 0.2);
                                    color: #fbbf24; border: 1px solid #f59e0b; border-radius: 6px; cursor: pointer;
                                    font-size: 10px; font-weight: 600;">
                                    UPGRADE (üí∞ ${upgradeCost.toLocaleString()})
                                </button>
                            ` : `
                                <div style="width: 100%; margin-top: 8px; padding: 6px; background: rgba(100, 116, 139, 0.2);
                                    color: #64748b; border: 1px solid #64748b; border-radius: 6px; text-align: center;
                                    font-size: 10px; font-weight: 600;">
                                    MAX LEVEL
                                </div>
                            `}
                            <button onclick="window.game.unequipPet('${charKey}')"
                                style="width: 100%; margin-top: 8px; padding: 6px; background: rgba(239, 68, 68, 0.2);
                                color: #ef4444; border: 1px solid #ef4444; border-radius: 6px; cursor: pointer;
                                font-size: 10px; font-weight: 600;">
                                UNEQUIP
                            </button>
                        </div>
                    `;
                } else {
                    petSlotDisplay.innerHTML = `
                        <div style="color: #64748b; font-style: italic; font-size: 11px; padding: 20px;">
                            No pet equipped
                        </div>
                    `;
                }

                // Show available pets
                if (this.pets.length === 0) {
                    petInventoryList.innerHTML = `
                        <div style="color: #64748b; font-style: italic; font-size: 10px; text-align: center; padding: 15px;">
                            No pets found<br>
                            <span style="font-size: 9px;">Defeat enemies!</span>
                        </div>
                    `;
                    return;
                }

                // Filter out equipped pets from other characters
                const availablePets = this.pets.filter(pet => {
                    const equippedChars = Object.values(this.equippedPets);
                    return !equippedChars.includes(pet) || pet === equippedPet;
                });

                // Sort pets by rarity then level
                const rarityOrder = { legendary: 5, epic: 4, rare: 3, uncommon: 2, common: 1 };
                const sortedPets = [...availablePets].sort((a, b) => {
                    if (rarityOrder[b.rarity] !== rarityOrder[a.rarity]) {
                        return rarityOrder[b.rarity] - rarityOrder[a.rarity];
                    }
                    return b.level - a.level;
                });

                const rarityColors = {
                    common: '#94a3b8',
                    uncommon: '#10b981',
                    rare: '#3b82f6',
                    epic: '#a855f7',
                    legendary: '#f59e0b'
                };

                petInventoryList.innerHTML = sortedPets.map(pet => {
                    const upgradeCost = pet.getUpgradeCost();
                    const bonus = pet.getCurrentBonus();
                    const bonusDisplay = ['attackSpeed', 'critChance', 'dodge', 'critDamage'].includes(pet.bonusType)
                        ? `+${bonus}%`
                        : `+${bonus}`;

                    return `
                        <div style="
                            background: rgba(${pet.rarity === 'legendary' ? '245, 158, 11' :
                                            pet.rarity === 'epic' ? '168, 85, 247' :
                                            pet.rarity === 'rare' ? '59, 130, 246' :
                                            pet.rarity === 'uncommon' ? '16, 185, 129' : '148, 163, 184'}, 0.1);
                            border: 1px solid ${rarityColors[pet.rarity]};
                            border-radius: 6px;
                            padding: 8px;
                            margin-bottom: 6px;">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                <img src="Kin/Earth/chundra.png"
                                    style="width: 40px; height: 40px; border-radius: 6px;">
                                <div style="flex: 1;">
                                    <div style="font-weight: 700; color: ${rarityColors[pet.rarity]}; font-size: 11px;">
                                        ${pet.name}
                                    </div>
                                    <div style="font-size: 9px; color: #94a3b8;">
                                        ${pet.rarity.toUpperCase()} ‚Ä¢ Lv.${pet.level}
                                    </div>
                                </div>
                            </div>
                            <div style="background: rgba(0, 0, 0, 0.2); padding: 5px; border-radius: 4px; margin-bottom: 6px;">
                                <div style="color: #10b981; font-size: 10px; text-align: center;">
                                    ${pet.bonusType.toUpperCase()}: ${bonusDisplay}
                                </div>
                            </div>
                            <div style="display: flex; gap: 4px;">
                                <button onclick="window.game.equipPetToCharacter(${pet.id}, '${charKey}')"
                                    style="flex: 1; padding: 5px; background: linear-gradient(135deg, #6366f1, #8b5cf6);
                                    color: white; border: none; border-radius: 4px; cursor: pointer;
                                    font-size: 9px; font-weight: 600;">
                                    EQUIP
                                </button>
                                <button onclick="window.game.upgradePet(${pet.id})"
                                    ${this.gold < upgradeCost ? 'disabled' : ''}
                                    style="flex: 1; padding: 5px; background: linear-gradient(135deg, #f59e0b, #fbbf24);
                                    color: #000; border: none; border-radius: 4px; cursor: pointer; font-size: 9px; font-weight: 600;
                                    ${this.gold < upgradeCost ? 'opacity: 0.4; cursor: not-allowed;' : ''}">
                                    ${upgradeCost}g
                                </button>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            equipPetToCharacter(petId, charKey) {
                const pet = this.pets.find(p => p.id === petId);
                if (!pet) return;

                const memberIndex = ['tank', 'healer', 'mage', 'rogue', 'archer', 'paladin'].indexOf(charKey);
                const member = this.party[memberIndex];

                // Unequip current pet from this character if any
                if (this.equippedPets[charKey]) {
                    const oldPet = this.equippedPets[charKey];
                    this.removePetBonus(oldPet, member);
                    // Add old pet back to inventory
                    this.pets.push(oldPet);
                }

                // Remove new pet from inventory
                const petIndex = this.pets.indexOf(pet);
                if (petIndex > -1) {
                    this.pets.splice(petIndex, 1);
                }

                // Equip new pet
                this.equippedPets[charKey] = pet;
                this.applyPetBonus(pet, member);

                this.addLog(`${member.name} equipped ${pet.name}!`, 'loot');
                this.rebuildUI();
                this.showPetsCollection();
            }

            unequipPet(charKey) {
                // Find the party member with this className (case-insensitive match)
                const member = this.party.find(m => m.className.toLowerCase() === charKey.toLowerCase());
                const pet = this.equippedPets[charKey];

                if (!pet || !member) return;

                this.removePetBonus(pet, member);
                this.equippedPets[charKey] = null;

                // CRITICAL FIX: Add pet back to inventory when unequipping
                this.pets.push(pet);

                this.addLog(`${member.name} unequipped ${pet.name}`, 'loot');
                this.rebuildUI();
                this.showPetsCollection();
            }

            upgradePet(petId) {
                // Search in both unequipped pets and equipped pets
                let pet = this.pets.find(p => p.id === petId);

                // If not found in unequipped, search in equipped pets - FIX: Use Object.values
                if (!pet) {
                    pet = Object.values(this.equippedPets).find(p => p && p.id === petId);
                }

                if (!pet) return;

                const cost = pet.getUpgradeCost();
                if (this.gold < cost) {
                    this.addLog('Not enough gold!', 'damage');
                    return;
                }

                this.gold -= cost;

                // Find which character has this pet equipped - FIX: Use proper lookup
                let equippedMember = null;
                for (const [charType, equippedPet] of Object.entries(this.equippedPets)) {
                    if (equippedPet === pet) {
                        // Find the party member with this class
                        equippedMember = this.party.find(m => m.className.toLowerCase() === charType);
                        break;
                    }
                }

                // Remove old bonus if equipped
                if (equippedMember) {
                    this.removePetBonus(pet, equippedMember);
                }

                pet.upgrade();

                // Reapply new bonus if equipped
                if (equippedMember) {
                    this.applyPetBonus(pet, equippedMember);
                    this.updatePetDisplay(equippedCharIndex);
                }

                this.addLog(`${pet.name} upgraded to level ${pet.level}!`, 'loot');
                this.updateUI();
                this.showPetsCollection(); // Refresh the pets display
            }

            applyPetBonus(pet, member) {
                const bonus = pet.getCurrentBonus();
                const bonusType = pet.bonusType;

                console.log(`Applying pet bonus to ${member.name}: ${bonusType} +${bonus}`);
                    const oldValue = bonusType === 'hp' ? member.maxHp :
                                    bonusType === 'mana' ? member.maxMana :
                                    bonusType === 'attack' ? member.attack :
                                    bonusType === 'defense' ? member.defense :
                                    bonusType === 'attackSpeed' ? member.attackSpeed :
                                    bonusType === 'critChance' ? member.critChance :
                                    bonusType === 'critDamage' ? member.critDamage :
                                    bonusType === 'dodge' ? member.dodgeChance :
                                    bonusType === 'lifesteal' ? member.lifesteal :
                                    bonusType === 'manaRegen' ? member.manaRegen :
                                    bonusType === 'hpRegen' ? member.hpRegen :
                                    bonusType === 'cdr' ? member.cdr : 0;

                    if (bonusType === 'attack') {
                        member.attack += bonus;
                    }
                    else if (bonusType === 'defense') {
                        member.defense += bonus;
                    }
                    else if (bonusType === 'hp') {
                        const hpPercent = member.hp / member.getTotalMaxHp();
                        member.maxHp += bonus;
                        member.hp = Math.min(member.getTotalMaxHp(), Math.round(member.getTotalMaxHp() * hpPercent));
                    }
                    else if (bonusType === 'mana') {
                        const manaPercent = member.mana / member.getTotalMaxMana();
                        member.maxMana += bonus;
                        member.mana = Math.min(member.getTotalMaxMana(), Math.round(member.getTotalMaxMana() * manaPercent));
                    }
                    else if (bonusType === 'attackSpeed') {
                        member.attackSpeed += bonus / 100;
                    }
                    else if (bonusType === 'critChance') {
                        member.critChance += bonus;
                    }
                    else if (bonusType === 'critDamage') {
                        member.critDamage += bonus;
                    }
                    else if (bonusType === 'dodge') {
                        member.dodgeChance += bonus;
                    }
                    else if (bonusType === 'lifesteal') {
                        member.lifesteal += bonus;
                    }
                    else if (bonusType === 'manaRegen') {
                        member.manaRegen += bonus;
                    }
                    else if (bonusType === 'hpRegen') {
                        member.hpRegen += bonus;
                    }
                    else if (bonusType === 'cdr') {
                        member.cdr += bonus;
                    }

                    const newValue = bonusType === 'hp' ? member.maxHp :
                                    bonusType === 'mana' ? member.maxMana :
                                    bonusType === 'attack' ? member.attack :
                                    bonusType === 'defense' ? member.defense :
                                    bonusType === 'attackSpeed' ? member.attackSpeed :
                                    bonusType === 'critChance' ? member.critChance :
                                    bonusType === 'critDamage' ? member.critDamage :
                                    bonusType === 'dodge' ? member.dodgeChance :
                                    bonusType === 'lifesteal' ? member.lifesteal :
                                    bonusType === 'manaRegen' ? member.manaRegen :
                                    bonusType === 'hpRegen' ? member.hpRegen :
                                    bonusType === 'cdr' ? member.cdr : 0;

                    console.log(`${member.name} ${bonusType}: ${oldValue} -> ${newValue}`);
            }

            removePetBonus(pet, member) {
                const bonus = pet.getCurrentBonus();
                const bonusType = pet.bonusType;

                console.log(`Removing pet bonus from ${member.name}: ${bonusType} -${bonus}`);
                    if (bonusType === 'attack') {
                        member.attack = Math.max(1, member.attack - bonus);
                    }
                    else if (bonusType === 'defense') {
                        member.defense = Math.max(0, member.defense - bonus);
                    }
                    else if (bonusType === 'hp') {
                        const hpPercent = member.hp / member.getTotalMaxHp();
                        member.maxHp = Math.max(10, member.maxHp - bonus);
                        member.hp = Math.round(member.getTotalMaxHp() * hpPercent);
                    }
                    else if (bonusType === 'mana') {
                        const manaPercent = member.mana / member.getTotalMaxMana();
                        member.maxMana = Math.max(10, member.maxMana - bonus);
                        member.mana = Math.round(member.getTotalMaxMana() * manaPercent);
                    }
                    else if (bonusType === 'attackSpeed') {
                        member.attackSpeed = Math.max(0.1, member.attackSpeed - (bonus / 100));
                    }
                    else if (bonusType === 'critChance') {
                        member.critChance = Math.max(0, member.critChance - bonus);
                    }
                    else if (bonusType === 'critDamage') {
                        member.critDamage = Math.max(100, member.critDamage - bonus);
                    }
                    else if (bonusType === 'dodge') {
                        member.dodgeChance = Math.max(0, member.dodgeChance - bonus);
                    }
                    else if (bonusType === 'lifesteal') {
                        member.lifesteal = Math.max(0, member.lifesteal - bonus);
                    }
                    else if (bonusType === 'manaRegen') {
                        member.manaRegen = Math.max(0, member.manaRegen - bonus);
                    }
                    else if (bonusType === 'hpRegen') {
                        member.hpRegen = Math.max(0, member.hpRegen - bonus);
                    }
                    else if (bonusType === 'cdr') {
                        member.cdr = Math.max(0, member.cdr - bonus);
                    }
            }

            rollKeystoneFromVault(vaultLevel) {
                // Rarity roll
                const roll = Math.random() * 100;
                let rarity;

                if (roll < 60) rarity = 'common';
                else if (roll < 85) rarity = 'uncommon';
                else if (roll < 95) rarity = 'rare';
                else if (roll < 99) rarity = 'epic';
                else rarity = 'legendary';

                // Random type - only from classes in party
                const partyClasses = this.party.map(m => m.className.toLowerCase());
                const type = partyClasses[Math.floor(Math.random() * partyClasses.length)];

                // Create keystone
                const keystone = new KeystoneItem(type, rarity, vaultLevel);
                this.keystones.push(keystone);

                const typeIcons = { tank: 'üõ°Ô∏è', healer: 'üíä', mage: 'üîÆ', rogue: 'üó°Ô∏è', archer: 'üèπ', paladin: '‚öîÔ∏è' };
                const typeNames = { tank: 'Tank', healer: 'Healer', mage: 'Mage', rogue: 'Rogue', archer: 'Archer', paladin: 'Paladin' };
                this.addLog(`Found ${typeIcons[type]} ${typeNames[type]} keystone: ${keystone.name}!`, 'loot');

                return keystone;
            }



showVaultKeyConfirmDialog(key, onConfirm) {
    const overlay = document.createElement('div');
    overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.95); display: flex; justify-content: center; align-items: center; z-index: 3500;';

    const panel = document.createElement('div');
    panel.style.cssText = 'background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(6, 9, 23, 0.98) 100%); border: 3px solid #f59e0b; border-radius: 20px; padding: 40px; text-align: center; box-shadow: 0 30px 80px rgba(0,0,0,0.9); max-width: 400px;';

    panel.innerHTML = `
        <div style="font-size: 48px; margin-bottom: 20px;">üîë</div>
        <div style="font-family: 'Orbitron', sans-serif; font-size: 28px; font-weight: 800; color: #f59e0b; margin-bottom: 20px;">ENTER VAULT?</div>
<div style="font-size: 18px; color: #fbbf24; margin-bottom: 10px; font-weight: 600;">Level ${key.level} Vault Key</div>
        <div style="font-size: 14px; color: #10b981; margin-bottom: 8px; font-weight: 600;">Recommended: Floor ${key.level * 5}</div>
        <div style="font-size: 14px; color: #94a3b8; margin-bottom: 30px;">This key will be consumed</div>
        <div style="display: flex; gap: 15px;">
            <button id="vault-confirm-enter" style="flex: 1; padding: 15px; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 10px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 16px; font-weight: 700;">ENTER</button>
            <button id="vault-confirm-cancel" style="flex: 1; padding: 15px; background: linear-gradient(135deg, #ef4444, #dc2626); color: white; border: none; border-radius: 10px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 16px; font-weight: 700;">CANCEL</button>
        </div>
    `;

    overlay.appendChild(panel);
    document.body.appendChild(overlay);

    document.getElementById('vault-confirm-enter').onclick = () => {
        overlay.remove();
        onConfirm();
    };

    document.getElementById('vault-confirm-cancel').onclick = () => {
        overlay.remove();
    };
}
showRuneTrialConfirmation(key) {
    const onConfirm = () => this.enterRuneTrialWithKey(key.id);

    const overlay = document.createElement('div');
    overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.95); display: flex; justify-content: center; align-items: center; z-index: 3500;';

    const panel = document.createElement('div');
    panel.style.cssText = 'background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(6, 9, 23, 0.98) 100%); border: 3px solid #3b82f6; border-radius: 20px; padding: 40px; text-align: center; box-shadow: 0 30px 80px rgba(0,0,0,0.9); max-width: 400px;';

    panel.innerHTML = `
        <div style="font-size: 48px; margin-bottom: 20px;">üîë</div>
        <div style="font-family: 'Orbitron', sans-serif; font-size: 28px; font-weight: 800; color: #f59e0b; margin-bottom: 20px;">ENTER RUNE TRIAL?</div>
        <div style="font-size: 18px; color: #fbbf24; margin-bottom: 10px; font-weight: 600;">Tier ${key.tier} Rune Trial Key</div>
        <div style="font-size: 14px; color: #10b981; margin-bottom: 8px; font-weight: 600;">Recommended: Level ${40 + key.tier * 10}</div>
        <div style="font-size: 14px; color: #94a3b8; margin-bottom: 30px;">This key will be consumed</div>
        <div style="display: flex; gap: 15px;">
            <button id="rune-trial-confirm-enter" style="flex: 1; padding: 15px; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 10px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 16px; font-weight: 700;">ENTER</button>
            <button id="rune-trial-confirm-cancel" style="flex: 1; padding: 15px; background: linear-gradient(135deg, #ef4444, #dc2626); color: white; border: none; border-radius: 10px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 16px; font-weight: 700;">CANCEL</button>
        </div>
    `;

    overlay.appendChild(panel);
    document.body.appendChild(overlay);

    document.getElementById('rune-trial-confirm-enter').onclick = () => {
        overlay.remove();
        onConfirm();
    };

    document.getElementById('rune-trial-confirm-cancel').onclick = () => {
        overlay.remove();
    };
}
enterRuneTrialWithKey(keyId) {
    // Prevent spam clicking (shared with Vault)
    const now = Date.now();
    if (this._lastSpecialDungeonUse && now - this._lastSpecialDungeonUse < 5000) {
        const remainingSeconds = Math.ceil((5000 - (now - this._lastSpecialDungeonUse)) / 1000);
        this.addLog(`Wait ${remainingSeconds}s before using another key`, 'damage');
        return;
    }

    const keyIndex = this.runeTrialKeys.findIndex(k => k.id === keyId);
    if (keyIndex === -1) return;

    this._lastSpecialDungeonUse = now;

    const key = this.runeTrialKeys[keyIndex];
    this.runeTrialKeys.splice(keyIndex, 1);

    this.currentDungeon = 'runetrial';
    this.runeTrialTier = key.tier;
    this.dungeonFloor = 1;
    this.lastDungeonChangeTime = Date.now();

    // Clear any existing dungeon layout and rooms
    this.hallways = [];
    this.adjacentRooms = [];
    this.enemies = [];

    // Reset character stats for Rune Trial
    if (!this.characterStats) this.characterStats = {};
    this.party.forEach(member => {
        if (!this.characterStats[member.name]) {
            this.characterStats[member.name] = {
                damageDealt: 0,
                healingDone: 0
            };
        } else {
            this.characterStats[member.name].damageDealt = 0;
            this.characterStats[member.name].healingDone = 0;
        }
    });

    // Create isolated Rune Trial room data
    this.currentRoomData = {
        type: ROOM_TYPES.BOSS,
        x: 0,
        y: 0,
        visited: true,
        cleared: false,
        connections: []
    };

    // Set dungeonLayout to NULL for Rune Trial
    this.dungeonLayout = null;

    // Create large Rune Trial room (30x30 for big boss arena) with icy blue floor
    this.room = new DungeonRoom(30, 30, ROOM_TYPES.BOSS, 'runetrial');

    // Override floor color to icy blue
    if (this.room && this.room.tiles) {
        this.room.tiles.forEach(tile => {
            tile.color = '#4a7c8a'; // Darker icy blue to match background
        });
    }

    // Clear the minimap
    this.mapCtx.fillStyle = '#000';
    this.mapCtx.fillRect(0, 0, this.mapCanvas.width, this.mapCanvas.height);

    // Show room label with blue theme
    const roomLabel = document.getElementById('room-label');
    roomLabel.style.display = 'block';
    roomLabel.textContent = `üîÆ Rune Trial - Tier ${key.tier}`;
    roomLabel.style.color = '#60a5fa'; // Blue color for Rune Trials

    // Restore party for Rune Trial fight - full heal and revive
this.party.forEach(member => {
    member.isAlive = true;
    member.hp = Math.round(member.getTotalMaxHp());
    member.mana = Math.round(member.getTotalMaxMana());
    // Force clean the base values too
    member.maxHp = Math.round(member.maxHp);
    member.maxMana = Math.round(member.maxMana);
    member.cooldown = 0;
    member.attackCooldown = 0;
    if (member.keystoneCooldown) member.keystoneCooldown = 0;
    member.shieldAmount = 0;
    member.phoenixUsedThisBattle = false;

    // Reset ability-specific cooldowns/buffs
    if (member.tauntActive) member.tauntActive = false;
    if (member.tauntTimer) member.tauntTimer = 0;
    if (member.sacredBarrierDefense) member.sacredBarrierDefense = 0;
    if (member.sacredBarrierTimer) member.sacredBarrierTimer = 0;
    if (member.berserkerActive) member.berserkerActive = false;
    if (member.berserkerTimer) member.berserkerTimer = 0;
});

    // Unpause the game
    this.paused = false;

    // Hide dungeon selector if it's open
    const selector = document.getElementById('dungeon-selector');
    if (selector) selector.style.display = 'none';

    // Set Rune Trial background
    console.log('üîÆ SETTING RUNE TRIAL BACKGROUND NOW');
    this.setDungeonBackground('runetrial', 'runetrial.png');
    console.log('üîÆ RUNE TRIAL BACKGROUND SET COMPLETE');

    // Position party in a circle around the pillar (15, 15)
    const formations = {
        0: {x: 15, y: 13},  // Tank - north of pillar
        1: {x: 13, y: 15},  // Healer - west of pillar
        2: {x: 17, y: 15},  // Mage - east of pillar
        3: {x: 15, y: 17}   // Rogue - south of pillar
    };

    this.party.forEach((member, i) => {
        if (member.sprite) {
            const pos = formations[i];
            member.sprite.moveTo(pos.x, pos.y, true);
            member.sprite.setCombatPosition(pos.x, pos.y);
        }
    });

    // DIRECTLY create pillar and boss setup

    // Initialize floor stats for Rune Trial
    this.floorStats = {
        startTime: Date.now(),
        damageDealt: 0,
        enemiesKilled: 0,
        goldEarned: 0,
        lootObtained: 0
    };

    // Initialize Rune Trial mechanics
    this.runeTrialPillarCharging = true;
    this.runeTrialPillarCharge = 0;
    this.runeTrialPillarMaxCharge = 3000; // 50 seconds at 60fps (10x longer)
    this.runeTrialBomberSpawnTimer = 120; // Start at max so first bomber spawns immediately
    this.runeTrialBomberSpawnRate = 120; // 2 seconds at 60fps
    this.runeTrialBossEnraged = false;
    this.runeTrialNextBomberId = 1;

    // Create pillar object
    this.runeTrialPillar = {
        gridX: 15,
        gridY: 15
    };

    // Create boss
    const boss = new Boss(this.runeTrialTier * 10, 'night_herald', 'umbral');
    boss.name = 'Rune Guardian';

    // Custom HP scaling per tier
    const hpByTier = {
        1: 500000,
        2: 600000,
        3: 700000,
        4: 800000,
        5: 1000000
    };

    // Custom Attack scaling per tier
    const atkByTier = {
        1: 100,
        2: 150,
        3: 200,
        4: 220,
        5: 300
    };

    // Defense: Use floor-based scaling for consistency
    const equivalentFloor = 40 + (this.runeTrialTier * 10);
    const defScaling = Math.min(Math.floor((4 + (equivalentFloor * 1.0) + (equivalentFloor * equivalentFloor * 0.005)) * 1.5), 200);

    boss.hp = hpByTier[this.runeTrialTier];
    boss.maxHp = hpByTier[this.runeTrialTier];
    boss.attack = atkByTier[this.runeTrialTier];
    boss.defense = defScaling;
    boss.attackSpeed = 0.6;
    boss.color = '#1e1b4b'; // Dark purple/black - menacing
    boss.xpReward = Math.floor(500 * this.runeTrialTier);
    boss.goldReward = this.runeTrialTier * 100;
    boss.isRuneTrialBoss = true;
    boss.isAlive = true;
    boss.isBig = true; // Mark as big boss
    boss.hasRedEyes = true; // Mark for red eye rendering
    boss.sprite = new CharacterSprite(15, 10, boss.color, 'enemy');
    boss.sprite.setCombatPosition(15, 10);
    boss.sprite.scale = 2.0; // Make it twice as big!

    // Store boss
    this.runeTrialBoss = boss;

    // Create pillar UI
    this.createRuneTrialPillarUI();

    // Mark room as not cleared
    this.currentRoomData.cleared = false;

    // DON'T START BATTLE - pillar must be charged first
    // Battle will start automatically when pillar is fully charged
    this.inBattle = false;

    this.addLog(`Entering Tier ${key.tier} Rune Trial! Activate the pillar to begin!`, 'room');

    // Update UI
    this.updateUI();

    // Update the chests display to remove the used key
    this.showChests();
}

enterVaultWithKeyConfirmed(keyId) {

    // Prevent spam clicking with 5 second cooldown (shared with Rune Trial)
    const now = Date.now();
    if (this._lastSpecialDungeonUse && now - this._lastSpecialDungeonUse < 5000) {
        const remainingSeconds = Math.ceil((5000 - (now - this._lastSpecialDungeonUse)) / 1000);
        this.addLog(`Wait ${remainingSeconds}s before using another key`, 'damage');
        return;
    }

    const keyIndex = this.vaultKeys.findIndex(k => k.id === keyId);
    if (keyIndex === -1) return;

    this._lastSpecialDungeonUse = now;

    const key = this.vaultKeys[keyIndex];
    this.vaultKeys.splice(keyIndex, 1);

    this.currentDungeon = 'vault';
    this.vaultLevel = key.level;
    this.dungeonFloor = 1;
    this.lastDungeonChangeTime = Date.now();

// Clear any existing dungeon layout and rooms FIRST
this.hallways = [];
this.adjacentRooms = [];
this.enemies = []; // Clear any existing enemies

// Reset character stats for Vault fight
if (!this.characterStats) this.characterStats = {};
this.party.forEach(member => {
    if (!this.characterStats[member.name]) {
        this.characterStats[member.name] = {
            damageDealt: 0,
            healingDone: 0
        };
    } else {
        this.characterStats[member.name].damageDealt = 0;
        this.characterStats[member.name].healingDone = 0;
    }
});

// Create isolated Vault room data
this.currentRoomData = {
    type: ROOM_TYPES.BOSS,
    x: 0,
    y: 0,
    visited: true,
    cleared: false,
    connections: []
};

// Set dungeonLayout to NULL for Vault - it's not a normal dungeon
this.dungeonLayout = null;

// Create large Vault room (30x30 for big boss arena) BEFORE unpausing
this.room = new DungeonRoom(30, 30, ROOM_TYPES.BOSS, 'vault');

// Clear the minimap since Vault has no dungeon layout
this.mapCtx.fillStyle = '#000';
this.mapCtx.fillRect(0, 0, this.mapCanvas.width, this.mapCanvas.height);

// Show room label
document.getElementById('room-label').style.display = 'block';
document.getElementById('room-label').textContent = `üîí Vault - Lvl ${key.level} Key`;

// Restore party for Vault fight - full heal and revive
this.party.forEach(member => {
    member.isAlive = true;
    member.hp = member.getTotalMaxHp();
    member.mana = member.getTotalMaxMana();
    member.cooldown = 0;
    member.attackCooldown = 0;
    if (member.keystoneCooldown) member.keystoneCooldown = 0;
    member.shieldAmount = 0;
    member.phoenixUsedThisBattle = false;

    // Reset ability-specific cooldowns/buffs
    if (member.tauntActive) member.tauntActive = false;
    if (member.tauntTimer) member.tauntTimer = 0;
    if (member.sacredBarrierDefense) member.sacredBarrierDefense = 0;
    if (member.sacredBarrierTimer) member.sacredBarrierTimer = 0;
    if (member.berserkerActive) member.berserkerActive = false;
    if (member.berserkerTimer) member.berserkerTimer = 0;
});

// Unpause the game AFTER everything is set up
this.paused = false;

// Hide dungeon selector if it's open
const selector = document.getElementById('dungeon-selector');
if (selector) selector.style.display = 'none';

// Set Vault background
console.log('üîë SETTING VAULT BACKGROUND NOW');
this.setDungeonBackground('vault', 'vault%20room.png');
console.log('üîë VAULT BACKGROUND SET COMPLETE');

    const formations = {
        0: {x: 15, y: 20},  // Tank front center
        1: {x: 13, y: 21},  // Healer back left
        2: {x: 14, y: 22},  // Mage back center
        3: {x: 16, y: 22}   // Rogue back right
    };

    this.party.forEach((member, i) => {
        if (member.sprite) {
            const pos = formations[i];
            member.sprite.moveTo(pos.x, pos.y, true);
            member.sprite.setCombatPosition(pos.x, pos.y);
        }
    });

    this.spawnVaultBoss();

    // Mark room as not cleared so battle triggers properly
    this.currentRoomData.cleared = false;

    // Ensure enemies array is populated before battle
this.updateUI();

// Start battle immediately - boss should already be spawned
if (this.enemies.length > 0 && this.enemies[0].isAlive) {
    setTimeout(() => this.startBattle(), 500);
} else {
    console.error('Vault boss failed to spawn!');
    this.addLog('ERROR: Vault boss failed to spawn!', 'damage');
}

    this.addLog(`Using Level ${key.level} Vault Key! Entering boss fight...`, 'room');

    // Update UI
    this.updateUI();

    // Update the chests display to remove the used key
    this.showChests();
}

            showKeystoneSelector() {
                const overlay = document.createElement('div');
                overlay.id = 'keystone-selector-overlay';
                overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.95); display: flex; justify-content: center; align-items: center; z-index: 3000;';

                const panel = document.createElement('div');
                panel.style.cssText = 'background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(6, 9, 23, 0.98) 100%); border: 2px solid #f59e0b; border-radius: 20px; padding: 40px; max-width: 600px;';

                let html = '<h2 style="font-family: Orbitron; color: #f59e0b; text-align: center; margin-bottom: 20px;">üîë Select Keystone</h2>';

                this.keystones.forEach(keystone => {
                    const difficulty = Math.floor(keystone.level * KEYSTONE_CONFIG.DIFFICULTY_MULTIPLIER);
                    html += `
                        <div class="keystone-option" data-keystone-id="${keystone.id}" style="background: linear-gradient(135deg, rgba(30, 41, 59, 0.9), rgba(15, 23, 42, 0.9)); border: 2px solid #f59e0b; border-radius: 12px; padding: 20px; margin: 15px 0; cursor: pointer; transition: all 0.3s ease;">
                            <div style="font-weight: 700; font-size: 16px; color: #f59e0b;">Level ${keystone.level} Keystone</div>
                            <div style="font-size: 12px; color: #94a3b8; margin-top: 8px;">Vault Difficulty: ~Floor ${difficulty}</div>
                            <div style="font-size: 11px; color: #64748b; margin-top: 4px;">Guaranteed: ${KEYSTONE_CONFIG.RARITY_BOOST.rare}% Rare, ${KEYSTONE_CONFIG.RARITY_BOOST.epic}% Epic, ${KEYSTONE_CONFIG.RARITY_BOOST.legendary}% Legendary</div>
                        </div>
                    `;
                });

                html += '<button onclick="document.getElementById(\'keystone-selector-overlay\').remove()" style="width: 100%; margin-top: 20px; padding: 12px; background: #ef4444; color: white; border: none; border-radius: 8px; cursor: pointer;">Cancel</button>';

                panel.innerHTML = html;
                overlay.appendChild(panel);
                document.body.appendChild(overlay);

                document.querySelectorAll('.keystone-option').forEach(opt => {
                    opt.addEventListener('click', () => {
                        const keystoneId = parseInt(opt.getAttribute('data-keystone-id'));
                        this.enterVault(keystoneId);
                        overlay.remove();
                    });

                    opt.addEventListener('mouseenter', (e) => {
                        e.target.style.background = 'linear-gradient(135deg, rgba(51, 65, 85, 0.9), rgba(30, 41, 59, 0.9))';
                        e.target.style.transform = 'translateX(10px)';
                    });

                    opt.addEventListener('mouseleave', (e) => {
                        e.target.style.background = 'linear-gradient(135deg, rgba(30, 41, 59, 0.9), rgba(15, 23, 42, 0.9))';
                        e.target.style.transform = 'translateX(0)';
                    });
                });
            }

            enterVault(keystoneId) {
                console.log('üö™ ENTER VAULT FUNCTION CALLED! Key ID:', keystoneId);
                const keystoneIndex = this.keystones.findIndex(k => k.id === keystoneId);
                if (keystoneIndex === -1) return;

                const keystone = this.keystones[keystoneIndex];
                this.keystones.splice(keystoneIndex, 1);

                this.currentDungeon = 'vault';
                this.vaultLevel = keystone.level;
                this.dungeonFloor = 1;
                this.lastDungeonChangeTime = Date.now();

                this.hideDungeonSelector();
                document.getElementById('room-label').style.display = 'block';

                this.currentRoomData = {
                    type: ROOM_TYPES.BOSS,
                    x: 0,
                    y: 0,
                    visited: true,
                    cleared: false,
                    connections: []
                };

                this.room = new DungeonRoom(20, 20, ROOM_TYPES.BOSS, 'vault');
                document.getElementById('room-label').textContent = `üîë Keystone Vault - Level ${this.vaultLevel}`;

                const formations = {
                    0: {x: 10, y: 14},
                    1: {x: 8, y: 14},
                    2: {x: 9, y: 15},
                    3: {x: 11, y: 15}
                };

                this.party.forEach((member, i) => {
                    if (member.sprite) {
                        const pos = formations[i];
                        member.sprite.moveTo(pos.x, pos.y, true);
                        member.sprite.setCombatPosition(pos.x, pos.y);
                    }
                });

                // Set Vault background IMMEDIATELY (no timeout needed)
                console.log('üîë ABOUT TO SET VAULT BACKGROUND');
                this.setDungeonBackground('vault', 'vault%20room.png');
                console.log('üîë VAULT BACKGROUND CALL COMPLETE');

                this.spawnVaultBoss();
                setTimeout(() => this.startBattle(), 1500);
                this.addLog(`Entering Level ${keystone.level} Keystone Vault!`, 'room');
            }

selectDungeon(dungeonType) {
    // Special handling for vault/rune trial - just show keys tab, don't actually select dungeon
    if (dungeonType === 'vault') {
        this.hideDungeonSelector();
        this.switchTab('chests');

        // Switch to vault keys sub-tab
        document.querySelectorAll('.cache-sub-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.cache-section').forEach(s => s.style.display = 'none');
        document.querySelector('[data-cache-tab="keys"]').classList.add('active');
        document.getElementById('cache-keys-section').style.display = 'block';

        // Just show a message about selecting a key
        if (this.vaultKeys.length === 0) {
            this.addLog('No Vault Keys! Find keys by clearing dungeon floors (10% chance).', 'room');
        } else {
            this.addLog('Select a Vault Key to enter the Vault', 'room');
        }
        return; // Exit - don't do anything else!
    }

    if (dungeonType === 'runetrial') {
        this.hideDungeonSelector();
        this.switchTab('chests');

        // Switch to rune keys sub-tab
        document.querySelectorAll('.cache-sub-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.cache-section').forEach(s => s.style.display = 'none');
        document.querySelector('[data-cache-tab="rune-keys"]').classList.add('active');
        document.getElementById('cache-rune-keys-section').style.display = 'block';

        // Just show a message about selecting a key
        if (this.runeTrialKeys.length === 0) {
            this.addLog('No Rune Trial Keys! Keys drop from floor 45+ (10% chance).', 'room');
        } else {
            this.addLog('Select a Rune Trial Key to enter the Rune Trial', 'room');
        }
        return; // Exit - don't do anything else!
    }

    // Handle Divine Arena dungeon
    if (dungeonType === 'endlessblessings') {
        console.log('üåü Entering Divine Arena dungeon...');

        // CHECK COOLDOWN FIRST - same as other dungeons
        if (this.currentDungeon) {
            const now = Date.now();
            const timeSinceLastChange = now - this.lastDungeonChangeTime;

            if (timeSinceLastChange < this.dungeonChangeCooldown) {
                const remainingSeconds = Math.ceil((this.dungeonChangeCooldown - timeSinceLastChange) / 1000);
                this.addLog(`Please wait ${remainingSeconds} seconds before changing dungeons.`, 'room');
                return;
            }
        }

        // COMPREHENSIVE STATE CLEANUP
        // 1. Clear all enemies and combat state
        this.enemies = [];
        this.inBattle = false; // Start false, will set to true after setup
        this.battleStartTime = 0;
        this.battleTimer = 0;

        // 2. CRITICAL: Clear enemy health bars UI - do this multiple times to ensure cleanup
        const healthBarContainer = document.getElementById('enemy-health-bars');
        if (healthBarContainer) {
            healthBarContainer.innerHTML = '';
            healthBarContainer.style.display = 'none';
            // Force a reflow to ensure the DOM updates
            void healthBarContainer.offsetHeight;
            healthBarContainer.style.display = 'flex';
        }

        // 3. Clear any previous dungeon-specific state
        this.runeTrialBoss = null;
        this.runeTrialPillarCharging = false;
        this.runeTrialPillarCharge = 0;
        this.runeTrialBossEnraged = false;
        this.vaultBoss = null;

        // 4. Clear rooms and dungeon layout - NO MAP for endless mode
        if (this.room) {
            this.room = null;
        }
        this.hallways = [];
        this.adjacentRooms = [];
        this.currentRoomData = null;
        this.dungeonLayout = null; // No dungeon layout - just single arena

        // Hide minimap for endless mode
        const minimapCanvas = document.getElementById('map-canvas');
        if (minimapCanvas) {
            minimapCanvas.style.display = 'none';
            // Clear the canvas
            const ctx = minimapCanvas.getContext('2d');
            if (ctx) {
                ctx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            }
        }

        // 5. Reset visual effects
        this.visualEffects = [];
        this._unitPositionsChanged = true;

        // 6. CRITICAL: Set dungeon BEFORE doing anything else
        this.currentDungeon = 'endlessblessings';
        this.dungeonFloor = 60; // Start at floor 60 (level 60 enemies)

        // 7. CRITICAL: Fully heal and revive all party members (like Vault)
        this.party.forEach(member => {
            // Revive all members
            member.isAlive = true;
            member.hp = member.getTotalMaxHp();
            member.mana = member.getTotalMaxMana();
            member.cooldown = 0;
            member.attackCooldown = 0;
            member.keystoneCooldown = 0;
            member.tauntActive = false;
            member.tauntTimer = 0;
            member.shieldAmount = 0;
            member.phoenixUsedThisBattle = false;

            // Reset ability-specific cooldowns/buffs (like Vault)
            if (member.sacredBarrierDefense) member.sacredBarrierDefense = 0;
            if (member.sacredBarrierTimer) member.sacredBarrierTimer = 0;
            if (member.berserkerActive) member.berserkerActive = false;
            if (member.berserkerTimer) member.berserkerTimer = 0;

            // Reset sprite if it exists
            if (member.sprite) {
                member.sprite.attacking = false;
                member.sprite.moving = false;
            }
        });

        this.hideDungeonSelector();

        // 8. Initialize endless dungeon specific variables - CONTINUOUS WAVE SYSTEM
        this.endlessKillCount = 0;
        this.endlessWave = 1; // Start at wave 1
        this.endlessEnemyLevel = 60; // Wave 1 = level 60
        this.endlessMinEnemies = 2; // Always keep at least 2 enemies alive
        this.endlessMaxEnemies = 3; // Maximum 3 enemies at once
        this.endlessEnemiesKilledThisWave = 0;
        this.endlessEnemiesPerWave = 5; // 5 kills = 1 wave = 1 blessing

        // Initialize character combat statistics tracking for endless arena
        this.characterStats = {};
        this.party.forEach(member => {
            this.characterStats[member.name] = {
                damageDealt: 0,
                healingDone: 0
            };
        });
        this.characterStatsDisplayMode = 'damage'; // 'damage' or 'healing'

        // 9. Set background
        const dungeonBackgrounds = {
            everfall: 'everfall.png',
            stoneforge: 'stoneforge.png',
            umbral: 'umbral%20depths1.png',
            vault: 'vault%20room.png',
            runetrial: 'vault%20room.png',
            endlessblessings: 'everfall.png'
        };

        this.setDungeonBackground('endlessblessings', dungeonBackgrounds.endlessblessings);

        // 10. Create large open world room (20x20 instead of 10x10) - AFTER setting currentDungeon
        this.room = new DungeonRoom(20, 20, 'normal', this.currentDungeon);

        // 11. Position party members in the center-left of the open world
        this.party.forEach((member, i) => {
            if (member.sprite) {
                const startX = 5;
                const startY = 8 + (i % 3);
                // Set position directly - no setGridPosition method exists
                member.sprite.gridX = startX;
                member.sprite.gridY = startY;
                member.sprite.targetX = startX;
                member.sprite.targetY = startY;
                member.sprite.combatX = startX;
                member.sprite.combatY = startY;
            }
        });

        // 12. Show room label - simple arena name
        document.getElementById('room-label').style.display = 'block';
        this.updateRoomLabel({
            type: 'normal',
            name: `Divine Arena`
        });

        // 13. Update UI to show healed stats
        this.rebuildUI();

        // 14. Set cooldown timestamp
        this.lastDungeonChangeTime = Date.now();

        // 15. NOW set battle mode and spawn enemies
        this.inBattle = true;
        this.battleStartTime = Date.now();

        // Show kill counter
        const killCounter = document.getElementById('kill-counter');
        if (killCounter) {
            killCounter.style.display = 'flex';
            killCounter.textContent = '0 Kills';
        }

        // Show End Run button for Divine Arena
        const endRunBtn = document.getElementById('end-run-btn');
        if (endRunBtn) {
            endRunBtn.style.display = 'block';
        }

        // Show damage stats display
        const combatStatsContainer = document.getElementById('combat-stats-container');
        const damageStatsDisplay = document.getElementById('damage-stats-display');
        if (combatStatsContainer) {
            combatStatsContainer.style.display = 'flex';
        }
        if (damageStatsDisplay) {
            this.updateCharacterStatsDisplay();
        }

        // Spawn initial 5 enemies immediately
        console.log('üåü Spawning initial wave...');

        // SAFETY CHECK: Ensure no weak enemies exist before spawning
        if (this.enemies.length > 0) {
            const weakEnemies = this.enemies.filter(e => e.maxHp < 5000);
            if (weakEnemies.length > 0) {
                console.warn(`‚ö†Ô∏è Clearing ${weakEnemies.length} weak enemies before spawning`);
                this.enemies = this.enemies.filter(e => e.maxHp >= 5000);
            }
        }

        this.spawnEndlessEnemyBatch(3);

        this.addLog('‚öîÔ∏è Divine Arena! Survive endless waves!', 'room');
        this.addLog('üíé Blessing Rewards: 1/kill (1-19), 2/kill (20-29), 3/kill (30-39), 4/kill (40-49), 5/kill (50+)', 'loot');
        console.log('‚úÖ Divine Arena setup complete!');
        console.log(`   - Enemy Level: ${this.endlessEnemyLevel}`);
        console.log(`   - Enemies: ${this.enemies.length}/${this.endlessMaxEnemies}`);
        console.log(`   - Battle Mode: ${this.inBattle}`);
        return;
    }

    // For NORMAL dungeons (everfall, stoneforge, umbral), check cooldown before doing anything
    if (this.currentDungeon) {
        const now = Date.now();
        const timeSinceLastChange = now - this.lastDungeonChangeTime;

        if (timeSinceLastChange < this.dungeonChangeCooldown) {
            const remainingSeconds = Math.ceil((this.dungeonChangeCooldown - timeSinceLastChange) / 1000);
            this.addLog(`‚è≥ Cannot change dungeon yet. Wait ${remainingSeconds}s`, 'room');
            return; // Exit WITHOUT clearing any state
        }
    }

    // ONLY clear state if we're actually changing dungeons (not vault/rune trial)
    this.enemies = [];
    this.inBattle = false;
    this.battleStartTime = 0;
    if (this.room) {
        this.room = null;
    }

    // Block dungeon selection if currently in Vault or Rune Trial
    if (this.currentDungeon === 'vault') {
        this.addLog('You are locked in the Vault! Defeat the boss or die to leave.', 'damage');
        return;
    }

    if (this.currentDungeon === 'runetrial') {
        this.addLog('You are locked in the Rune Trial! Defeat the boss or die to leave.', 'damage');
        return;
    }

                // Normal dungeon changes - cooldown already checked at start of function
                const now = Date.now();

                // Set dungeon type AND floor together immediately
                this.currentDungeon = dungeonType;

                // Use the dungeon-specific start floor from progress
                if (this.dungeonProgress[dungeonType]) {
                    this.dungeonFloor = this.dungeonProgress[dungeonType].startFloor;
                } else {
                    // Fallback for non-tracked dungeons
                    this.dungeonFloor = Math.max(1, this.globalStats.farthestFloor - 9);
                }

                console.log(`üéØ Dungeon Switch: ${dungeonType} | Floor: ${this.dungeonFloor}`);

                this.lastDungeonChangeTime = now;
                this.hideDungeonSelector();

                // Set dungeon background image
                const dungeonBackgrounds = {
                    everfall: 'everfall.png',
                    stoneforge: 'stoneforge.png',
                    umbral: 'umbral%20depths1.png',
                    vault: 'vault%20room.png',
                    runetrial: 'vault%20room.png' // Using same for now
                };

                this.setDungeonBackground(dungeonType, dungeonBackgrounds[dungeonType]);

                // Clear previous dungeon rooms and enemies
                this.hallways = [];
                this.adjacentRooms = [];
                this.enemies = []; // Ensure enemies array is cleared again

                // Show room label now that dungeon is selected
                document.getElementById('room-label').style.display = 'block';

                // Update current dungeon display
                const dungeonNames = {
                    umbral: 'üåë Umbral Depths',
                    everfall: '‚öîÔ∏è Everfall',
                    stoneforge: 'üî• Stoneforge'
                };
                document.getElementById('current-dungeon-display').textContent = dungeonNames[dungeonType] || 'Unknown';
                document.getElementById('current-floor-display').textContent = this.dungeonFloor;

                // Full heal, revive, and reset party for new dungeon
this.party.forEach((member, i) => {
    member.isAlive = true;
    member.hp = member.getTotalMaxHp();
    member.mana = member.getTotalMaxMana();
    member.cooldown = 0;
    if (member.keystoneCooldown) member.keystoneCooldown = 0;

    // Reset ability-specific cooldowns/buffs
    if (member.tauntActive) member.tauntActive = false;
    if (member.tauntTimer) member.tauntTimer = 0;

    // Reset party positions to starting formation
    if (member.sprite) {
        const formations = {
            0: {x: 5, y: 7}, // Tank
            1: {x: 3, y: 7}, // Healer
            2: {x: 4, y: 8}, // Mage
            3: {x: 6, y: 8}  // Rogue
        };
        const pos = formations[i];
        member.sprite.moveTo(pos.x, pos.y, true); // instant move
        member.sprite.setCombatPosition(pos.x, pos.y);
    }
});

this.generateDungeon();
            }

generateDungeon() {
                // Ensure clean slate for new dungeon - clear all flags and state
                this.enemies = [];
                this.inBattle = false;
                this.movingToNextRoom = false;  // Reset room movement flag
                this.battleTimer = 0;

                console.log(`üè∞ Generating Dungeon: ${this.currentDungeon} | Floor: ${this.dungeonFloor}`);

                this.dungeonLayout = new DungeonLayout(this.dungeonFloor);
                const startRoom = this.dungeonLayout.getCurrentRoom();

                // Clear previous dungeon rooms
                this.hallways = [];
                this.adjacentRooms = [];

                // Reset floor stats when starting a new floor
                this.floorStats = {
                    startTime: Date.now(),
                    damageDealt: 0,
                    enemiesKilled: 0,
                    goldEarned: 0,
                    lootObtained: 0
                };

                // Reset character stats at the start of each floor
                if (!this.characterStats) this.characterStats = {};
                this.party.forEach(member => {
                    if (!this.characterStats[member.name]) {
                        this.characterStats[member.name] = {
                            damageDealt: 0,
                            healingDone: 0
                        };
                    } else {
                        // Reset stats for new floor - stats will accumulate across all rooms in this floor
                        this.characterStats[member.name].damageDealt = 0;
                        this.characterStats[member.name].healingDone = 0;
                    }
                });

                this.enterRoom(startRoom);
                this.drawMinimap();
                this.updateRoomLabel(startRoom);
            }

enterRoom(roomData) {
                // Safety check for null roomData
                if (!roomData) {
                    console.error('enterRoom called with null roomData');
                    return;
                }

                console.log(`üö™ Entering Room: Type=${roomData.type} | Dungeon=${this.currentDungeon} | Floor=${this.dungeonFloor}`);

                // Clear any existing enemies from previous room
                this.enemies = [];
                this.inBattle = false;

                // Generate hallway connections and adjacent rooms
                this.currentRoomData = roomData;
                this.hallways = [];
                this.adjacentRooms = [];

                // Real-time regen now happens during combat, no need for between-room burst

                // Create main room
                this.room = new DungeonRoom(10, 10, roomData.type, this.currentDungeon);
                this.updateRoomLabel(roomData);

                // Create visible hallways and adjacent rooms based on actual connections
                if (roomData.connections && roomData.connections.length > 0) {
                    roomData.connections.forEach((connection, index) => {
                        const connectedRoom = this.dungeonLayout.rooms.find(r => r.x === connection.x && r.y === connection.y);
                        if (connectedRoom) {
                            // Determine direction based on grid position difference
                            const dx = connection.x - roomData.x;
                            const dy = connection.y - roomData.y;

                            // Create hallway and adjacent room preview
                            if (dx === 1 && dy === 0) { // Right
                                // Hallway to the right
                                this.hallways.push({
                                    room: new DungeonRoom(4, 10, ROOM_TYPES.PATHWAY, this.currentDungeon),
                                    offsetX: 10,
                                    offsetY: 0,
                                    direction: 'right'
                                });

                                // Adjacent room preview (darkened)
                                if (!connectedRoom.visited) {
                                    this.adjacentRooms.push({
                                        room: new DungeonRoom(8, 8, ROOM_TYPES.EMPTY, this.currentDungeon),
                                        offsetX: 14,
                                        offsetY: 1,
                                        alpha: 0.3
                                    });
                                } else {
                                    this.adjacentRooms.push({
                                        room: new DungeonRoom(8, 8, connectedRoom.type, this.currentDungeon),
                                        offsetX: 14,
                                        offsetY: 1,
                                        alpha: connectedRoom.cleared ? 0.5 : 0.4
                                    });
                                }
                            } else if (dx === -1 && dy === 0) { // Left
                                // Hallway to the left
                                this.hallways.push({
                                    room: new DungeonRoom(4, 10, ROOM_TYPES.PATHWAY, this.currentDungeon),
                                    offsetX: -4,
                                    offsetY: 0,
                                    direction: 'left'
                                });

                                // Adjacent room preview
                                if (!connectedRoom.visited) {
                                    this.adjacentRooms.push({
                                        room: new DungeonRoom(8, 8, ROOM_TYPES.EMPTY, this.currentDungeon),
                                        offsetX: -12,
                                        offsetY: 1,
                                        alpha: 0.3
                                    });
                                } else {
                                    this.adjacentRooms.push({
                                        room: new DungeonRoom(8, 8, connectedRoom.type, this.currentDungeon),
                                        offsetX: -12,
                                        offsetY: 1,
                                        alpha: connectedRoom.cleared ? 0.5 : 0.4
                                    });
                                }
                            } else if (dx === 0 && dy === 1) { // Down (in grid = up-right in isometric)
                                // Hallway down-right in isometric view
                                this.hallways.push({
                                    room: new DungeonRoom(10, 4, ROOM_TYPES.PATHWAY, this.currentDungeon),
                                    offsetX: 0,
                                    offsetY: 10,
                                    direction: 'down'
                                });

                                // Adjacent room preview
                                if (!connectedRoom.visited) {
                                    this.adjacentRooms.push({
                                        room: new DungeonRoom(8, 8, ROOM_TYPES.EMPTY, this.currentDungeon),
                                        offsetX: 1,
                                        offsetY: 14,
                                        alpha: 0.3
                                    });
                                } else {
                                    this.adjacentRooms.push({
                                        room: new DungeonRoom(8, 8, connectedRoom.type, this.currentDungeon),
                                        offsetX: 1,
                                        offsetY: 14,
                                        alpha: connectedRoom.cleared ? 0.5 : 0.4
                                    });
                                }
                            } else if (dx === 0 && dy === -1) { // Up (in grid = down-left in isometric)
                                // Hallway up-left in isometric view
                                this.hallways.push({
                                    room: new DungeonRoom(10, 4, ROOM_TYPES.PATHWAY, this.currentDungeon),
                                    offsetX: 0,
                                    offsetY: -4,
                                    direction: 'up'
                                });

                                // Adjacent room preview
                                if (!connectedRoom.visited) {
                                    this.adjacentRooms.push({
                                        room: new DungeonRoom(8, 8, ROOM_TYPES.EMPTY, this.currentDungeon),
                                        offsetX: 1,
                                        offsetY: -12,
                                        alpha: 0.3
                                    });
                                } else {
                                    this.adjacentRooms.push({
                                        room: new DungeonRoom(8, 8, connectedRoom.type, this.currentDungeon),
                                        offsetX: 1,
                                        offsetY: -12,
                                        alpha: connectedRoom.cleared ? 0.5 : 0.4
                                    });
                                }
                            }
                        }
                    });
                }

                // Reset party positions to formation - bottom center of room
                const formations = {
                    0: {x: 5, y: 7}, // Tank - front line center bottom
                    1: {x: 3, y: 7}, // Healer - back line left
                    2: {x: 4, y: 8}, // Mage - back line center
                    3: {x: 6, y: 8}  // Rogue - back line right
                };

                this.party.forEach((member, i) => {
                    if (member.sprite && member.isAlive) {
                        const pos = formations[i];
                        member.sprite.moveTo(pos.x, pos.y, true); // instant move
                        member.sprite.setCombatPosition(pos.x, pos.y);
                    }
                });

// Spawn enemies based on room type
if (roomData.type === ROOM_TYPES.NORMAL && !roomData.cleared) {
    this.spawnEnemies('normal');
    this.inBattle = false; // Ensure battle flag is reset
    this.movingToNextRoom = false; // Reset movement flag

    // Initialize character stats if needed
    if (!this.characterStats) this.characterStats = {};
    this.party.forEach(member => {
        if (!this.characterStats[member.name]) {
            this.characterStats[member.name] = { damageDealt: 0, healingDone: 0 };
        }
    });
    if (!this.characterStatsDisplayMode) this.characterStatsDisplayMode = 'damage';

    setTimeout(() => this.startBattle(), 1000);
} else if (roomData.type === ROOM_TYPES.TREASURE && !roomData.cleared) {
    // Show treasure room popup if enabled
    if (this.treasurePopupEnabled) {
        this.showTreasurePopup();
    }
    this.spawnEnemies('treasure');
    this.inBattle = false; // Ensure battle flag is reset
    this.movingToNextRoom = false; // Reset movement flag

    // Initialize character stats if needed
    if (!this.characterStats) this.characterStats = {};
    this.party.forEach(member => {
        if (!this.characterStats[member.name]) {
            this.characterStats[member.name] = { damageDealt: 0, healingDone: 0 };
        }
    });
    if (!this.characterStatsDisplayMode) this.characterStatsDisplayMode = 'damage';

    setTimeout(() => this.startBattle(), 1000);
} else if (roomData.type === ROOM_TYPES.BOSS && !roomData.cleared) {
    this.spawnBoss();
    this.inBattle = false; // Ensure battle flag is reset
    this.movingToNextRoom = false; // Reset movement flag

    // Initialize character stats if needed
    if (!this.characterStats) this.characterStats = {};
    this.party.forEach(member => {
        if (!this.characterStats[member.name]) {
            this.characterStats[member.name] = { damageDealt: 0, healingDone: 0 };
        }
    });
    if (!this.characterStatsDisplayMode) this.characterStatsDisplayMode = 'damage';

    setTimeout(() => this.startBattle(), 1500);
} else if (roomData.type === ROOM_TYPES.FOUNTAIN && !roomData.cleared) {
    // Fountain of Youth - revive and heal 40% (only once)
    roomData.cleared = true; // Mark as used immediately
    this.addLog('Fountain of Youth! Party is recovering...', 'heal');

    // Show fountain popup if enabled
    if (this.fountainPopupEnabled) {
        this.showFountainPopup();
    }

    // Apply healing immediately
    this.party.forEach(member => {
        // Revive dead members
        member.isAlive = true;

        // Restore 40% of MAX HP/Mana (including equipment bonuses)
        const maxHp = member.getTotalMaxHp();
        const maxMana = member.getTotalMaxMana();

        member.hp = Math.min(maxHp, member.hp + Math.floor(maxHp * 0.4));
        member.mana = Math.min(maxMana, member.mana + Math.floor(maxMana * 0.4));

        // Ensure HP is at least 1 for revived members
        if (member.hp <= 0) {
            member.hp = Math.floor(maxHp * 0.4);
        }
    });

    this.addLog('Party restored 40% HP and Mana!', 'heal');
    this.updateUI();

    // Auto-progress after healing (with delay for popup if enabled)
    const delay = this.fountainPopupEnabled ? 2000 : 1000;
    if (this.hasUnvisitedRooms()) {
        setTimeout(() => {
            if (!this.inBattle && !this.movingToNextRoom) {
                this.moveToNextRoom();
            }
        }, delay);
    }
} else if (roomData.type === ROOM_TYPES.ENTRANCE || roomData.cleared) {
                    // No enemies, auto-progress after short delay
                    this.addLog('Room is clear', 'room');
                    // Only auto-progress if not in Vault (Vault has no dungeon layout)
                    if (this.hasUnvisitedRooms() && this.currentDungeon !== 'vault') {
                        setTimeout(() => {
                            if (!this.inBattle && !this.movingToNextRoom) {
                                this.moveToNextRoom();
                            }
                        }, 2000);
                    }
                }

                this.drawMinimap();
            }


updateRoomLabel(roomData) {
                const roomTypes = {
                    [ROOM_TYPES.ENTRANCE]: 'Entrance',
                    [ROOM_TYPES.NORMAL]: 'Chamber',
                    [ROOM_TYPES.TREASURE]: 'Treasury',
                    [ROOM_TYPES.BOSS]: 'Boss Lair',
                    [ROOM_TYPES.FOUNTAIN]: 'Fountain of Youth'
                };

                const dungeonNames = {
                    umbral: 'Umbral Depths',
                    everfall: 'Everfall',
                    stoneforge: 'Stoneforge',
                    endlessblessings: 'Divine Arena'
                };

                // Check if roomData has a custom name (for endless dungeon)
                if (roomData.name) {
                    document.getElementById('room-label').textContent = roomData.name;
                } else {
                    const dungeonName = dungeonNames[this.currentDungeon] || 'Unknown';
                    document.getElementById('room-label').textContent =
                        `${dungeonName} - Floor ${this.dungeonFloor} - ${roomTypes[roomData.type] || 'Unknown'}`;
                }
            }

spawnEnemies(roomType) {
    console.log(`üëπ Spawning Enemies: Dungeon=${this.currentDungeon} | Floor=${this.dungeonFloor} | Room=${roomType}`);

    // Reset phoenix flag at the start of each battle
    this.party.forEach(member => {
        if (member.phoenixUsedThisBattle !== undefined) {
            member.phoenixUsedThisBattle = false;
        }
    });

    // Enemy pools by dungeon
    const dungeonPools = {
        everfall: ['forest_wolf', 'bandit_cutthroat', 'moss_boar', 'hollow_stag', 'rotting_treant', 'briar_spider', 'fallen_scout', 'autumn_wisp'],
        stoneforge: ['forge_golem', 'ember_sprite', 'tunnel_rat', 'quarry_brute', 'anvil_guard', 'smelter_imp', 'oreback_beetle', 'molten_slime'],
        umbral: ['shade', 'gloomling', 'night_stalker', 'void_mite', 'abyssal_leech', 'umbral_wisp', 'dread_bat', 'hollow_cultist']
    };

    const types = dungeonPools[this.currentDungeon] || dungeonPools.everfall;

    // Enemy count based on floor level and room type
    let count;
    if (roomType === 'treasure') {
        // Treasure rooms scale with floor level
        if (this.dungeonFloor <= 5) {
            count = 1;
        } else if (this.dungeonFloor <= 20) {
            count = 2;
        } else if (this.dungeonFloor <= 60) {
            count = 3;
        } else {
            count = 4;
        }

        // Spawn Treasure Guardians instead of normal enemies
        this.enemies = [];
        this._unitPositionsChanged = true;

        for (let i = 0; i < count; i++) {
            const enemy = new Enemy('treasure_guardian', this.dungeonFloor, this.currentDungeon, true);

            // Position enemies in formation on the right side
            const xPos = 6 - Math.floor(i / 2);
            const yPos = 3 + (i % 3);

            enemy.sprite = new CharacterSprite(xPos, yPos, enemy.color, 'enemy');
            enemy.sprite.setCombatPosition(xPos, yPos);
            this.enemies.push(enemy);
        }

        this.addLog(`${count} Treasure Guardians appear!`, 'room');
        return;
    } else {
        // Normal rooms have variable counts
        let minEnemies, maxEnemies;
        if (this.dungeonFloor <= 5) {
            minEnemies = 2;
            maxEnemies = 3;
        } else if (this.dungeonFloor <= 10) {
            minEnemies = 2;
            maxEnemies = 4;
        } else {
            minEnemies = 2;
            maxEnemies = 5;
        }

        count = minEnemies + Math.floor(Math.random() * (maxEnemies - minEnemies + 1));

        // Umbral spawns more enemies
        if (this.currentDungeon === 'umbral') {
            count += Math.floor(2 + Math.random() * 4); // +2 to +5 enemies
        }
    }

    this.enemies = [];
    this._unitPositionsChanged = true; // New enemies spawned
    for (let i = 0; i < count; i++) {
        const type = types[Math.floor(Math.random() * types.length)];
        const enemy = new Enemy(type, this.dungeonFloor, this.currentDungeon, false);

        // Position enemies in formation on the right side
        const xPos = 6 - Math.floor(i / 2);
        const yPos = 3 + (i % 3);

        enemy.sprite = new CharacterSprite(xPos, yPos, enemy.color, 'enemy');
        enemy.sprite.setCombatPosition(xPos, yPos);
        this.enemies.push(enemy);
    }

    this.addLog(`${count} enemies appear!`, 'room');
}

spawnRuneTrialBoss() {
    console.log('üîµ spawnRuneTrialBoss() called!');

    const tier = this.runeTrialTier;
    console.log('Tier:', tier);
    this._unitPositionsChanged = true;

    console.log('=== SPAWNING RUNE TRIAL BOSS ===');

    // Initialize Rune Trial mechanics
    this.runeTrialPillarCharging = true;
    this.runeTrialPillarCharge = 0;
    this.runeTrialPillarMaxCharge = 300; // 5 seconds at 60fps
    this.runeTrialBomberSpawnTimer = 0;
    this.runeTrialBomberSpawnRate = 120; // 2 seconds at 60fps
    this.runeTrialBossEnraged = false;
    this.runeTrialNextBomberId = 1;

    // Create pillar object at center of arena
    this.runeTrialPillar = {
        gridX: 15,
        gridY: 15
    };

    console.log('Pillar created at:', this.runeTrialPillar.gridX, this.runeTrialPillar.gridY);
    console.log('Pillar charging:', this.runeTrialPillarCharging);



    // Position boss in center (spawns when pillar is charged)
    boss.sprite = new CharacterSprite(15, 10, boss.color, 'enemy');
    boss.sprite.setCombatPosition(15, 10);

    // Store boss for later spawning
    this.runeTrialBoss = boss;

    // Start with empty enemies array - boss spawns after pillar charges
    this.enemies = [];

    this.addLog(`Activate the pillar to begin the Rune Trial!`, 'room');

    // Create pillar UI
    this.createRuneTrialPillarUI();

    console.log('=== RUNE TRIAL SETUP COMPLETE ===');
}

spawnEndlessEnemies() {
    // Calculate how many enemies to spawn to reach the target
    const currentCount = this.enemies.length;

    // If below minimum, spawn up to max
    if (currentCount < this.endlessMinEnemies) {
        const toSpawn = this.endlessMaxEnemies - currentCount;
        this.spawnEndlessEnemyBatch(toSpawn);
    }
    // If below max, spawn one to maintain flow
    else if (currentCount < this.endlessMaxEnemies) {
        this.spawnEndlessEnemyBatch(1);
    }
}

spawnEndlessEnemyBatch(count) {
    // NEW: Epic Endless Monsters - Large treasure guardian-style enemies
    const endlessEnemyTypes = [
        'titan_colossus', 'infernal_behemoth', 'frost_leviathan', 'chaos_juggernaut',
        'void_dreadnought', 'storm_ravager', 'plague_abomination', 'crimson_tyrant',
        'arcane_devastator', 'shadow_overlord', 'molten_destroyer', 'crystal_sentinel'
    ];

    // Helper function to check if a position is too close to existing enemies
    const isPositionValid = (x, y, minDistance = 4) => {
        for (const enemy of this.enemies) {
            if (!enemy.sprite) continue;
            const dx = Math.abs(enemy.sprite.gridX - x);
            const dy = Math.abs(enemy.sprite.gridY - y);
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < minDistance) {
                return false; // Too close to another enemy
            }
        }
        // Also check party members to avoid spawning on top of them
        for (const member of this.party) {
            if (!member.sprite) continue;
            const dx = Math.abs(member.sprite.gridX - x);
            const dy = Math.abs(member.sprite.gridY - y);
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < 3) {
                return false; // Too close to party
            }
        }
        return true;
    };

    // Helper function to find a valid spawn position
    const findValidPosition = (side) => {
        let attempts = 0;
        const maxAttempts = 50;

        while (attempts < maxAttempts) {
            let xPos, yPos;

            switch(side) {
                case 0: // Right side
                    xPos = 14 + Math.floor(Math.random() * 5); // 14-18
                    yPos = 6 + Math.floor(Math.random() * 8); // 6-13
                    break;
                case 1: // Left side
                    xPos = 2 + Math.floor(Math.random() * 3); // 2-4
                    yPos = 6 + Math.floor(Math.random() * 8); // 6-13
                    break;
                case 2: // Top
                    xPos = 5 + Math.floor(Math.random() * 10); // 5-14
                    yPos = 2 + Math.floor(Math.random() * 3); // 2-4
                    break;
                case 3: // Bottom
                    xPos = 5 + Math.floor(Math.random() * 10); // 5-14
                    yPos = 15 + Math.floor(Math.random() * 3); // 15-17
                    break;
            }

            if (isPositionValid(xPos, yPos)) {
                return { xPos, yPos };
            }

            attempts++;
        }

        // If we couldn't find a valid position after many attempts, return a random one anyway
        // (this is a fallback to prevent infinite loops)
        switch(side) {
            case 0: return { xPos: 14 + Math.floor(Math.random() * 5), yPos: 6 + Math.floor(Math.random() * 8) };
            case 1: return { xPos: 2 + Math.floor(Math.random() * 3), yPos: 6 + Math.floor(Math.random() * 8) };
            case 2: return { xPos: 5 + Math.floor(Math.random() * 10), yPos: 2 + Math.floor(Math.random() * 3) };
            case 3: return { xPos: 5 + Math.floor(Math.random() * 10), yPos: 15 + Math.floor(Math.random() * 3) };
        }
    };

    let spawned = 0;
    for (let i = 0; i < count; i++) {
        const type = endlessEnemyTypes[Math.floor(Math.random() * endlessEnemyTypes.length)];
        const enemy = new Enemy(type, this.endlessEnemyLevel, 'endlessblessings', false);

        // CRITICAL: Validate enemy HP - endless arena should only have strong enemies
        // If enemy has less than 5000 HP, it's not properly scaled - skip it
        if (enemy.maxHp < 5000) {
            i--; // Retry this spawn
            continue;
        }

        // Spawn enemies from ALL SIDES to surround the team with collision detection
        const side = Math.floor(Math.random() * 4); // 0=right, 1=left, 2=top, 3=bottom
        const position = findValidPosition(side);

        enemy.sprite = new CharacterSprite(position.xPos, position.yPos, enemy.color, 'enemy');
        enemy.sprite.setCombatPosition(position.xPos, position.yPos);
        this.enemies.push(enemy);
        spawned++;
    }

    this._unitPositionsChanged = true;
}

updateEndlessDungeon() {
    // PERIODIC CLEANUP: Remove any weak enemies that shouldn't be here
    // Only check every 3 seconds to avoid FPS drops
    if (!this._lastEndlessCleanupTime) this._lastEndlessCleanupTime = 0;
    const now = Date.now();

    if (now - this._lastEndlessCleanupTime > 3000) {
        const weakEnemies = this.enemies.filter(e => e.maxHp < 5000);
        if (weakEnemies.length > 0) {
            this.enemies = this.enemies.filter(e => e.maxHp >= 5000);
            this._unitPositionsChanged = true;
        }
        this._lastEndlessCleanupTime = now;
    }

    // Continuously maintain 3-5 enemies - spawn immediately when below threshold
    this.spawnEndlessEnemies();
}

// Call this when enemies are killed to track progression and award blessings
updateEndlessWave() {
    // Increment kill count FIRST
    this.endlessKillCount++;
    this.endlessEnemiesKilledThisWave++;

    // Calculate blessing reward based on total kills
    let blessingsToAward = 0;
    if (this.endlessKillCount < 20) {
        blessingsToAward = 1; // 1 blessing per kill
    } else if (this.endlessKillCount < 30) {
        blessingsToAward = 2; // 2 blessings per kill
    } else if (this.endlessKillCount < 40) {
        blessingsToAward = 3; // 3 blessings per kill
    } else if (this.endlessKillCount < 50) {
        blessingsToAward = 4; // 4 blessings per kill
    } else {
        blessingsToAward = 5; // 5 blessings per kill (50+)
    }

    // Award blessings
    this.blessingCurrency = (this.blessingCurrency || 0) + blessingsToAward;

    // Update kill counter display
    const killCounter = document.getElementById('kill-counter');
    if (killCounter) {
        killCounter.textContent = `${this.endlessKillCount} Kills`;
    }

    // Log the reward
    if (blessingsToAward > 1) {
        this.addLog(`‚öîÔ∏è Kill #${this.endlessKillCount}! +${blessingsToAward} Blessings!`, 'loot');
    }

    // Every 5 kills, increase enemy level by 5
    if (this.endlessEnemiesKilledThisWave >= 5) {
        this.endlessWave++;
        this.endlessEnemyLevel += 5;
        this.dungeonFloor = this.endlessEnemyLevel;
        this.endlessEnemiesKilledThisWave = 0;

        this.updateRoomLabel({
            type: 'normal',
            name: `Divine Arena`
        });

        this.addLog(`üíÄ Enemies now Level ${this.endlessEnemyLevel}!`, 'room');
    }
}

// Update endless arena stats display showing damage or healing per character
updateCharacterStatsDisplay() {
    const display = document.getElementById('damage-stats-display');
    const panel = document.getElementById('character-stats-panel');
    if (!display || !panel || !this.characterStats) return;

    const mode = this.characterStatsDisplayMode || 'damage';
    let totalStat = 0;
    let characterStats = [];

    // Calculate total and create breakdown for each character
    this.party.forEach(member => {
        const stats = this.characterStats[member.name];
        if (stats) {
            const value = mode === 'damage' ? stats.damageDealt : stats.healingDone;
            totalStat += value;
            characterStats.push({
                name: member.name,
                value: value,
                className: member.className
            });
        }
    });

    // Sort by value descending
    characterStats.sort((a, b) => b.value - a.value);

    // Check if display needs updating (change detection for performance)
    const icon = mode === 'damage' ? '‚öîÔ∏è' : 'üíö';
    const label = mode === 'damage' ? 'DMG' : 'HEAL+SHIELD';
    const dragHandle = '<span style="opacity: 0.5; margin-right: 4px;">‚ãÆ‚ãÆ</span>';
    const newDisplayText = `${dragHandle}${icon} ${label}: ${totalStat.toLocaleString()}`;

    if (display.innerHTML !== newDisplayText) {
        display.innerHTML = newDisplayText;
    }

    // Only update panel if data has changed (cache last update)
    const cacheKey = JSON.stringify({ mode, stats: characterStats.map(c => ({ n: c.name, v: c.value })) });
    if (this._lastStatsCache === cacheKey) return;
    this._lastStatsCache = cacheKey;

    // Build character breakdown HTML
    const title = mode === 'damage' ? '‚öîÔ∏è Damage Dealt' : 'üíö Healing & Shielding';
    let panelHTML = `<div style="font-family: 'Orbitron', sans-serif; font-size: 14px; font-weight: 700; color: #93c5fd; margin-bottom: 8px; text-align: center; letter-spacing: 1px;">${title}</div>`;

    if (characterStats.length === 0 || totalStat === 0) {
        panelHTML += `<div style="text-align: center; color: #64748b; font-size: 12px; padding: 8px 0;">No stats yet</div>`;
    } else {
        characterStats.forEach(char => {
            const percentage = totalStat > 0 ? Math.round((char.value / totalStat) * 100) : 0;
            const barWidth = percentage;

            // Class-specific colors
            const classColors = {
                'Tank': '#71717a',
                'Healer': '#22c55e',
                'Mage': '#a855f7',
                'Rogue': '#ef4444',
                'Archer': '#f59e0b',
                'Paladin': '#fbbf24'
            };
            const color = classColors[char.className] || '#3b82f6';

            panelHTML += `
                <div style="margin-bottom: 8px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                        <span style="font-size: 12px; font-weight: 600; color: ${color};">${char.name}</span>
                        <span style="font-size: 12px; font-weight: 700; color: #e2e8f0;">${char.value.toLocaleString()} (${percentage}%)</span>
                    </div>
                    <div style="width: 100%; height: 6px; background: rgba(15, 23, 42, 0.8); border-radius: 3px; overflow: hidden;">
                        <div style="width: ${barWidth}%; height: 100%; background: linear-gradient(90deg, ${color}, ${color}99); transition: width 0.3s ease;"></div>
                    </div>
                </div>
            `;
        });
    }

    panel.innerHTML = panelHTML;
}

// Toggle between damage and healing stats display
toggleCharacterStatsDisplay() {
    if (!this.characterStatsDisplayMode) return;

    this.characterStatsDisplayMode = this.characterStatsDisplayMode === 'damage' ? 'healing' : 'damage';
    this.updateCharacterStatsDisplay();
}


createRuneTrialPillarUI() {
    // Remove existing UI if any
    let existingUI = document.getElementById('rune-trial-pillar-ui');
    if (existingUI) existingUI.remove();

    const pillarUI = document.createElement('div');
    pillarUI.id = 'rune-trial-pillar-ui';
    pillarUI.style.cssText = `
        position: fixed;
        top: 120px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.95));
        border: 3px solid #3b82f6;
        border-radius: 12px;
        padding: 20px 30px;
        z-index: 1000;
        box-shadow: 0 10px 40px rgba(59, 130, 246, 0.4);
    `;

    pillarUI.innerHTML = `
        <div style="font-family: 'Orbitron', sans-serif; font-size: 18px; color: #3b82f6; margin-bottom: 10px; text-align: center; font-weight: 700;">
            ‚ö° CHARGING PILLAR ‚ö°
        </div>
        <div style="width: 300px; height: 24px; background: rgba(15, 23, 42, 0.8); border: 2px solid #1e293b; border-radius: 12px; overflow: hidden; position: relative;">
            <div id="pillar-charge-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #3b82f6, #60a5fa); transition: width 0.1s linear; box-shadow: 0 0 20px rgba(59, 130, 246, 0.8);"></div>
            <div id="pillar-charge-text" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: 'Orbitron', sans-serif; font-weight: 700; font-size: 12px; color: white; text-shadow: 0 0 4px black;">0%</div>
        </div>
        <div style="font-size: 11px; color: #94a3b8; text-align: center; margin-top: 8px; font-style: italic;">
            Stand near pillar to charge
        </div>
    `;

    document.body.appendChild(pillarUI);
}

updateRuneTrialPillarUI() {
    const bar = document.getElementById('pillar-charge-bar');
    const text = document.getElementById('pillar-charge-text');

    if (bar && text) {
        const percent = Math.floor((this.runeTrialPillarCharge / this.runeTrialPillarMaxCharge) * 100);
        bar.style.width = percent + '%';
        text.textContent = percent + '%';
    }
}

spawnRuneTrialBomber() {
    const tier = this.runeTrialTier;

    // Create bomber
    const bomber = new Enemy('shade', tier * 10, 'umbral');
    bomber.name = `Bomber #${this.runeTrialNextBomberId++}`;
    bomber.hp = 100; // Takes multiple hits to kill
    bomber.maxHp = 100;
    bomber.attack = 0; // Doesn't attack normally
    bomber.defense = 0;
    bomber.color = '#ef4444';
    bomber.isBomber = true;
    bomber.bombTimer = 0;
    bomber.spawnTime = Date.now(); // Track when bomber spawned

    // Spawn at random edge position
    const edges = [
        {x: 5, y: 5}, {x: 25, y: 5}, {x: 5, y: 25}, {x: 25, y: 25},
        {x: 15, y: 3}, {x: 3, y: 15}, {x: 27, y: 15}, {x: 15, y: 27}
    ];
    const spawnPos = edges[Math.floor(Math.random() * edges.length)];

    bomber.sprite = new CharacterSprite(spawnPos.x, spawnPos.y, bomber.color, 'enemy');
    bomber.sprite.setCombatPosition(spawnPos.x, spawnPos.y);

    // Pick random party member as target
    const aliveParty = this.party.filter(m => m.isAlive);
    if (aliveParty.length > 0) {
        bomber.bomberTarget = aliveParty[Math.floor(Math.random() * aliveParty.length)];
    }

    this.enemies.push(bomber);
    this.addLog(`Bomber spawned!`, 'damage');
}

updateBomber(bomber) {
    if (!bomber.isAlive || !bomber.bomberTarget || !bomber.bomberTarget.isAlive) {
        bomber.isAlive = false;
        return;
    }

    // Move towards target
    const target = bomber.bomberTarget;
    const dx = target.sprite.gridX - bomber.sprite.gridX;
    const dy = target.sprite.gridY - bomber.sprite.gridY;
    const distance = Math.sqrt(dx * dx + dy * dy);

    // Initialize movement counter if needed
    if (!bomber.moveCounter) bomber.moveCounter = 0;
    bomber.moveCounter++;

    // Only move every 10 frames (makes them VERY slow)
    if (bomber.moveCounter % 10 === 0 && distance > 0.5) {
        const speed = 0.01;
        bomber.sprite.gridX += (dx / distance) * speed;
        bomber.sprite.gridY += (dy / distance) * speed;
    }

    // Flash red more frequently as it gets closer
    bomber.bombTimer++;
    const flashRate = Math.max(15, 60 - Math.floor((1 - distance / 20) * 45));
    if (bomber.bombTimer % flashRate < flashRate / 2) {
        bomber.color = '#ff0000';
    } else {
        bomber.color = '#ef4444';
    }
    bomber.sprite.color = bomber.color;

    // Explode if close enough to ANY party member
    const aliveParty = this.party.filter(m => m.isAlive);
    let shouldExplode = false;

    for (const partyMember of aliveParty) {
        if (!partyMember.sprite) continue;
        const dx = partyMember.sprite.gridX - bomber.sprite.gridX;
        const dy = partyMember.sprite.gridY - bomber.sprite.gridY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 2) {
            shouldExplode = true;
            break;
        }
    }

    if (shouldExplode) {
        // Explosion effect
        this.createBombExplosionEffect(bomber.sprite);

        const timeAlive = ((Date.now() - bomber.spawnTime) / 1000).toFixed(1);

        // Deal AOE damage to ALL party members within explosion radius
        let hitCount = 0;
        aliveParty.forEach(partyMember => {
            if (!partyMember.sprite) return;

            const dx = partyMember.sprite.gridX - bomber.sprite.gridX;
            const dy = partyMember.sprite.gridY - bomber.sprite.gridY;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Explosion radius of 3 tiles
            if (dist < 3) {
                const damage = Math.floor(partyMember.maxHp * 0.2);
                partyMember.takeDamage(damage);
                this.createFloatingText(partyMember.sprite, `-${damage} BOMB!`, 'damage-text');
                hitCount++;
            }
        });

        bomber.isAlive = false;
        this.addLog(`Bomber explodes, hitting ${hitCount} party member(s)!`, 'damage');
    }
}

createBombExplosionEffect(sprite) {
    if (!sprite) return;
    const pos = ISO.toScreen(sprite.gridX, sprite.gridY);

    // Large red explosion ring
    this.visualEffects.push({
        type: 'ring',
        x: pos.x + this.offsetX,
        y: pos.y + this.offsetY,
        radius: 10,
        maxRadius: 80,
        color: 'rgba(239, 68, 68, 0.8)',
        lineWidth: 8,
        life: 30
    });

    // Fire particles - REDUCED for performance
    for (let i = 0; i < 8; i++) {
        const angle = (Math.PI * 2 * i) / 8;
        this.visualEffects.push({
            type: 'spark',
            x: pos.x + this.offsetX,
            y: pos.y + this.offsetY,
            vx: Math.cos(angle) * 6,
            vy: Math.sin(angle) * 6,
            color: 'rgba(251, 146, 60, 0.9)',
            size: 5,
            life: 35
        });
    }
}

showBossEnrageEffect(boss) {
    if (!boss || !boss.sprite) return;

    // Create large enrage notification overlay
    const overlay = document.createElement('div');
    overlay.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: 'Orbitron', sans-serif;
        font-size: 72px;
        font-weight: 900;
        color: #ef4444;
        text-shadow: 0 0 40px #ef4444, 0 0 80px #dc2626;
        z-index: 5000;
        pointer-events: none;
        animation: enrage-pulse 0.5s ease-in-out 3;
    `;
    overlay.textContent = 'ENRAGED!';

    // Add animation keyframes
    if (!document.getElementById('enrage-animation')) {
        const style = document.createElement('style');
        style.id = 'enrage-animation';
        style.textContent = `
            @keyframes enrage-pulse {
                0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.8; }
            }
        `;
        document.head.appendChild(style);
    }

    document.body.appendChild(overlay);

    // Remove after 1.5 seconds
    setTimeout(() => overlay.remove(), 1500);

    // Boss visual effect
    const pos = ISO.toScreen(boss.sprite.gridX, boss.sprite.gridY);

    // Massive red explosion
    for (let i = 0; i < 3; i++) {
        setTimeout(() => {
            this.visualEffects.push({
                type: 'ring',
                x: pos.x + this.offsetX,
                y: pos.y + this.offsetY,
                radius: 20,
                maxRadius: 150 + i * 30,
                color: 'rgba(220, 38, 38, 0.8)',
                lineWidth: 12,
                life: 50
            });
        }, i * 150);
    }

    // Rage particles - REDUCED for performance
    for (let i = 0; i < 12; i++) {
        const angle = (Math.PI * 2 * i) / 12;
        this.visualEffects.push({
            type: 'spark',
            x: pos.x + this.offsetX,
            y: pos.y + this.offsetY,
            vx: Math.cos(angle) * 8,
            vy: Math.sin(angle) * 8,
            color: 'rgba(220, 38, 38, 0.9)',
            size: 8,
            life: 50
        });
    }
}
spawnVaultBoss() {
    const L = this.vaultLevel;
    this._unitPositionsChanged = true; // Boss spawning

    // Create boss with scaled stats - use any valid boss type since we'll override everything
    const boss = new Boss(L, 'night_herald', 'umbral');
    boss.name = 'Keystone Warden';
    boss.hp = VAULT_SCALER.bossHP(L);
    boss.maxHp = VAULT_SCALER.bossHP(L);
    boss.attack = VAULT_SCALER.bossATK(L);
    boss.defense = VAULT_SCALER.bossDEF(L);
    boss.attackSpeed = 0.5;
    boss.color = '#f59e0b';
    boss.xpReward = Math.floor(1000 * L);
    boss.goldReward = L * 25;
    boss.isVaultBoss = true;
    boss.isAlive = true;  // Explicitly set alive

    // Position in center of large room (30x30)
    boss.sprite = new CharacterSprite(15, 10, boss.color, 'enemy');
    boss.sprite.setCombatPosition(15, 10);

    this.enemies = [boss];

    if (this.enemies.length === 0) {
        console.error('No enemies spawned!');
        return;
    }

    this.addLog(`Keystone Warden appears! HP: ${boss.maxHp}`, 'damage');

    // Start summoning timer - first summon at 2.0s
    this.vaultSummonTimeout = setTimeout(() => {
        this.summonHound();

        // Then repeat every SI(L) seconds (Math.max(2.4, 4.0 - 0.08*L))
        const summonInterval = Math.max(2.4, 4.0 - 0.08 * L);
        const intervalMs = summonInterval * 1000;
        this.vaultSummonInterval = setInterval(() => {
            this.summonHound();
        }, intervalMs);
    }, 2000);

    this.addLog(`Keystone Warden appears!`, 'room');
}

spawnRuneTrialBoss() {
    const tier = this.runeTrialTier;
    this._unitPositionsChanged = true;

    // Create boss with scaled stats
    const boss = new Boss(tier * 10, 'night_herald', 'umbral');
    boss.name = 'Rune Guardian';

    // Custom HP scaling per tier
    const hpByTier = {
        1: 500000,
        2: 600000,
        3: 700000,
        4: 800000,
        5: 1000000
    };

    // Custom Attack scaling per tier
    const atkByTier = {
        1: 135,
        2: 200,
        3: 270,
        4: 295,
        5: 400
    };

    // Defense: Use floor-based scaling for consistency (CALCULATE FIRST)
    const equivalentFloor = 40 + (tier * 10);
    const defScaling = Math.min(Math.floor((4 + (equivalentFloor * 1.0) + (equivalentFloor * equivalentFloor * 0.005)) * 1.5), 200);

    // NOW set all stats after calculating defScaling
    boss.hp = hpByTier[tier];
    boss.maxHp = hpByTier[tier];
    boss.attack = atkByTier[tier];
    boss.defense = defScaling;
    boss.attackSpeed = 0.6;
    boss.color = '#3b82f6'; // Blue theme for Rune Trials
    boss.xpReward = Math.floor(500 * tier);
    boss.goldReward = tier * 100;
    boss.isRuneTrialBoss = true;
    boss.isAlive = true;
    boss.isBig = true; // Make it 2x size like other bosses
    boss.hasRedEyes = true; // Add red eyes for menacing look

    // Position in center of large room (30x30)
    boss.sprite = new CharacterSprite(15, 10, boss.color, 'enemy');
    boss.sprite.setCombatPosition(15, 10);
    boss.sprite.scale = 2.0; // Make it twice as big

    this.enemies = [boss];

    this.addLog(`Rune Guardian appears! HP: ${boss.maxHp.toLocaleString()}`, 'damage');
}

summonHound() {
    const boss = this.enemies.find(e => e.isVaultBoss);
    if (!boss || !boss.isAlive) {
        // Boss is dead, stop summoning
        if (this.vaultSummonInterval) clearInterval(this.vaultSummonInterval);
        if (this.vaultSummonTimeout) clearTimeout(this.vaultSummonTimeout);
        return;
    }

    const L = this.vaultLevel;
    const maxHounds = 4 + Math.floor(L / 7); // cap(L) formula embedded
    const aliveHounds = this.enemies.filter(e => e.name === 'Warden Hound' && e.isAlive).length;

    if (aliveHounds >= maxHounds) {
        return; // At cap, skip this summon
    }

   // Create hound with scaled stats
const hound = new Enemy('shade', L, 'umbral'); // Use any valid enemy type with theme
hound.name = 'Warden Hound';
    hound.color = '#8b4513';
    // HP: 100 per level (keep tanky)
    hound.hp = 100 * L;
    hound.maxHp = 100 * L;
    // Attack: Match floor enemy scaling (same formula as regular enemies)
    const equivalentFloor = L * 5;
    let houndAtkScaling;
    if (equivalentFloor <= 4) {
        // Floors 1-4: Very gentle linear scaling
        houndAtkScaling = Math.floor(3 + (equivalentFloor * 1.2));
    } else {
        // Floor 5+: Moderate scaling
        const adjustedLevel = equivalentFloor - 4;
        houndAtkScaling = Math.floor(8 + (adjustedLevel * 1.2) + (adjustedLevel * adjustedLevel * 0.012));
    }
    hound.attack = houndAtkScaling;
    // Defense: 5 per level
    hound.defense = 7 * L;
    hound.attackSpeed = 1.0;

    // Spawn at random positions around the boss
    const spawnPositions = [
        {x: 7, y: 8}, {x: 13, y: 8}, {x: 7, y: 4}, {x: 13, y: 4},
        {x: 10, y: 9}, {x: 10, y: 3}, {x: 6, y: 6}, {x: 14, y: 6}
    ];
    const pos = spawnPositions[Math.floor(Math.random() * spawnPositions.length)];

    hound.sprite = new CharacterSprite(pos.x, pos.y, hound.color, 'enemy');
    hound.sprite.setCombatPosition(pos.x, pos.y);

    this.enemies.push(hound);
    this.addLog(`Keystone Warden summons a Warden Hound!`, 'damage');
}

spawnBoss() {
    // Boss selection by dungeon and floor
    const bossSelection = {
        everfall: ['red_stag', 'elder_treant'],
        stoneforge: ['foundry_master', 'colossus_of_iron'],
        umbral: ['night_herald', 'maw_of_deep']
    };

    const bossList = bossSelection[this.currentDungeon] || bossSelection.everfall;
    const bossType = bossList[Math.floor(Math.random() * bossList.length)];

    const boss = new Boss(this.dungeonFloor, bossType, this.currentDungeon);
    boss.sprite = new CharacterSprite(6, 4, boss.color, 'enemy');
    boss.sprite.setCombatPosition(6, 4);

    // Minion pools by dungeon - use same pools as regular enemies
    const minionPools = {
        everfall: ['forest_wolf', 'fallen_scout'],
        stoneforge: ['tunnel_rat', 'smelter_imp'],
        umbral: ['shade', 'void_mite']
    };

    const minionList = minionPools[this.currentDungeon] || minionPools.everfall;

    // Add minions for the boss
    const minion1Type = minionList[Math.floor(Math.random() * minionList.length)];
    const minion1 = new Enemy(minion1Type, this.dungeonFloor, this.currentDungeon);
    minion1.sprite = new CharacterSprite(5, 3, minion1.color, 'enemy');
    minion1.sprite.setCombatPosition(5, 3);

    const minion2Type = minionList[Math.floor(Math.random() * minionList.length)];
    const minion2 = new Enemy(minion2Type, this.dungeonFloor, this.currentDungeon);
    minion2.sprite = new CharacterSprite(5, 5, minion2.color, 'enemy');
    minion2.sprite.setCombatPosition(5, 5);

    this.enemies = [boss, minion1, minion2];

    this.addLog(`${boss.name} appears with minions!`, 'room');
}

            hasUnvisitedRooms() {
                if (!this.dungeonLayout || !this.dungeonLayout.rooms) {
                    return false;
                }
                return this.dungeonLayout.rooms.some(r => !r.visited);
            }

            moveToNextRoom() {
                // Prevent multiple simultaneous room transitions
                if (this.movingToNextRoom || this.transitioningFloor) {
                    console.log('‚ö†Ô∏è Room transition already in progress');
                    return;
                }

                if (!this.dungeonLayout || !this.dungeonLayout.getCurrentRoom) {
                    console.warn('Cannot move to next room: no dungeon layout');
                    return;
                }

                this.movingToNextRoom = true;

                const currentRoom = this.dungeonLayout.getCurrentRoom();
                if (!currentRoom) {
                    console.warn('Cannot move to next room: no current room');
                    this.movingToNextRoom = false;
                    return;
                }

                // Find next unvisited connected room
                let nextRoom = null;
                let nextDirection = null;
                for (const connection of currentRoom.connections) {
                    const room = this.dungeonLayout.rooms.find(r => r.x === connection.x && r.y === connection.y);
                    if (room && !room.visited) {
                        nextRoom = room;
                        // Determine direction
                        const dx = connection.x - currentRoom.x;
                        const dy = connection.y - currentRoom.y;
                        if (dx === 1) nextDirection = 'right';
                        else if (dx === -1) nextDirection = 'left';
                        else if (dy === 1) nextDirection = 'down';
                        else if (dy === -1) nextDirection = 'up';
                        break;
                    }
                }

                // If no unvisited connected rooms, find any unvisited room
                if (!nextRoom) {
                    nextRoom = this.dungeonLayout.rooms.find(r => !r.visited);
                    if (nextRoom) {
                        // Calculate direction for any room
                        const dx = nextRoom.x - currentRoom.x;
                        const dy = nextRoom.y - currentRoom.y;
                        if (Math.abs(dx) >= Math.abs(dy)) {
                            nextDirection = dx > 0 ? 'right' : 'left';
                        } else {
                            nextDirection = dy > 0 ? 'down' : 'up';
                        }
                    }
                }

                if (nextRoom) {
                    // Animate party walking through hallway
                    this.animateRoomTransition(nextDirection, () => {
                        try {
                            this.dungeonLayout.moveToRoom(nextRoom.x, nextRoom.y);
                            this.enterRoom(nextRoom);
                        } finally {
                            this.movingToNextRoom = false;
                        }
                    });
                } else {
                    // Dungeon complete! Move to next floor
                    try {
                        this.completeDungeon();
                    } finally {
                        this.movingToNextRoom = false;
                    }
                }
            }

animateRoomTransition(direction, callback) {
                // Just call the callback immediately - room repositioning happens in enterRoom
                callback();
            }

completeDungeon() {
    this.addLog(`Floor ${this.dungeonFloor} complete!`, 'room');

    // Floor will be incremented in showSummary

    if (this.currentDungeon === 'vault') {
        this.addLog(`Vault conquered!`, 'loot');
        this.successfulRuns++;
        this.globalStats.totalFloorsCleared++;
        this.globalStats.totalGoldEarned += this.floorStats.goldEarned;
        this.updateUI();
        this.showSummary(true);
        return;
    }

    // Roll for Vault Key drop (10% chance, capped at level 20)
    if (Math.random() < VAULT_KEY_CONFIG.DROP_CHANCE) {
        // Determine key level based on current floor
        let keyLevel = 1;
        if (this.dungeonFloor >= 100) {
            keyLevel = 20; // Floor 100+ always drops level 20
        } else {
            // Calculate key level from floor ranges
            for (let kl = 19; kl >= 1; kl--) {
                const minFloor = (kl - 1) * 5 + 1;
                const maxFloor = kl === 19 ? 100 : kl * 5 + 5;
                if (this.dungeonFloor >= minFloor && this.dungeonFloor <= maxFloor) {
                    keyLevel = kl;
                    break;
                }
            }
        }
        const key = {
            id: this.nextVaultKeyId++,
            level: keyLevel
        };
        this.vaultKeys.push(key);
        this.addLog(`Found Level ${keyLevel} Vault Key! Access Vault in Cache tab.`, 'loot');
    }

    // Roll for Rune Trial Key drop (10% chance, floor 45+, capped at tier 5)
    if (this.dungeonFloor >= RUNE_TRIAL_KEY_CONFIG.MIN_DROP_FLOOR && Math.random() < RUNE_TRIAL_KEY_CONFIG.DROP_CHANCE) {
        // Determine key tier based on current floor
        let keyTier = 1;
        if (this.dungeonFloor >= 90) keyTier = 5;
        else if (this.dungeonFloor >= 80) keyTier = 4;
        else if (this.dungeonFloor >= 70) keyTier = 3;
        else if (this.dungeonFloor >= 60) keyTier = 2;
        else keyTier = 1;

        const key = {
            id: this.nextRuneTrialKeyId++,
            tier: keyTier
        };
        this.runeTrialKeys.push(key);
        this.addLog(`Found Tier ${keyTier} Rune Trial Key! Access in Cache tab.`, 'loot');
    }

    // Increment successful runs counter
    this.successfulRuns++;

// Update global stats
if (this.dungeonFloor >= this.globalStats.farthestFloor) {
    this.globalStats.farthestFloor = this.dungeonFloor;
}

// Update dungeon-specific progress (start 10 floors behind farthest)
if (this.currentDungeon !== 'vault' && this.currentDungeon !== 'runetrial') {
    // Track farthest floor in THIS dungeon
    if (this.dungeonFloor > this.dungeonProgress[this.currentDungeon].farthestFloor) {
        this.dungeonProgress[this.currentDungeon].farthestFloor = this.dungeonFloor;
    }

    // Set start floor to 10 behind farthest in this dungeon
    this.dungeonProgress[this.currentDungeon].startFloor =
        Math.max(1, this.dungeonProgress[this.currentDungeon].farthestFloor - 9);
}

// Force UI update to reflect new farthest floor
this.updateUI();

// Track floor time

    // Track floor time with validation
    const floorTime = this.floorStats.startTime ?
        Math.floor((Date.now() - this.floorStats.startTime) / 1000) :
        null;

    // Only update fastest floor time if valid AND reasonable (at least 3 seconds)
    if (floorTime !== null && floorTime >= 3) {
        if (this.globalStats.fastestFloorTime === null || floorTime < this.globalStats.fastestFloorTime) {
            this.globalStats.fastestFloorTime = floorTime;
        }
    }

    this.globalStats.totalFloorsCleared++;
    this.globalStats.totalGoldEarned += this.floorStats.goldEarned;

    // Roll for chest drop (5% chance)
if (Math.random() < CHEST_CONFIG.DROP_CHANCE) {
    // 5% of chests are mythic
    const isMythic = Math.random() < CHEST_CONFIG.MYTHIC_CHEST_CHANCE;

    const chest = {
        id: this.nextChestId++,
        level: this.dungeonFloor,
        isMythic: isMythic,
        openCost: isMythic ?
            CHEST_CONFIG.MYTHIC_OPEN_COST_MULTIPLIER * this.dungeonFloor :
            CHEST_CONFIG.OPEN_COST_MULTIPLIER * this.dungeonFloor,
        sellValue: isMythic ?
            CHEST_CONFIG.MYTHIC_SELL_VALUE_MULTIPLIER * this.dungeonFloor :
            CHEST_CONFIG.SELL_VALUE_MULTIPLIER * this.dungeonFloor,
        sourceDungeon: this.currentDungeon,
        foundAtFloor: this.dungeonFloor,
        rarityOdds: isMythic ?
            { ...CHEST_CONFIG.MYTHIC_RARITY_DISTRIBUTION } :
            { ...CHEST_CONFIG.RARITY_DISTRIBUTION }
    };

    this.playerChests.push(chest);
                    this.globalStats.chestsFound++;

                    if (isMythic) {
                        this.globalStats.mythicChestsFound++;
                        this.addLog(`Found a ‚ú® MYTHIC CHEST (Level ${chest.level})! ‚ú®`, 'loot');
                    }

const dungeonNames = {
                        umbral: 'Umbral Depths',
                        everfall: 'Everfall',
                        stoneforge: 'Stoneforge'
                    };

                    this.addLog(
                        `Found a Level ${chest.level} Chest from ${dungeonNames[chest.sourceDungeon]}! (Open: ${chest.openCost}g, Sell: ${chest.sellValue}g). See Chests tab.`,
                        'loot'
                    );
                }

                // Update stats display immediately
                this.updateUI();

                // Show summary screen
                this.showSummary(true);
            }
showFountainPopup() {
                // Check if popups are disabled
                if (!this.fountainPopupEnabled) return;

                // Create overlay if it doesn't exist
                let overlay = document.getElementById('fountain-overlay');
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.id = 'fountain-overlay';
                    overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 2500; opacity: 0; transition: opacity 0.3s ease;';

                    const panel = document.createElement('div');
                    panel.style.cssText = 'background: linear-gradient(135deg, rgba(26, 58, 74, 0.98) 0%, rgba(42, 74, 90, 0.98) 100%); border: 3px solid #3b82f6; border-radius: 20px; padding: 40px; text-align: center; box-shadow: 0 30px 80px rgba(0,0,0,0.9);';

                    panel.innerHTML = `
                        <div style="font-family: 'Orbitron', sans-serif; font-size: 42px; font-weight: 800; color: #60a5fa; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 4px; text-shadow: 0 0 20px rgba(59, 130, 246, 0.8);">
                            FOUNTAIN OF YOUTH
                        </div>
                        <div style="font-size: 24px; color: #10b981; font-weight: 600; font-family: 'Rajdhani', sans-serif;">
                             PARTY RESTORED 40% HP & MANA
                        </div>
                    `;

                    overlay.appendChild(panel);
                    document.body.appendChild(overlay);
                }

                // Show with fade-in
                overlay.style.display = 'flex';
                setTimeout(() => overlay.style.opacity = '1', 10);

                // Auto-hide after 2 seconds with fade-out
                setTimeout(() => {
                    overlay.style.opacity = '0';
                    setTimeout(() => {
                        overlay.style.display = 'none';
                        // Remove from DOM to prevent memory leak
                        overlay.remove();
                    }, 300);
                }, 2000);
            }

           showTreasurePopup() {
    // Check if popups are disabled
    if (!this.treasurePopupEnabled) return;

    // Create overlay
    const overlay = document.createElement('div');
    overlay.id = 'treasure-overlay';
    overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 2500; opacity: 0; transition: opacity 0.3s ease;';

    const panel = document.createElement('div');
    panel.style.cssText = 'background: linear-gradient(135deg, rgba(102, 85, 0, 0.98) 0%, rgba(153, 102, 0, 0.98) 100%); border: 3px solid #f59e0b; border-radius: 20px; padding: 40px; text-align: center; box-shadow: 0 30px 80px rgba(0,0,0,0.9);';

    const goldPerEnemy = this.dungeonFloor * 200;

    panel.innerHTML = `
        <div style="font-family: 'Orbitron', sans-serif; font-size: 42px; font-weight: 800; color: #fbbf24; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 4px; text-shadow: 0 0 20px rgba(251, 191, 36, 0.8);">
            üèÜ TREASURE ROOM üèÜ
        </div>
        <div style="font-size: 24px; color: #f59e0b; font-weight: 600; font-family: 'Rajdhani', sans-serif; margin-bottom: 10px;">
            Treasure Guardians Protect This Room!
        </div>
        <div style="font-size: 18px; color: #fbbf24; font-weight: 500; font-family: 'Rajdhani', sans-serif;">
            Each guardian drops ${goldPerEnemy} gold!
        </div>
    `;

    overlay.appendChild(panel);
    document.body.appendChild(overlay);

    // Show with fade-in
    setTimeout(() => overlay.style.opacity = '1', 10);

    // Auto-hide after 2 seconds with fade-out
    setTimeout(() => {
        overlay.style.opacity = '0';
        setTimeout(() => {
            overlay.remove();
        }, 300);
    }, 2000);
}
            showSummary(victory) {
    // CRITICAL FIX: Hide any visible tooltips immediately when showing summary
    const lootTooltip = document.getElementById('loot-tooltip');
    if (lootTooltip) {
        lootTooltip.classList.remove('show');
        lootTooltip.style.display = 'none';
    }

    // Calculate time taken
    const timeElapsed = Math.floor((Date.now() - this.floorStats.startTime) / 1000);
    const minutes = Math.floor(timeElapsed / 60);
    const seconds = timeElapsed % 60;
    const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;

    // Find the guaranteed boss loot item if victory
    let bossLootItem = null;
    if (victory && this.loot.length > 0) {
        // Get the most recent item (boss always drops last)
        bossLootItem = this.loot[this.loot.length - 1];
    }

    // Create custom victory/defeat overlay
    const overlay = document.createElement('div');
    overlay.id = 'floor-summary-overlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: ${victory ?
            'radial-gradient(ellipse at center, rgba(16, 185, 129, 0.15) 0%, rgba(0, 0, 0, 0.95) 70%)' :
            'radial-gradient(ellipse at center, rgba(239, 68, 68, 0.15) 0%, rgba(0, 0, 0, 0.95) 70%)'};
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 2000;
        backdrop-filter: blur(20px);
        animation: fadeIn 0.3s ease;
    `;

    const panel = document.createElement('div');
    panel.style.cssText = `
        background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(6, 9, 23, 0.98) 100%);
        border: 3px solid ${victory ? '#10b981' : '#ef4444'};
        border-radius: 20px;
        padding: 40px;
        max-width: 700px;
        width: 90%;
        box-shadow: 0 30px 80px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        animation: slideUp 0.4s ease;
    `;

    let itemDisplayHTML = '';
    if (victory && bossLootItem) {
        const rarityColors = {
            common: '#94a3b8',
            uncommon: '#10b981',
            rare: '#3b82f6',
            epic: '#a855f7',
            legendary: '#f59e0b',
            mythic: '#ef4444'
        };

        const itemColor = rarityColors[bossLootItem.rarity] || '#94a3b8';
        const itemGlow = victory ? `0 0 30px ${itemColor}80` : '';

        itemDisplayHTML = `
            <div style="margin: 30px 0; padding: 25px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.05)); border: 2px solid ${itemColor}; border-radius: 16px; box-shadow: ${itemGlow}; animation: itemPulse 2s ease-in-out infinite;">
                <div style="font-size: 14px; color: #94a3b8; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 10px; text-align: center;">Boss Loot Acquired</div>
                <div style="font-size: 22px; font-weight: 800; color: ${itemColor}; text-align: center; font-family: 'Orbitron', sans-serif; text-shadow: 0 2px 10px ${itemColor}80; margin-bottom: 8px;">
                    ${bossLootItem.name}
                </div>
                <div style="font-size: 13px; color: #cbd5e1; text-align: center; line-height: 1.6;">
                    ${bossLootItem.getStatsDisplay ? bossLootItem.getStatsDisplay() : ''}
                </div>
            </div>
        `;
    }

    panel.innerHTML = `
        <div style="font-family: 'Orbitron', sans-serif; font-size: 48px; font-weight: 800; text-align: center; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 4px; ${victory ?
            'background: linear-gradient(135deg, #10b981, #34d399); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 0 40px rgba(16, 185, 129, 0.5);' :
            'background: linear-gradient(135deg, #ef4444, #dc2626); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 0 40px rgba(239, 68, 68, 0.5);'} animation: titlePulse 2s ease-in-out infinite;">
            ${victory ? '‚öîÔ∏è VICTORY! ‚öîÔ∏è' : 'üíÄ DEFEAT üíÄ'}
        </div>

        <div style="text-align: center; font-size: 20px; color: #f59e0b; font-weight: 700; margin-bottom: 25px; font-family: 'Orbitron', sans-serif;">
            Floor ${this.dungeonFloor} ${victory ? 'Complete' : 'Failed'}
        </div>

        ${itemDisplayHTML}

        <div style="background: rgba(15, 23, 42, 0.5); border-radius: 12px; padding: 25px; margin-bottom: 25px; border: 1px solid rgba(99, 102, 241, 0.2);">
            <div style="display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid rgba(99, 102, 241, 0.1);">
                <span style="color: #94a3b8; font-weight: 500;">Time Taken:</span>
                <span style="color: #e2e8f0; font-weight: 700; font-family: 'Orbitron', sans-serif;">${timeString}</span>
            </div>
            <div style="display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid rgba(99, 102, 241, 0.1);">
                <span style="color: #94a3b8; font-weight: 500;">Damage Dealt:</span>
                <span style="color: #ef4444; font-weight: 700; font-family: 'Orbitron', sans-serif;">${this.floorStats.damageDealt.toLocaleString()}</span>
            </div>
            <div style="display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid rgba(99, 102, 241, 0.1);">
                <span style="color: #94a3b8; font-weight: 500;">Enemies Defeated:</span>
                <span style="color: #a855f7; font-weight: 700; font-family: 'Orbitron', sans-serif;">${this.floorStats.enemiesKilled}</span>
            </div>
            <div style="display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid rgba(99, 102, 241, 0.1);">
                <span style="color: #94a3b8; font-weight: 500;">Gold Earned:</span>
                <span style="color: #f59e0b; font-weight: 700; font-family: 'Orbitron', sans-serif;">${this.floorStats.goldEarned}g</span>
            </div>
            <div style="display: flex; justify-content: space-between; padding: 10px 0;">
                <span style="color: #94a3b8; font-weight: 500;">Loot Obtained:</span>
                <span style="color: #3b82f6; font-weight: 700; font-family: 'Orbitron', sans-serif;">${this.floorStats.lootObtained} items</span>
            </div>
        </div>

        <button id="floor-summary-btn" style="width: 100%; padding: 18px; background: ${victory ?
            'linear-gradient(135deg, #10b981, #059669)' :
            'linear-gradient(135deg, #71717a, #52525b)'}; color: white; border: none; border-radius: 12px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 16px; font-weight: 700; text-transform: uppercase; letter-spacing: 2px; transition: all 0.3s ease; box-shadow: 0 4px 20px ${victory ?
            'rgba(16, 185, 129, 0.4)' :
            'rgba(99, 102, 241, 0.4)'}; position: relative; overflow: hidden;">
            ${victory ? `Continue to Floor ${this.dungeonFloor + 1}` : 'Respawn'} (${this.summaryDuration}s)
        </button>
    `;

    overlay.appendChild(panel);
    document.body.appendChild(overlay);

    // Add animations via style tag
    const style = document.createElement('style');
    style.textContent = `
        @keyframes itemPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        @keyframes titlePulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
    `;
    document.head.appendChild(style);

    // Countdown logic
    let countdown = this.summaryDuration;
    const button = document.getElementById('floor-summary-btn');

    const countdownInterval = setInterval(() => {
        countdown--;
        button.textContent = `${victory ? `Continue to Floor ${this.dungeonFloor + 1}` : 'Respawn'} (${countdown}s)`;
    }, 1000);

    const continueAction = () => {
        clearInterval(countdownInterval);
        overlay.remove();
        style.remove();

        // CRITICAL FIX: Hide any visible tooltips when completing floor
        const lootTooltip = document.getElementById('loot-tooltip');
        if (lootTooltip) {
            lootTooltip.classList.remove('show');
            lootTooltip.style.display = 'none';
        }

        // Set transition flag to prevent other operations
        this.transitioningFloor = true;

        // Check if this was a Vault run
        if (this.currentDungeon === 'vault') {
            this.currentDungeon = null;
            this.vaultLevel = null;
            this.dungeonFloor = 1;
            this.room = null;
            this.dungeonLayout = null;
            this.enemies = [];
            this.hallways = [];  // Clear visual elements
            this.adjacentRooms = [];  // Clear visual elements
            this.transitioningFloor = false;
            this.movingToNextRoom = false;
            document.getElementById('room-label').style.display = 'none';
            this.showDungeonSelector();
            return;
        }

        if (victory) {
            // Clear any pending operations
            this.movingToNextRoom = false;

            // Increment floor
            this.dungeonFloor++;
            document.getElementById('current-floor-display').textContent = this.dungeonFloor;

            // Award blessing currency for Divine Arena dungeon
            if (this.currentDungeon === 'endlessblessings') {
                const blessingReward = Math.floor(this.dungeonFloor / 2); // 1 per 2 floors
                this.blessingCurrency = (this.blessingCurrency || 0) + blessingReward;
                if (blessingReward > 0) {
                    this.addLog(`‚ú® Earned ${blessingReward} Blessing Currency!`, 'loot');
                }
            }

            // Clear old state before generating new dungeon - INCLUDING visual elements
            this.enemies = [];
            this.room = null;
            this.dungeonLayout = null;
            this.hallways = [];  // Clear old hallways to prevent ghost floors
            this.adjacentRooms = [];  // Clear old adjacent rooms to prevent invisible floors

            // Generate new dungeon with proper delay
            setTimeout(() => {
                try {
                    this.generateDungeon();
                } finally {
                    this.transitioningFloor = false;
                }
            }, 300);
        } else {
            this.transitioningFloor = false;
            this.respawnParty();
        }
    };

    setTimeout(continueAction, this.summaryDuration * 1000);
    button.onclick = continueAction;
}

            showRuneTrialVictoryScreen(goldReward, xpReward, rune, lootItems) {
    // CRITICAL FIX: Hide any visible tooltips immediately when showing victory screen
    const lootTooltip = document.getElementById('loot-tooltip');
    if (lootTooltip) {
        lootTooltip.classList.remove('show');
        lootTooltip.style.display = 'none';
    }

    const overlay = document.createElement('div');
    overlay.id = 'runetrial-victory-overlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: radial-gradient(ellipse at center, rgba(59, 130, 246, 0.15) 0%, rgba(0, 0, 0, 0.95) 70%);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 3000;
        opacity: 0;
        transition: opacity 0.5s ease;
    `;

    const panel = document.createElement('div');
    panel.style.cssText = `
        background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.98) 100%);
        border: 3px solid #3b82f6;
        border-radius: 20px;
        padding: 40px;
        max-width: 700px;
        width: 90%;
        box-shadow: 0 30px 80px rgba(59, 130, 246, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        transform: scale(0.8);
        transition: transform 0.5s ease;
    `;

    const tierColors = {
        1: '#94a3b8',
        2: '#10b981',
        3: '#3b82f6',
        4: '#a855f7',
        5: '#f59e0b'
    };

    panel.innerHTML = `
        <div style="font-family: 'Orbitron', sans-serif; font-size: 48px; font-weight: 800; text-align: center; margin-bottom: 30px; background: linear-gradient(135deg, #3b82f6, #60a5fa); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-transform: uppercase; letter-spacing: 4px;">
            TRIAL COMPLETE
        </div>

        <div style="background: rgba(15, 23, 42, 0.5); border-radius: 12px; padding: 25px; margin-bottom: 25px; border: 1px solid rgba(168, 85, 247, 0.3);">
            <div style="display: flex; justify-content: space-around; margin-bottom: 20px;">
                <div style="text-align: center;">
                    <div style="font-size: 14px; color: #94a3b8; text-transform: uppercase; letter-spacing: 1px;">Gold Earned</div>
                    <div style="font-size: 32px; font-weight: 800; color: #f59e0b; font-family: 'Orbitron', sans-serif; text-shadow: 0 0 20px rgba(245, 158, 11, 0.5);">üí∞ ${goldReward}g</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 14px; color: #94a3b8; text-transform: uppercase; letter-spacing: 1px;">XP Per Member</div>
                    <div style="font-size: 32px; font-weight: 800; color: #ffffff; font-family: 'Orbitron', sans-serif; text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);">‚≠ê ${xpReward}</div>
                </div>
            </div>
        </div>

        <div style="border-top: 2px solid rgba(59, 130, 246, 0.3); padding-top: 20px; margin-top: 10px;">
            <div style="font-size: 16px; color: #3b82f6; text-transform: uppercase; letter-spacing: 2px; text-align: center; margin-bottom: 15px; font-weight: 700;">üîÆ Rune Reward üîÆ</div>
            <div style="display: flex; align-items: center; gap: 20px; background: rgba(59, 130, 246, 0.1); padding: 15px; border-radius: 12px; border: 2px solid #3b82f6;">
                <div style="width: 80px; height: 80px; flex-shrink: 0; background: radial-gradient(circle, rgba(251, 191, 36, 0.3) 0%, rgba(245, 158, 11, 0.1) 70%, transparent 100%); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 48px; box-shadow: 0 0 20px rgba(251, 191, 36, 0.4), inset 0 0 20px rgba(251, 191, 36, 0.2); border: 3px solid rgba(251, 191, 36, 0.5);">
                    ${rune.emoji}
                </div>
                <div style="flex: 1; text-align: left;">
                    <div style="font-size: 18px; font-weight: 700; color: #3b82f6; margin-bottom: 5px; font-family: 'Orbitron', sans-serif;">${rune.name}</div>
                    <div style="font-size: 12px; color: #e2e8f0; line-height: 1.5;">${rune.description}</div>
                </div>
            </div>
        </div>

        <div style="border-top: 2px solid rgba(59, 130, 246, 0.3); padding-top: 20px; margin-top: 20px;">
            <div style="font-size: 14px; color: #3b82f6; text-transform: uppercase; letter-spacing: 2px; text-align: center; margin-bottom: 12px; font-weight: 700;">Bonus Loot (3 Items)</div>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;">
                ${lootItems.map((item, idx) => `
                    <div class="runetrial-loot-item" data-loot-index="${idx}" style="background: rgba(30, 41, 59, 0.8); border: 2px solid ${this.getRarityColor(item.rarity)}; border-radius: 8px; padding: 10px; text-align: center; cursor: pointer; transition: all 0.2s ease;">
                        <div style="font-size: 11px; font-weight: 700; color: ${this.getRarityColor(item.rarity)}; margin-bottom: 3px;">${item.rarity.toUpperCase()}</div>
                        <div style="font-size: 10px; color: #e2e8f0; margin-top: 4px;">${item.name}</div>
                        <div style="font-size: 9px; color: #94a3b8;">Lvl ${item.level}</div>
                    </div>
                `).join('')}
            </div>
            <div style="font-size: 9px; color: #64748b; text-align: center; margin-top: 8px; font-style: italic;">Loot odds: 10% Legendary, 40% Epic, 50% Rare</div>
        </div>

        <button class="summary-button" id="runetrial-continue-btn" style="width: 100%; margin-top: 20px; padding: 18px; background: linear-gradient(135deg, #3b82f6, #60a5fa); color: #fff; border: none; border-radius: 12px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 16px; font-weight: 700; text-transform: uppercase; letter-spacing: 2px; box-shadow: 0 4px 20px rgba(59, 130, 246, 0.4); transition: all 0.3s ease;">
            Continue
        </button>
    `;

    overlay.appendChild(panel);
    document.body.appendChild(overlay);

    // Fade in
    setTimeout(() => {
        overlay.style.opacity = '1';
        panel.style.transform = 'scale(1)';
    }, 10);

    // Add tooltip event listeners for loot items - with proper cleanup
setTimeout(() => {
    // Clean up old listeners first
    const oldItems = document.querySelectorAll('.runetrial-loot-item');
    oldItems.forEach(item => {
        const clone = item.cloneNode(true);
        item.parentNode?.replaceChild(clone, item);
    });

    // Now add fresh listeners
    document.querySelectorAll('.runetrial-loot-item').forEach((itemDiv, idx) => {
        itemDiv.addEventListener('mouseenter', (e) => {
            const index = parseInt(itemDiv.getAttribute('data-loot-index'));
            const item = lootItems[index];

            if (!item) return;

            itemDiv.style.transform = 'scale(1.05)';
            itemDiv.style.boxShadow = `0 0 20px ${this.getRarityColor(item.rarity)}`;

            const tooltip = document.getElementById('equipment-tooltip');
            if (!tooltip) return;

            let tooltipHTML = `
                <div class="tooltip-header ${item.rarity}">${item.name}</div>
                <div class="tooltip-stats">
            `;

            const slotNames = {
                helmet: 'Helmet', gloves: 'Gloves', belt: 'Belt', chest: 'Chestplate',
                boots: 'Boots', amulet: 'Amulet', ring: 'Ring', wand: 'Wand',
                dagger: 'Dagger', greatsword: 'Greatsword', staff: 'Staff', bow: 'Bow', warhammer: 'Warhammer', weapon: 'Weapon'
            };

            const itemType = item.weaponType || item.type;
            tooltipHTML += `<div class="tooltip-stat" style="color: #3b82f6; font-weight: 600;">${slotNames[itemType] || itemType}</div>`;

            if (item.attack) tooltipHTML += `<div class="tooltip-stat">+${item.attack} Attack ${this.getStatRollPercent(item, 'attack')}</div>`;
            if (item.attackSpeed) tooltipHTML += `<div class="tooltip-stat">+${item.attackSpeed} Attack Speed ${this.getStatRollPercent(item, 'attackSpeed')}</div>`;
            if (item.hp) tooltipHTML += `<div class="tooltip-stat">+${item.hp} HP ${this.getStatRollPercent(item, 'hp')}</div>`;
            if (item.mana) tooltipHTML += `<div class="tooltip-stat">+${item.mana} Mana ${this.getStatRollPercent(item, 'mana')}</div>`;
            if (item.defense) tooltipHTML += `<div class="tooltip-stat">+${item.defense} Defense ${this.getStatRollPercent(item, 'defense')}</div>`;
            if (item.critChance) tooltipHTML += `<div class="tooltip-stat">+${item.critChance}% Crit Chance ${this.getStatRollPercent(item, 'critChance')}</div>`;
            if (item.critDamage) tooltipHTML += `<div class="tooltip-stat">+${item.critDamage}% Crit Damage ${this.getStatRollPercent(item, 'critDamage')}</div>`;
            if (item.dodgeChance) tooltipHTML += `<div class="tooltip-stat">+${item.dodgeChance}% Dodge ${this.getStatRollPercent(item, 'dodgeChance')}</div>`;
            if (item.lifesteal) tooltipHTML += `<div class="tooltip-stat">+${item.lifesteal}% Lifesteal ${this.getStatRollPercent(item, 'lifesteal')}</div>`;
            if (item.hpRegen) tooltipHTML += `<div class="tooltip-stat">+${item.hpRegen}% HP Regen ${this.getStatRollPercent(item, 'hpRegen')}</div>`;
            if (item.manaRegen) tooltipHTML += `<div class="tooltip-stat">+${item.manaRegen}% Mana Regen ${this.getStatRollPercent(item, 'manaRegen')}</div>`;
            if (item.cdr) tooltipHTML += `<div class="tooltip-stat">+${item.cdr}% CDR ${this.getStatRollPercent(item, 'cdr')}</div>`;

            tooltipHTML += `</div>`;

            tooltip.innerHTML = tooltipHTML;
            tooltip.classList.add('show');
            tooltip.style.display = 'block';
            tooltip.style.zIndex = '10000';

            const rect = e.target.getBoundingClientRect();
            tooltip.style.left = `${rect.left + rect.width / 2 - 125}px`;
            tooltip.style.top = `${rect.top - 100}px`;
            tooltip.style.transform = 'translateY(-100%)';
        });

        itemDiv.addEventListener('mouseleave', () => {
            const tooltip = document.getElementById('equipment-tooltip');
            if (tooltip) {
                tooltip.classList.remove('show');
                tooltip.style.display = 'none';
            }
            itemDiv.style.transform = 'scale(1)';
            itemDiv.style.boxShadow = 'none';
        });
    });
}, 100);

                const btn = document.getElementById('runetrial-continue-btn');

    const closeVictoryScreen = () => {
        overlay.style.opacity = '0';
        panel.style.transform = 'scale(0.8)';

        setTimeout(() => {
            overlay.remove();

            // Reset trial state
            this.currentDungeon = null;
            this.runeTrialTier = null;
            this.dungeonFloor = 1;
            this.room = null;
            this.dungeonLayout = null;
            this.enemies = [];

            // Hide room label
            document.getElementById('room-label').style.display = 'none';

            // Go directly to dungeon selector (banner page) without showing keystones first
            this.addLog('Rune Trial complete! Select your next dungeon...', 'room');
            setTimeout(() => {
                this.showDungeonSelector();
            }, 100);
        }, 500);
    };

    btn.onclick = closeVictoryScreen;
}

showVaultVictoryScreen(goldReward, xpReward, keystone, lootItems) {
                // Create overlay
                const overlay = document.createElement('div');
                overlay.id = 'vault-victory-overlay';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: radial-gradient(ellipse at center, rgba(245, 158, 11, 0.15) 0%, rgba(0, 0, 0, 0.95) 70%);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 3000;
                    opacity: 0;
                    transition: opacity 0.5s ease;
                `;

                const panel = document.createElement('div');
                panel.style.cssText = `
                    background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.98) 100%);
                    border: 3px solid #f59e0b;
                    border-radius: 20px;
                    padding: 40px;
                    max-width: 700px;
                    width: 90%;
                    box-shadow: 0 30px 80px rgba(245, 158, 11, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.1);
                    transform: scale(0.8);
                    transition: transform 0.5s ease;
                `;

                // Get keystone icon class
                const keystoneIconClass = keystone.internalName;
                const keystoneRarityClass = `rarity-${keystone.rarity}`;

                panel.innerHTML = `
    <div style="font-family: 'Orbitron', sans-serif; font-size: 48px; font-weight: 800; text-align: center; margin-bottom: 30px; background: linear-gradient(135deg, #f59e0b, #fbbf24); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-transform: uppercase; letter-spacing: 4px; animation: pulse 2s ease-in-out infinite;">
        VAULT CONQUERED
    </div>

                    <div style="background: rgba(15, 23, 42, 0.5); border-radius: 12px; padding: 25px; margin-bottom: 25px; border: 1px solid rgba(245, 158, 11, 0.3);">
                        <div style="display: flex; justify-content: space-around; margin-bottom: 20px;">
                            <div style="text-align: center;">
                                <div style="font-size: 14px; color: #94a3b8; text-transform: uppercase; letter-spacing: 1px;">Gold Earned</div>
                                <div style="font-size: 32px; font-weight: 800; color: #f59e0b; font-family: 'Orbitron', sans-serif; text-shadow: 0 0 20px rgba(245, 158, 11, 0.5);">üí∞ ${goldReward}g</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 14px; color: #94a3b8; text-transform: uppercase; letter-spacing: 1px;">XP Per Member</div>
                                <div style="font-size: 32px; font-weight: 800; color: #ffffff; font-family: 'Orbitron', sans-serif; text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);">‚≠ê ${xpReward}</div>
                            </div>
                        </div>
</div>
                        </div>

                        <div style="border-top: 2px solid rgba(245, 158, 11, 0.3); padding-top: 20px; margin-top: 10px;">
                            <div style="font-size: 16px; color: #f59e0b; text-transform: uppercase; letter-spacing: 2px; text-align: center; margin-bottom: 15px; font-weight: 700;">üîë Keystone Reward üîë</div>
                            <div style="display: flex; align-items: center; gap: 20px; background: rgba(245, 158, 11, 0.1); padding: 15px; border-radius: 12px; border: 2px solid #f59e0b;">
                                <div class="keystone-icon ${keystoneIconClass} ${keystoneRarityClass}" style="width: 80px; height: 80px; flex-shrink: 0; animation: float 3s ease-in-out infinite;"></div>
                                <div style="flex: 1;">
                                    <div style="font-size: 18px; font-weight: 700; color: ${this.getRarityColor(keystone.rarity)}; margin-bottom: 5px; font-family: 'Orbitron', sans-serif;">${keystone.name}</div>
                                    <div style="font-size: 12px; color: #f59e0b; margin-bottom: 5px; font-weight: 600;">${keystone.ability.name} (${keystone.ability.cooldown}s CD | ${keystone.ability.manaCost === 0 ? '<span style="color: #10b981;">Free</span>' : keystone.ability.manaCost + ' Mana'})</div>
                                    <div style="font-size: 11px; color: #94a3b8;">${keystone.ability.description}</div>
                                    <div style="font-size: 10px; color: #e2e8f0; margin-top: 5px;">${keystone.getStatsDisplay()}</div>
                                </div>
                            </div>
                        </div>

                        <div style="border-top: 2px solid rgba(245, 158, 11, 0.3); padding-top: 20px; margin-top: 20px;">
    <div style="font-size: 14px; color: #f59e0b; text-transform: uppercase; letter-spacing: 2px; text-align: center; margin-bottom: 12px; font-weight: 700;">Bonus Loot (3 Items)</div>
    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;">
                                ${lootItems.map((item, idx) => `
                                    <div class="vault-loot-item" data-loot-index="${idx}" style="background: rgba(30, 41, 59, 0.8); border: 2px solid ${this.getRarityColor(item.rarity)}; border-radius: 8px; padding: 10px; text-align: center; cursor: pointer; transition: all 0.2s ease;">
                                        <div style="font-size: 11px; font-weight: 700; color: ${this.getRarityColor(item.rarity)}; margin-bottom: 3px;">${item.rarity.toUpperCase()}</div>
                                        <div style="font-size: 10px; color: #e2e8f0; margin-top: 4px;">${item.name}</div>
                                        <div style="font-size: 9px; color: #94a3b8;">Lvl ${item.level}</div>
                                    </div>
                                `).join('')}
                            </div>
    <div style="font-size: 9px; color: #64748b; text-align: center; margin-top: 8px; font-style: italic;">Loot odds: 25% Legendary, 20% Epic, 55% Rare</div>
</div>
                    </div>

                    <button id="vault-continue-btn" style="width: 100%; padding: 18px; background: linear-gradient(135deg, #f59e0b, #fbbf24); color: #000; border: none; border-radius: 12px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 16px; font-weight: 700; text-transform: uppercase; letter-spacing: 2px; box-shadow: 0 4px 20px rgba(245, 158, 11, 0.4); transition: all 0.3s ease;">
                        Continue (3s)
                    </button>
                `;

                overlay.appendChild(panel);
                document.body.appendChild(overlay);

                // Add floating animation keyframes if not already present
                if (!document.getElementById('vault-victory-styles')) {
                    const style = document.createElement('style');
                    style.id = 'vault-victory-styles';
                    style.textContent = `
                        @keyframes float {
                            0%, 100% { transform: translateY(0px); }
                            50% { transform: translateY(-10px); }
                        }
                        @keyframes pulse {
                            0%, 100% { opacity: 1; transform: scale(1); }
                            50% { opacity: 0.8; transform: scale(1.05); }
                        }
                    `;
                    document.head.appendChild(style);
                }

                // Fade in
                setTimeout(() => {
                    overlay.style.opacity = '1';
                    panel.style.transform = 'scale(1)';
                }, 10);

                // Manual continue only - no auto-continue
const btn = document.getElementById('vault-continue-btn');
btn.textContent = 'Continue';

const closeVictoryScreen = () => {
                    overlay.style.opacity = '0';
                    panel.style.transform = 'scale(0.8)';

                    setTimeout(() => {
                        overlay.remove();

                        // Reset vault state completely
                        this.currentDungeon = null;
                        this.vaultLevel = null;
                        this.dungeonFloor = 1;
                        this.room = null;
                        this.dungeonLayout = null;
                        this.enemies = [];

                        // Hide room label
                        document.getElementById('room-label').style.display = 'none';

                        // Go directly to dungeon selector (banner page) without showing keystones first
                        this.addLog('Vault conquered! Select your next dungeon...', 'room');
                        setTimeout(() => {
                            this.showDungeonSelector();
                        }, 100);
                    }, 500);
                };

                // Add tooltip event listeners for loot items
                setTimeout(() => {
                    document.querySelectorAll('.vault-loot-item').forEach((itemDiv, idx) => {
                        itemDiv.addEventListener('mouseenter', (e) => {
                            const index = parseInt(itemDiv.getAttribute('data-loot-index'));
                            const item = lootItems[index];

                            if (!item) {
                                return;
                            }

                            // Add scale effect
                            itemDiv.style.transform = 'scale(1.05)';
                            itemDiv.style.boxShadow = `0 0 20px ${this.getRarityColor(item.rarity)}`;

                            const tooltip = document.getElementById('equipment-tooltip');

                            if (!tooltip) {
                                return;
                            }

                            let tooltipHTML = `
                                <div class="tooltip-header ${item.rarity}">${item.name}</div>
                                <div class="tooltip-stats">
                            `;

                            // Get weapon type display
                            const slotNames = {
                                helmet: 'Helmet',
                                gloves: 'Gloves',
                                belt: 'Belt',
                                chest: 'Chestplate',
                                boots: 'Boots',
                                amulet: 'Amulet',
                                ring: 'Ring',
                                wand: 'Wand',
                                dagger: 'Dagger',
                                greatsword: 'Greatsword',
                                staff: 'Staff',
                                bow: 'Bow',
                                warhammer: 'Warhammer',
                                weapon: 'Weapon'
                            };

                            const itemType = item.weaponType || item.type;
                            tooltipHTML += `<div class="tooltip-stat" style="color: #f59e0b; font-weight: 600;">${slotNames[itemType] || itemType}</div>`;

                            if (item.attack) tooltipHTML += `<div class="tooltip-stat">+${item.attack} Attack ${this.getStatRollPercent(item, 'attack')}</div>`;
            if (item.attackSpeed) tooltipHTML += `<div class="tooltip-stat">+${item.attackSpeed} Attack Speed ${this.getStatRollPercent(item, 'attackSpeed')}</div>`;
            if (item.hp) tooltipHTML += `<div class="tooltip-stat">+${item.hp} HP ${this.getStatRollPercent(item, 'hp')}</div>`;
            if (item.mana) tooltipHTML += `<div class="tooltip-stat">+${item.mana} Mana ${this.getStatRollPercent(item, 'mana')}</div>`;
            if (item.defense) tooltipHTML += `<div class="tooltip-stat">+${item.defense} Defense ${this.getStatRollPercent(item, 'defense')}</div>`;
            if (item.critChance) tooltipHTML += `<div class="tooltip-stat">+${item.critChance}% Crit Chance ${this.getStatRollPercent(item, 'critChance')}</div>`;
            if (item.critDamage) tooltipHTML += `<div class="tooltip-stat">+${item.critDamage}% Crit Damage ${this.getStatRollPercent(item, 'critDamage')}</div>`;
            if (item.dodgeChance) tooltipHTML += `<div class="tooltip-stat">+${item.dodgeChance}% Dodge Chance ${this.getStatRollPercent(item, 'dodgeChance')}</div>`;
            if (item.lifesteal) tooltipHTML += `<div class="tooltip-stat">+${item.lifesteal}% Lifesteal ${this.getStatRollPercent(item, 'lifesteal')}</div>`;
            if (item.hpRegen) tooltipHTML += `<div class="tooltip-stat">+${item.hpRegen}% HP Regen ${this.getStatRollPercent(item, 'hpRegen')}</div>`;
            if (item.manaRegen) tooltipHTML += `<div class="tooltip-stat">+${item.manaRegen}% Mana Regen ${this.getStatRollPercent(item, 'manaRegen')}</div>`;
            if (item.cdr) tooltipHTML += `<div class="tooltip-stat">+${item.cdr}% CDR ${this.getStatRollPercent(item, 'cdr')}</div>`;

                            tooltipHTML += `</div>`;

                            tooltip.innerHTML = tooltipHTML;
                            tooltip.classList.add('show');
                            tooltip.style.display = 'block';
                            tooltip.style.zIndex = '10000';

                            const rect = e.target.getBoundingClientRect();
							tooltip.style.left = `${rect.left + rect.width / 2 - 125}px`;
							tooltip.style.top = `${rect.top - 100}px`;
							tooltip.style.transform = 'translateY(-100%)';

                            console.log('Tooltip shown at:', tooltip.style.left, tooltip.style.top);
                        });

                        itemDiv.addEventListener('mouseleave', () => {
                            const tooltip = document.getElementById('equipment-tooltip');
                            if (tooltip) {
                                tooltip.classList.remove('show');
                                tooltip.style.display = 'none';
                            }
                            itemDiv.style.transform = 'scale(1)';
                            itemDiv.style.boxShadow = 'none';
                        });
                    });
                }, 100);

                btn.onclick = closeVictoryScreen;
            }

showEndlessBlessingsResults() {
    // Calculate total blessings earned based on kills
    let totalBlessings = 0;
    for (let i = 1; i <= this.endlessKillCount; i++) {
        if (i < 20) {
            totalBlessings += 1;
        } else if (i < 30) {
            totalBlessings += 2;
        } else if (i < 40) {
            totalBlessings += 3;
        } else if (i < 50) {
            totalBlessings += 4;
        } else {
            totalBlessings += 5;
        }
    }

    // Determine loot based on kill count
    const kills = this.endlessKillCount;
    let itemLevel, rarityRolls;

    // NEW: 1-9 kills = DEFEAT (no loot items)
    if (kills < 10) {
        itemLevel = null;
        rarityRolls = null;
    } else if (kills <= 20) {
        // 10-20 kills = Basic rarity table
        itemLevel = this.endlessEnemyLevel; // 60-80
        rarityRolls = [
            { rarity: 'rare', chance: 50 },
            { rarity: 'epic', chance: 85 },
            { rarity: 'legendary', chance: 100 }
        ];
    } else if (kills < 40) {
        itemLevel = this.endlessEnemyLevel; // 80-100
        rarityRolls = [
            { rarity: 'rare', chance: 35 },
            { rarity: 'epic', chance: 79.9 },
            { rarity: 'legendary', chance: 99.9 },
            { rarity: 'mythic', chance: 100 }
        ];
    } else if (kills < 60) {
        itemLevel = this.endlessEnemyLevel; // 100-120
        rarityRolls = [
            { rarity: 'rare', chance: 20 },
            { rarity: 'epic', chance: 69.8 },
            { rarity: 'legendary', chance: 99.8 },
            { rarity: 'mythic', chance: 100 }
        ];
    } else if (kills < 80) {
        itemLevel = this.endlessEnemyLevel; // 120-140
        rarityRolls = [
            { rarity: 'rare', chance: 10 },
            { rarity: 'epic', chance: 59.7 },
            { rarity: 'legendary', chance: 99.7 },
            { rarity: 'mythic', chance: 100 }
        ];
    } else if (kills < 100) {
        itemLevel = this.endlessEnemyLevel; // 140-160
        rarityRolls = [
            { rarity: 'rare', chance: 5 },
            { rarity: 'epic', chance: 49.5 },
            { rarity: 'legendary', chance: 99.5 },
            { rarity: 'mythic', chance: 100 }
        ];
    } else if (kills < 120) {
        itemLevel = this.endlessEnemyLevel; // 160-180
        rarityRolls = [
            { rarity: 'epic', chance: 34 },
            { rarity: 'legendary', chance: 99 },
            { rarity: 'mythic', chance: 100 }
        ];
    } else if (kills < 140) {
        itemLevel = this.endlessEnemyLevel; // 180-200
        rarityRolls = [
            { rarity: 'epic', chance: 23 },
            { rarity: 'legendary', chance: 98 },
            { rarity: 'mythic', chance: 100 }
        ];
    } else if (kills < 160) {
        itemLevel = this.endlessEnemyLevel; // 200-220
        rarityRolls = [
            { rarity: 'epic', chance: 12 },
            { rarity: 'legendary', chance: 97 },
            { rarity: 'mythic', chance: 100 }
        ];
    } else if (kills < 180) {
        itemLevel = this.endlessEnemyLevel; // 220-240
        rarityRolls = [
            { rarity: 'epic', chance: 5 },
            { rarity: 'legendary', chance: 95 },
            { rarity: 'mythic', chance: 100 }
        ];
    } else if (kills < 200) {
        itemLevel = this.endlessEnemyLevel; // 240-260
        rarityRolls = [
            { rarity: 'epic', chance: 3 },
            { rarity: 'legendary', chance: 93 },
            { rarity: 'mythic', chance: 100 }
        ];
    } else {
        itemLevel = this.endlessEnemyLevel; // 260+
        rarityRolls = [
            { rarity: 'epic', chance: 2 },
            { rarity: 'legendary', chance: 90 },
            { rarity: 'mythic', chance: 100 }
        ];
    }

    // Generate 3 items ONLY if player got 10+ kills (victory threshold)
    const lootTable = ['helmet', 'chest', 'gloves', 'boots', 'belt', 'amulet', 'ring', 'wand', 'dagger', 'greatsword', 'staff', 'bow', 'warhammer'];
    const rewardItems = [];

    // Only generate loot if rarityRolls exist (10+ kills)
    if (rarityRolls) {
        for (let i = 0; i < 3; i++) {
            const itemType = lootTable[Math.floor(Math.random() * lootTable.length)];
            const roll = Math.random() * 100;
            let rarity = 'rare';

            for (const tier of rarityRolls) {
                if (roll < tier.chance) {
                    rarity = tier.rarity;
                    break;
                }
            }

            const item = new Item(itemType, rarity, itemLevel);
            rewardItems.push(item);
            this.inventory.push(item);
        }
    }

    // Build loot display HTML
    const rarityColors = {
        common: '#94a3b8',
        uncommon: '#10b981',
        rare: '#3b82f6',
        epic: '#a855f7',
        legendary: '#f59e0b',
        mythic: '#ef4444'
    };

    let lootHTML = '';

    // Show different message based on kills
    if (kills < 10) {
        // DEFEAT - less than 10 kills
        lootHTML = '<div style="margin: 30px 0;">';
        lootHTML += '<div style="font-size: 22px; color: #ef4444; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 15px; text-align: center; font-weight: 700; text-shadow: 0 0 20px rgba(239, 68, 68, 0.6);">üíÄ DEFEAT üíÄ</div>';
        lootHTML += '<div style="font-size: 14px; color: #94a3b8; text-align: center; margin-bottom: 10px;">Reach 10 kills for arena rewards!</div>';
        lootHTML += '</div>';
    } else {
        // VICTORY - 10+ kills, show loot
        lootHTML = '<div style="margin: 30px 0;">';
        lootHTML += '<div style="font-size: 16px; color: #94a3b8; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 15px; text-align: center; font-weight: 600;">‚öîÔ∏è ARENA REWARDS ‚öîÔ∏è</div>';

        rewardItems.forEach(item => {
            const itemColor = rarityColors[item.rarity] || '#94a3b8';
            lootHTML += `
                <div style="margin: 15px 0; padding: 20px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.05)); border: 2px solid ${itemColor}; border-radius: 12px; box-shadow: 0 0 20px ${itemColor}40;">
                    <div style="font-size: 18px; font-weight: 800; color: ${itemColor}; text-align: center; font-family: 'Orbitron', sans-serif; text-shadow: 0 2px 10px ${itemColor}80; margin-bottom: 6px;">
                        ${item.name}
                    </div>
                    <div style="font-size: 12px; color: #cbd5e1; text-align: center; line-height: 1.4;">
                        ${item.getStatsDisplay ? item.getStatsDisplay() : ''}
                    </div>
                </div>
            `;
        });
        lootHTML += '</div>';
    }

    const overlay = document.createElement('div');
    overlay.id = 'endless-summary-overlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: radial-gradient(ellipse at center, rgba(168, 85, 247, 0.15) 0%, rgba(0, 0, 0, 0.95) 70%);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 2000;
        backdrop-filter: blur(20px);
        animation: fadeIn 0.3s ease;
    `;

    const panel = document.createElement('div');
    panel.style.cssText = `
        background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(6, 9, 23, 0.98) 100%);
        border: 3px solid ${kills >= 10 ? '#10b981' : '#ef4444'};
        border-radius: 20px;
        padding: 40px;
        max-width: 700px;
        width: 90%;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 30px 80px rgba(0, 0, 0, 0.9), 0 0 40px rgba(${kills >= 10 ? '16, 185, 129' : '239, 68, 68'}, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        animation: slideUp 0.4s ease;
    `;

    panel.innerHTML = `
        <div style="font-family: 'Orbitron', sans-serif; font-size: 48px; font-weight: 800; text-align: center; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 4px; ${kills >= 10 ?
            'background: linear-gradient(135deg, #10b981, #34d399); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 0 40px rgba(16, 185, 129, 0.5);' :
            'background: linear-gradient(135deg, #ef4444, #dc2626); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 0 40px rgba(239, 68, 68, 0.5);'} animation: titlePulse 2s ease-in-out infinite;">
            ${kills >= 10 ? '‚öîÔ∏è VICTORY ‚öîÔ∏è' : 'üíÄ DEFEAT üíÄ'}
        </div>

        <div style="text-align: center; font-size: 32px; color: ${kills >= 10 ? '#10b981' : '#ef4444'}; font-weight: 800; margin-bottom: 30px; font-family: 'Orbitron', sans-serif; text-shadow: 0 0 20px rgba(${kills >= 10 ? '16, 185, 129' : '239, 68, 68'}, 0.6);">
            ${this.endlessKillCount} KILLS
        </div>

        ${lootHTML}

        <div style="background: rgba(15, 23, 42, 0.5); border-radius: 12px; padding: 25px; margin-bottom: 25px; border: 1px solid rgba(16, 185, 129, 0.3);">
            <div style="display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid rgba(168, 85, 247, 0.1);">
                <span style="color: #94a3b8; font-weight: 500;">üíÄ Final Enemy Level:</span>
                <span style="color: #a855f7; font-weight: 700; font-family: 'Orbitron', sans-serif; font-size: 20px;">${this.endlessEnemyLevel}</span>
            </div>
            <div style="display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid rgba(168, 85, 247, 0.1);">
                <span style="color: #94a3b8; font-weight: 500;">üí∞ Gold Earned:</span>
                <span style="color: #f59e0b; font-weight: 700; font-family: 'Orbitron', sans-serif; font-size: 20px;">${this.floorStats.goldEarned}g</span>
            </div>
            <div style="display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid rgba(168, 85, 247, 0.1);">
                <span style="color: #94a3b8; font-weight: 500;">üî• Damage Dealt:</span>
                <span style="color: #ef4444; font-weight: 700; font-family: 'Orbitron', sans-serif; font-size: 20px;">${this.floorStats.damageDealt.toLocaleString()}</span>
            </div>
            <div style="display: flex; justify-content: space-between; padding: 10px 0;">
                <span style="color: #94a3b8; font-weight: 500;">‚ú® Blessings Earned:</span>
                <span style="color: #e9d5ff; font-weight: 700; font-family: 'Orbitron', sans-serif; font-size: 28px; text-shadow: 0 0 10px rgba(168, 85, 247, 0.8);">${totalBlessings}</span>
            </div>
        </div>

        <button id="endless-summary-btn" style="width: 100%; padding: 18px; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 12px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 16px; font-weight: 700; text-transform: uppercase; letter-spacing: 2px; transition: all 0.3s ease; box-shadow: 0 4px 20px rgba(16, 185, 129, 0.4);">
            Return to Dungeon Selection (5s)
        </button>
    `;

    overlay.appendChild(panel);
    document.body.appendChild(overlay);

    const style = document.createElement('style');
    style.textContent = `
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideUp { from { transform: translateY(50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes titlePulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.8; } }
    `;
    document.head.appendChild(style);

    let countdown = 5;
    const button = document.getElementById('endless-summary-btn');

    const countdownInterval = setInterval(() => {
        countdown--;
        if (countdown > 0) {
            button.textContent = `Return to Dungeon Selection (${countdown}s)`;
        } else {
            button.textContent = 'Return to Dungeon Selection';
        }
    }, 1000);

    const returnAction = () => {
        clearInterval(countdownInterval);
        overlay.remove();
        style.remove();

        // Save the kill count for leaderboard tracking
        localStorage.setItem('currentEndlessKills', this.endlessKillCount.toString());

        this.currentDungeon = null;
        this.dungeonFloor = 1;
        this.room = null;
        this.dungeonLayout = null;
        this.enemies = [];
        this.hallways = [];
        this.adjacentRooms = [];
        this.endlessKillCount = 0;
        this.endlessWave = 1;
        this.endlessEnemyLevel = 60;

        // Show minimap again
        const minimapCanvas = document.getElementById('map-canvas');
        if (minimapCanvas) {
            minimapCanvas.style.display = 'block';
        }

        // Hide kill counter
        const killCounter = document.getElementById('kill-counter');
        if (killCounter) {
            killCounter.style.display = 'none';
        }

        // Hide damage stats display
        const combatStatsContainer = document.getElementById('combat-stats-container');
        if (combatStatsContainer) {
            combatStatsContainer.style.display = 'none';
        }

        document.getElementById('room-label').style.display = 'none';
        this.showDungeonSelector();
    };

    button.onclick = returnAction;
    setTimeout(returnAction, 5000);
}


drawMinimap() {
    // Don't draw minimap for endless mode - it's a single arena
    if (this.currentDungeon === 'endlessblessings') {
        return;
    }

    // Only redraw minimap every 500ms
    const now = Date.now();
    if (now - this._lastMinimapUpdate < 500) return;
    this._lastMinimapUpdate = now;

    const ctx = this.mapCtx;
    const canvasWidth = this.mapCanvas.width;
    const canvasHeight = this.mapCanvas.height;

    // Disable anti-aliasing for crisp pixels
    ctx.imageSmoothingEnabled = false;
    ctx.webkitImageSmoothingEnabled = false;
    ctx.mozImageSmoothingEnabled = false;
    ctx.msImageSmoothingEnabled = false;

    // Calculate cell size - use FULL canvas
    const gridSize = this.dungeonLayout.gridSize;
    const padding = 5; // Minimal padding
    const maxCellSize = Math.min(
        (canvasWidth - padding * 2) / gridSize,
        (canvasHeight - padding * 2) / gridSize
    );
    const cellSize = Math.floor(maxCellSize);

    // Calculate total grid dimensions
    const totalWidth = gridSize * cellSize;
    const totalHeight = gridSize * cellSize;

    // Center the grid in the canvas
    const offsetX = (canvasWidth - totalWidth) / 2;
    const offsetY = (canvasHeight - totalHeight) / 2;

    // Store room positions for hover detection
    this.minimapRooms = [];

    // Clear canvas with dark background
    ctx.fillStyle = 'rgba(6, 9, 23, 0.95)';
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

    // Draw grid lines for structure
    ctx.strokeStyle = 'rgba(99, 102, 241, 0.08)';
    ctx.lineWidth = 1;
    for (let x = offsetX; x <= offsetX + totalWidth; x += cellSize) {
        ctx.beginPath();
        ctx.moveTo(x, offsetY);
        ctx.lineTo(x, offsetY + totalHeight);
        ctx.stroke();
    }
    for (let y = offsetY; y <= offsetY + totalHeight; y += cellSize) {
        ctx.beginPath();
        ctx.moveTo(offsetX, y);
        ctx.lineTo(offsetX + totalWidth, y);
        ctx.stroke();
    }

    // Draw connections FIRST (under rooms)
    for (const room of this.dungeonLayout.rooms) {
        const x = offsetX + room.x * cellSize + cellSize/2;
        const y = offsetY + room.y * cellSize + cellSize/2;

        for (const connection of room.connections) {
            const x2 = offsetX + connection.x * cellSize + cellSize/2;
            const y2 = offsetY + connection.y * cellSize + cellSize/2;

            // Connection color based on status
            const connectedRoom = this.dungeonLayout.rooms.find(r => r.x === connection.x && r.y === connection.y);
            if (room.cleared && connectedRoom?.cleared) {
                ctx.strokeStyle = 'rgba(16, 185, 129, 0.6)';
            } else if (room.visited || connectedRoom?.visited) {
                ctx.strokeStyle = 'rgba(100, 116, 139, 0.5)';
            } else {
                ctx.strokeStyle = 'rgba(71, 85, 105, 0.3)';
            }

            ctx.lineWidth = Math.max(4, cellSize * 0.15);
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }
    }

    // Draw rooms AFTER connections (on top)
    for (const room of this.dungeonLayout.rooms) {
        const x = offsetX + room.x * cellSize;
        const y = offsetY + room.y * cellSize;
        const roomPadding = 2;
        const roomSize = cellSize - roomPadding * 2;

        // Store room position for hover
        this.minimapRooms.push({
            room: room,
            x: x + roomPadding,
            y: y + roomPadding,
            width: roomSize,
            height: roomSize
        });

        // Determine room color
        let fillColor, borderColor;

        if (room === this.dungeonLayout.getCurrentRoom()) {
            // Current room - bright orange with pulse
            const pulse = Math.sin(Date.now() / 300) * 0.2 + 0.8;
            fillColor = `rgba(245, 158, 11, ${pulse})`;
            borderColor = '#f59e0b';
        } else if (room.type === ROOM_TYPES.BOSS) {
            fillColor = '#dc2626';  // Red for boss
            borderColor = '#ef4444';
        } else if (room.type === ROOM_TYPES.FOUNTAIN && room.visited) {
            fillColor = '#3b82f6';  // Blue for fountain
            borderColor = '#60a5fa';
        } else if (room.type === ROOM_TYPES.TREASURE) {
            fillColor = '#f59e0b';  // Gold for treasure
            borderColor = '#fbbf24';
        } else if (room.cleared) {
            fillColor = '#10b981';  // Green for cleared
            borderColor = '#34d399';
        } else if (room.visited) {
            fillColor = '#f87171';  // Light red for visited/has enemies
            borderColor = '#fca5a5';
        } else {
            fillColor = '#4b5563';  // Gray for unexplored
            borderColor = '#6b7280';
        }

        // Draw room fill
        ctx.fillStyle = fillColor;
        ctx.fillRect(x + roomPadding, y + roomPadding, roomSize, roomSize);

        // Draw room border
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = room === this.dungeonLayout.getCurrentRoom() ? 2 : 1;
        ctx.strokeRect(x + roomPadding, y + roomPadding, roomSize, roomSize);
    }


}

            startBattle() {
                this.inBattle = true;
                this.battleTimer = 0;
                this.battleStartTime = Date.now();

                // Reset room regen tracking for new battle
                this._roomRegenTicks = 0;
                this._roomStartTick = 0;

                // Initialize visual effects arrays
                if (!this.visualEffects) this.visualEffects = [];

                // Initialize character combat statistics tracking (but don't reset - that happens per floor)
                if (!this.characterStats) this.characterStats = {};
                this.party.forEach(member => {
                    if (!this.characterStats[member.name]) {
                        this.characterStats[member.name] = {
                            damageDealt: 0,
                            healingDone: 0
                        };
                    }
                    // Stats accumulate across rooms in the same floor
                });

                // Initialize stats display mode if not set
                if (!this.characterStatsDisplayMode) {
                    this.characterStatsDisplayMode = 'damage';
                }

                // Show combat stats display for all dungeons - CRITICAL FOR ALL DUNGEONS
                const combatStatsContainer = document.getElementById('combat-stats-container');
                if (combatStatsContainer) {
                    combatStatsContainer.style.display = 'flex';
                    console.log('‚úÖ Combat stats container shown for battle');
                    this.updateCharacterStatsDisplay();
                } else {
                    console.warn('‚ö†Ô∏è Combat stats container not found!');
                }

                // Initialize attack timers for all units
                [...this.party, ...this.enemies].forEach(unit => {
                    unit.attackTimer = Math.random() * 50; // Stagger initial attacks
                    unit.hasEngaged = false; // Track if unit has engaged in this battle
                });
            }

            createTauntEffect(sprite) {
                if (!sprite) return;
                const pos = ISO.toScreen(sprite.gridX, sprite.gridY);

                // Create expanding red ring for taunt
                this.visualEffects.push({
                    type: 'ring',
                    x: pos.x + this.offsetX,
                    y: pos.y + this.offsetY,
                    radius: 10,
                    maxRadius: 120,
                    color: 'rgba(239, 68, 68, 0.6)',
                    lineWidth: 6,
                    life: 30
                });

                // Add intimidation lines
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI * 2 * i) / 6;
                    this.visualEffects.push({
                        type: 'line',
                        x: pos.x + this.offsetX,
                        y: pos.y + this.offsetY,
                        angle: angle,
                        length: 0,
                        maxLength: 60,
                        color: 'rgba(239, 68, 68, 0.8)',
                        width: 4,
                        life: 25
                    });
                }
            }

            createDoubleStrikeEffect(sprite) {
                if (!sprite) return;
                const pos = ISO.toScreen(sprite.gridX, sprite.gridY);

                // Create two crossing slash marks
                this.visualEffects.push({
                    type: 'slash',
                    x: pos.x + this.offsetX,
                    y: pos.y + this.offsetY,
                    angle: -Math.PI / 4,
                    length: 0,
                    maxLength: 80,
                    color: 'rgba(239, 68, 68, 0.9)',
                    width: 3,
                    life: 20
                });

                setTimeout(() => {
                    this.visualEffects.push({
                        type: 'slash',
                        x: pos.x + this.offsetX,
                        y: pos.y + this.offsetY,
                        angle: Math.PI / 4,
                        length: 0,
                        maxLength: 80,
                        color: 'rgba(239, 68, 68, 0.9)',
                        width: 3,
                        life: 20
                    });
                }, 100);
            }

            createFireballEffect(casterSprite, targets) {
                if (!casterSprite) return;
                const startPos = ISO.toScreen(casterSprite.gridX, casterSprite.gridY);

                targets.forEach((target, index) => {
                    if (!target.sprite) return;
                    const endPos = ISO.toScreen(target.sprite.gridX, target.sprite.gridY);

                    // Stagger fireballs slightly
                    setTimeout(() => {
                        this.visualEffects.push({
                            type: 'projectile',
                            x: startPos.x + this.offsetX,
                            y: startPos.y + this.offsetY - 20,
                            targetX: endPos.x + this.offsetX,
                            targetY: endPos.y + this.offsetY,
                            speed: 8,
                            color: 'rgba(255, 100, 0, 0.9)',
                            size: 12,
                            trail: [],
                            life: 60
                        });
                    }, index * 50);
                });
            }
            createInvulnerabilityEffect(sprite) {
                if (!sprite) return;
                const pos = ISO.toScreen(sprite.gridX, sprite.gridY);

                // Golden shield dome
                this.visualEffects.push({
                    type: 'dome',
                    x: pos.x + this.offsetX,
                    y: pos.y + this.offsetY,
                    radius: 20,
                    maxRadius: 50,
                    color: 'rgba(245, 158, 11, 0.4)',
                    life: 60
                });

                // Rotating shield rings
                for (let i = 0; i < 3; i++) {
                    this.visualEffects.push({
                        type: 'rotating-ring',
                        x: pos.x + this.offsetX,
                        y: pos.y + this.offsetY,
                        radius: 30 + i * 10,
                        angle: i * 60,
                        color: 'rgba(245, 158, 11, 0.6)',
                        life: 180 // 3 seconds at 60fps
                    });
                }
            }

            createBloodFrenzyEffect(sprite) {
                if (!sprite) return;
                const pos = ISO.toScreen(sprite.gridX, sprite.gridY);

                // Blood explosion - REDUCED for performance
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI * 2 * i) / 6;
                    this.visualEffects.push({
                        type: 'blood-drop',
                        x: pos.x + this.offsetX,
                        y: pos.y + this.offsetY,
                        vx: Math.cos(angle) * 5,
                        vy: Math.sin(angle) * 5,
                        color: 'rgba(220, 38, 38, 0.8)',
                        size: 5,
                        life: 30
                    });
                }

                // Red aura
                this.visualEffects.push({
                    type: 'aura',
                    x: pos.x + this.offsetX,
                    y: pos.y + this.offsetY,
                    radius: 25,
                    maxRadius: 40,
                    color: 'rgba(220, 38, 38, 0.3)',
                    life: 480 // 8 seconds
                });
            }

            createSeismicSlamEffect(sprite) {
                if (!sprite) return;
                const pos = ISO.toScreen(sprite.gridX, sprite.gridY);

                // Ground shockwave
                this.visualEffects.push({
                    type: 'shockwave',
                    x: pos.x + this.offsetX,
                    y: pos.y + this.offsetY,
                    radius: 10,
                    maxRadius: 150,
                    color: 'rgba(251, 146, 60, 0.6)',
                    lineWidth: 8,
                    life: 40
                });

                // Earth spikes
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 * i) / 8;
                    setTimeout(() => {
                        this.visualEffects.push({
                            type: 'spike',
                            x: pos.x + this.offsetX + Math.cos(angle) * 60,
                            y: pos.y + this.offsetY + Math.sin(angle) * 60,
                            height: 0,
                            maxHeight: 40,
                            color: 'rgba(168, 162, 158, 0.9)',
                            life: 30
                        });
                    }, i * 50);
                }
            }

            createBlizzardEffect(targets) {
                // Icy storm over whole battlefield - REDUCED for performance
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        this.visualEffects.push({
                            type: 'ice-shard',
                            x: this.canvas.width / 2 + (Math.random() - 0.5) * 400,
                            y: 100,
                            vy: 5,
                            vx: (Math.random() - 0.5) * 2,
                            color: 'rgba(186, 230, 253, 0.9)',
                            size: 8,
                            life: 60
                        });
                    }, i * 100);
                }

                // Freeze effect on each target
                targets.forEach(target => {
                    if (!target.sprite) return;
                    const pos = ISO.toScreen(target.sprite.gridX, target.sprite.gridY);
                    this.visualEffects.push({
                        type: 'freeze',
                        x: pos.x + this.offsetX,
                        y: pos.y + this.offsetY,
                        radius: 30,
                        color: 'rgba(125, 211, 252, 0.5)',
                        life: 120 // 2 seconds frozen
                    });
                });
            }

            createVoidSurgeEffect(sprite) {
                if (!sprite) return;
                const pos = ISO.toScreen(sprite.gridX, sprite.gridY);

                // Purple void energy
                this.visualEffects.push({
                    type: 'void-portal',
                    x: pos.x + this.offsetX,
                    y: pos.y + this.offsetY,
                    radius: 15,
                    maxRadius: 45,
                    color: 'rgba(139, 92, 246, 0.6)',
                    life: 300 // 5 attacks
                });

                // Void tendrils
                for (let i = 0; i < 6; i++) {
                    this.visualEffects.push({
                        type: 'tendril',
                        x: pos.x + this.offsetX,
                        y: pos.y + this.offsetY,
                        angle: (Math.PI * 2 * i) / 6,
                        length: 0,
                        maxLength: 60,
                        color: 'rgba(124, 58, 237, 0.8)',
                        life: 300
                    });
                }
            }

            createTemporalRewindEffect() {
                // Clockwise spiral effect across whole screen
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 3;

                for (let i = 0; i < 6; i++) {
                    setTimeout(() => {
                        const angle = (Math.PI * 2 * i) / 6;
                        this.visualEffects.push({
                            type: 'time-ripple',
                            x: centerX,
                            y: centerY,
                            angle: angle,
                            radius: 0,
                            maxRadius: 300,
                            color: 'rgba(245, 158, 11, 0.4)',
                            life: 40
                        });
                    }, i * 50);
                }
            }

            createCrippleEffect(sprite) {
                if (!sprite) return;
                const pos = ISO.toScreen(sprite.gridX, sprite.gridY);

                // Dark red slash mark
                this.visualEffects.push({
                    type: 'cripple-slash',
                    x: pos.x + this.offsetX,
                    y: pos.y + this.offsetY,
                    angle: -Math.PI / 3,
                    length: 0,
                    maxLength: 70,
                    color: 'rgba(127, 29, 29, 0.9)',
                    width: 6,
                    life: 25
                });

                // Debuff aura
                this.visualEffects.push({
                    type: 'debuff',
                    x: pos.x + this.offsetX,
                    y: pos.y + this.offsetY,
                    radius: 25,
                    color: 'rgba(127, 29, 29, 0.3)',
                    life: 300 // 5 seconds
                });
            }

            createShadowStepEffect(sprite) {
                if (!sprite) return;
                const pos = ISO.toScreen(sprite.gridX, sprite.gridY);

                // Shadow clone afterimages
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        this.visualEffects.push({
                            type: 'afterimage',
                            x: pos.x + this.offsetX + (Math.random() - 0.5) * 40,
                            y: pos.y + this.offsetY + (Math.random() - 0.5) * 40,
                            alpha: 0.6,
                            color: 'rgba(0, 0, 0, 0.6)',
                            life: 20
                        });
                    }, i * 100);
                }

                // Shadow veil
                this.visualEffects.push({
                    type: 'shadow-veil',
                    x: pos.x + this.offsetX,
                    y: pos.y + this.offsetY,
                    radius: 35,
                    color: 'rgba(0, 0, 0, 0.5)',
                    life: 240 // 4 seconds
                });
            }

            createToxicCascadeEffect(sprite) {
                if (!sprite) return;
                const pos = ISO.toScreen(sprite.gridX, sprite.gridY);

                // Poison cloud
                this.visualEffects.push({
                    type: 'poison-cloud',
                    x: pos.x + this.offsetX,
                    y: pos.y + this.offsetY,
                    radius: 20,
                    maxRadius: 50,
                    color: 'rgba(16, 185, 129, 0.4)',
                    life: 600 // 10 seconds
                });

                // Poison bubbles
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        this.visualEffects.push({
                            type: 'poison-bubble',
                            x: pos.x + this.offsetX + (Math.random() - 0.5) * 30,
                            y: pos.y + this.offsetY,
                            vy: -2,
                            size: 4,
                            color: 'rgba(16, 185, 129, 0.7)',
                            life: 40
                        });
                    }, i * 150);
                }
            }
            createHealEffect(sprite) {
                if (!sprite) return;
                const pos = ISO.toScreen(sprite.gridX, sprite.gridY);

                // Create ascending green sparkles
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        const offsetX = (Math.random() - 0.5) * 30;
                        this.visualEffects.push({
                            type: 'sparkle',
                            x: pos.x + this.offsetX + offsetX,
                            y: pos.y + this.offsetY + 10,
                            vy: -2,
                            vx: offsetX * 0.02,
                            color: 'rgba(16, 185, 129, 0.8)',
                            size: 6,
                            life: 40
                        });
                    }, i * 50);
                }

                // Add a gentle green glow
                this.visualEffects.push({
                    type: 'glow',
                    x: pos.x + this.offsetX,
                    y: pos.y + this.offsetY,
                    radius: 20,
                    maxRadius: 60,
                    color: 'rgba(16, 185, 129, 0.3)',
                    life: 30
                });
            }

            createMultiShotEffect(casterSprite, targets) {
                if (!casterSprite) return;
                const startPos = ISO.toScreen(casterSprite.gridX, casterSprite.gridY);

                // Fire 3 arrows at different targets with stagger
                const arrowTargets = targets.slice(0, 3);
                arrowTargets.forEach((target, index) => {
                    if (!target.sprite) return;
                    const endPos = ISO.toScreen(target.sprite.gridX, target.sprite.gridY);

                    // Stagger arrows slightly
                    setTimeout(() => {
                        this.visualEffects.push({
                            type: 'arrow-projectile',
                            x: startPos.x + this.offsetX,
                            y: startPos.y + this.offsetY - 20,
                            targetX: endPos.x + this.offsetX,
                            targetY: endPos.y + this.offsetY,
                            speed: 12, // Arrows are fast!
                            angle: 0,
                            color: 'rgba(132, 204, 22, 0.9)', // Green arrow
                            size: 8,
                            trail: [],
                            life: 60
                        });
                    }, index * 100); // 100ms between arrows
                });

                // Bow flash effect
                this.visualEffects.push({
                    type: 'glow',
                    x: startPos.x + this.offsetX,
                    y: startPos.y + this.offsetY - 20,
                    radius: 15,
                    maxRadius: 35,
                    color: 'rgba(132, 204, 22, 0.4)',
                    life: 15
                });
            }

            createDivineShieldEffect(casterSprite) {
                if (!casterSprite) return;
                const pos = ISO.toScreen(casterSprite.gridX, casterSprite.gridY);

                // Holy light pillar from above
                this.visualEffects.push({
                    type: 'holy-pillar',
                    x: pos.x + this.offsetX,
                    y: pos.y + this.offsetY - 100,
                    targetY: pos.y + this.offsetY,
                    height: 0,
                    maxHeight: 100,
                    color: 'rgba(251, 191, 36, 0.6)',
                    width: 40,
                    life: 20
                });

                // Golden shield dome for ALL party members
                if (this.party) {
                    this.party.forEach(member => {
                        if (member.sprite && member.isAlive) {
                            const memberPos = ISO.toScreen(member.sprite.gridX, member.sprite.gridY);

                            // Shield dome
                            this.visualEffects.push({
                                type: 'dome',
                                x: memberPos.x + this.offsetX,
                                y: memberPos.y + this.offsetY,
                                radius: 20,
                                maxRadius: 45,
                                color: 'rgba(251, 191, 36, 0.35)',
                                life: 240 // 4 seconds
                            });

                            // Holy sparkles
                            for (let i = 0; i < 6; i++) {
                                setTimeout(() => {
                                    const angle = (Math.PI * 2 * i) / 6;
                                    this.visualEffects.push({
                                        type: 'sparkle',
                                        x: memberPos.x + this.offsetX + Math.cos(angle) * 30,
                                        y: memberPos.y + this.offsetY + Math.sin(angle) * 20,
                                        vy: -1.5,
                                        vx: 0,
                                        color: 'rgba(254, 243, 199, 0.9)',
                                        size: 5,
                                        life: 30
                                    });
                                }, i * 80);
                            }
                        }
                    });
                }

                // Radiant burst from caster
                for (let i = 0; i < 12; i++) {
                    const angle = (Math.PI * 2 * i) / 12;
                    this.visualEffects.push({
                        type: 'spark',
                        x: pos.x + this.offsetX,
                        y: pos.y + this.offsetY,
                        vx: Math.cos(angle) * 4,
                        vy: Math.sin(angle) * 4,
                        color: 'rgba(251, 191, 36, 0.8)',
                        size: 4,
                        life: 25
                    });
                }
            }

            // ARCHER KEYSTONE VISUAL EFFECTS
            createPerfectShotEffect(casterSprite, targetSprite) {
                if (!casterSprite || !targetSprite) return;
                const startPos = ISO.toScreen(casterSprite.gridX, casterSprite.gridY);
                const endPos = ISO.toScreen(targetSprite.gridX, targetSprite.gridY);

                // Golden arrow trail
                this.visualEffects.push({
                    type: 'line',
                    x: startPos.x + this.offsetX,
                    y: startPos.y + this.offsetY - 10,
                    targetX: endPos.x + this.offsetX,
                    targetY: endPos.y + this.offsetY - 10,
                    color: 'rgba(251, 191, 36, 0.9)',
                    width: 4,
                    life: 15
                });

                // Impact sparkles
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 * i) / 8;
                    this.visualEffects.push({
                        type: 'spark',
                        x: endPos.x + this.offsetX,
                        y: endPos.y + this.offsetY - 10,
                        vx: Math.cos(angle) * 3,
                        vy: Math.sin(angle) * 3,
                        color: 'rgba(251, 191, 36, 0.9)',
                        size: 4,
                        life: 20
                    });
                }
            }

            createArrowEffect(casterSprite, targetSprite) {
                if (!casterSprite || !targetSprite) return;
                const startPos = ISO.toScreen(casterSprite.gridX, casterSprite.gridY);
                const endPos = ISO.toScreen(targetSprite.gridX, targetSprite.gridY);

                // Arrow trail
                this.visualEffects.push({
                    type: 'line',
                    x: startPos.x + this.offsetX,
                    y: startPos.y + this.offsetY - 10,
                    targetX: endPos.x + this.offsetX,
                    targetY: endPos.y + this.offsetY - 10,
                    color: 'rgba(132, 204, 22, 0.7)',
                    width: 2,
                    life: 10
                });
            }

            createMarkEffect(sprite) {
                if (!sprite) return;
                const pos = ISO.toScreen(sprite.gridX, sprite.gridY);

                // Red target marker
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        this.visualEffects.push({
                            type: 'ring',
                            x: pos.x + this.offsetX,
                            y: pos.y + this.offsetY - 15,
                            radius: 5,
                            maxRadius: 35,
                            color: 'rgba(239, 68, 68, 0.6)',
                            width: 2,
                            life: 30
                        });
                    }, i * 100);
                }
            }

            // PALADIN KEYSTONE VISUAL EFFECTS
            createDivineWrathEffect(casterSprite) {
                if (!casterSprite) return;
                const pos = ISO.toScreen(casterSprite.gridX, casterSprite.gridY);

                // Holy explosion from caster
                this.visualEffects.push({
                    type: 'ring',
                    x: pos.x + this.offsetX,
                    y: pos.y + this.offsetY,
                    radius: 10,
                    maxRadius: 120,
                    color: 'rgba(251, 191, 36, 0.5)',
                    width: 3,
                    life: 25
                });

                // Divine sparks - REDUCED for performance
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 * i) / 8;
                    this.visualEffects.push({
                        type: 'spark',
                        x: pos.x + this.offsetX,
                        y: pos.y + this.offsetY - 20,
                        vx: Math.cos(angle) * 4,
                        vy: Math.sin(angle) * 4 - 2,
                        color: 'rgba(254, 243, 199, 0.9)',
                        size: 5,
                        life: 30
                    });
                }
            }

            createSacredBarrierEffect(casterSprite) {
                if (!casterSprite) return;

                // Golden shields for all party members
                if (this.party) {
                    this.party.forEach(member => {
                        if (member.sprite && member.isAlive) {
                            const memberPos = ISO.toScreen(member.sprite.gridX, member.sprite.gridY);

                            // Shield barrier
                            this.visualEffects.push({
                                type: 'dome',
                                x: memberPos.x + this.offsetX,
                                y: memberPos.y + this.offsetY,
                                radius: 15,
                                maxRadius: 40,
                                color: 'rgba(59, 130, 246, 0.4)',
                                life: 360 // 6 seconds
                            });
                        }
                    });
                }
            }

            createHolyFireEffect(casterSprite) {
                if (!casterSprite) return;
                const pos = ISO.toScreen(casterSprite.gridX, casterSprite.gridY);

                // Fire wave expanding from caster
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        this.visualEffects.push({
                            type: 'ring',
                            x: pos.x + this.offsetX,
                            y: pos.y + this.offsetY,
                            radius: 20 + i * 15,
                            maxRadius: 100 + i * 15,
                            color: 'rgba(249, 115, 22, 0.5)',
                            width: 4,
                            life: 30
                        });
                    }, i * 100);
                }

                // Fire sparks
                for (let i = 0; i < 20; i++) {
                    const angle = (Math.PI * 2 * i) / 20;
                    this.visualEffects.push({
                        type: 'spark',
                        x: pos.x + this.offsetX,
                        y: pos.y + this.offsetY,
                        vx: Math.cos(angle) * 3,
                        vy: Math.sin(angle) * 3 - 1,
                        color: 'rgba(251, 146, 60, 0.9)',
                        size: 4,
                        life: 25
                    });
                }
            }

            updateVisualEffects() {
                if (!this.visualEffects) return;

                // Cap effects for performance
                // Cap effects efficiently (in-place removal instead of slice)
                if (this.visualEffects.length > 15) {
                    this.visualEffects.splice(0, this.visualEffects.length - 15);
                }

                for (let i = this.visualEffects.length - 1; i >= 0; i--) {
                    const effect = this.visualEffects[i];
                    effect.life--;

                    // Update based on type
                    switch(effect.type) {
                        case 'ring':
                            effect.radius += (effect.maxRadius - effect.radius) * 0.15;
                            break;
                        case 'line':
                            effect.length += (effect.maxLength - effect.length) * 0.2;
                            break;
                        case 'slash':
                            effect.length += (effect.maxLength - effect.length) * 0.3;
                            break;
                        case 'projectile': {
                            const dx = effect.targetX - effect.x;
                            const dy = effect.targetY - effect.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > 5) {
                                // Store trail positions
                                effect.trail.push({x: effect.x, y: effect.y, life: 10});
                                if (effect.trail.length > 5) effect.trail.shift();

                                effect.x += (dx / dist) * effect.speed;
                                effect.y += (dy / dist) * effect.speed;
                            } else {
                                // Hit target - create explosion
                                for (let j = 0; j < 6; j++) {
                                    const angle = (Math.PI * 2 * j) / 6;
                                    this.visualEffects.push({
                                        type: 'spark',
                                        x: effect.x,
                                        y: effect.y,
                                        vx: Math.cos(angle) * 3,
                                        vy: Math.sin(angle) * 3,
                                        color: 'rgba(255, 100, 0, 0.8)',
                                        size: 2,
                                        life: 15
                                    });
                                }
                                effect.life = 0;
                            }
                            break;
                        }
                        case 'arrow-projectile': {
                            const dx = effect.targetX - effect.x;
                            const dy = effect.targetY - effect.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > 5) {
                                // Store trail positions
                                effect.trail.push({x: effect.x, y: effect.y, life: 10});
                                if (effect.trail.length > 8) effect.trail.shift();

                                effect.x += (dx / dist) * effect.speed;
                                effect.y += (dy / dist) * effect.speed;
                            } else {
                                // Hit target - create green impact
                                for (let j = 0; j < 4; j++) {
                                    const angle = (Math.PI * 2 * j) / 4;
                                    this.visualEffects.push({
                                        type: 'spark',
                                        x: effect.x,
                                        y: effect.y,
                                        vx: Math.cos(angle) * 2,
                                        vy: Math.sin(angle) * 2,
                                        color: 'rgba(132, 204, 22, 0.8)',
                                        size: 3,
                                        life: 12
                                    });
                                }
                                effect.life = 0;
                            }
                            break;
                        }
                        case 'sparkle':
                            effect.y += effect.vy;
                            effect.x += effect.vx;
                            effect.vy *= 0.98;
                            effect.size *= 0.97;
                            break;
                        case 'spark':
                            effect.x += effect.vx;
                            effect.y += effect.vy;
                            effect.vx *= 0.95;
                            effect.vy *= 0.95;
                            effect.size *= 0.95;
                            break;
                        case 'dome':
                        case 'aura':
                        case 'void-portal':
                        case 'freeze':
                        case 'shadow-veil':
                        case 'poison-cloud':
                            effect.radius += (effect.maxRadius - effect.radius) * 0.1;
                            break;
                        case 'rotating-ring':
                            effect.angle += 3; // Rotate
                            break;
                        case 'shockwave':
                            effect.radius += (effect.maxRadius - effect.radius) * 0.25;
                            break;
                        case 'spike':
                            effect.height += (effect.maxHeight - effect.height) * 0.35;
                            break;
                        case 'holy-pillar':
                            effect.height += (effect.maxHeight - effect.height) * 0.4;
                            break;
                        case 'blood-drop':
                        case 'ice-shard':
                        case 'poison-bubble':
                            effect.x += effect.vx || 0;
                            effect.y += effect.vy || 0;
                            if (effect.vy) effect.vy += 0.3; // Gravity
                            if (effect.vx) effect.vx *= 0.95; // Friction
                            effect.size *= 0.97;
                            break;
                        case 'tendril':
                        case 'cripple-slash':
                            effect.length += (effect.maxLength - effect.length) * 0.3;
                            break;
                        case 'time-ripple':
                            effect.radius += (effect.maxRadius - effect.radius) * 0.2;
                            break;
                        case 'afterimage':
                            effect.alpha *= 0.9;
                            break;
                        case 'debuff':
                            // Just persist
                            break;
                        case 'ice-orbit':
                            effect.angle += 0.1;
                            effect.x = effect.x + Math.cos(effect.angle) * 0.5;
                            effect.y = effect.y + Math.sin(effect.angle) * 0.5;
                            break;
                        case 'lightning-bolt':
                            // Just display briefly
                            break;
                    }

                    if (effect.life <= 0) {
                        this.visualEffects.splice(i, 1);
                    }
                }
            }
            drawRuneTrialPillar(ctx) {
                if (!this.runeTrialPillar || !this.currentDungeon === 'runetrial') return;

                const pillar = this.runeTrialPillar;
                const pos = ISO.toScreen(pillar.gridX, pillar.gridY);
                const x = pos.x + this.offsetX;
                const y = pos.y + this.offsetY;

                // Draw pillar base (larger circle)
                ctx.fillStyle = '#1e293b';
                ctx.beginPath();
                ctx.arc(x, y, 25, 0, Math.PI * 2);
                ctx.fill();

                // Draw pillar body (vertical rectangle in isometric)
                ctx.fillStyle = '#3b82f6';
                ctx.fillRect(x - 15, y - 40, 30, 40);

                // Draw pillar top (smaller circle)
                ctx.fillStyle = '#60a5fa';
                ctx.beginPath();
                ctx.arc(x, y - 40, 18, 0, Math.PI * 2);
                ctx.fill();

                // Draw charging effect
                if (this.runeTrialPillarCharging) {
                    const chargePercent = this.runeTrialPillarCharge / this.runeTrialPillarMaxCharge;

                    // Pulsing glow
                    const pulseAlpha = 0.3 + Math.sin(Date.now() / 200) * 0.2;
                    const gradient = ctx.createRadialGradient(x, y - 20, 0, x, y - 20, 50 * chargePercent);
                    gradient.addColorStop(0, `rgba(59, 130, 246, ${pulseAlpha})`);
                    gradient.addColorStop(1, 'rgba(59, 130, 246, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y - 20, 50 * chargePercent, 0, Math.PI * 2);
                    ctx.fill();

                    // Floating particles
                    if (Math.random() < 0.3) {
                        this.visualEffects.push({
                            type: 'sparkle',
                            x: x + (Math.random() - 0.5) * 30,
                            y: y + 10,
                            vy: -1,
                            vx: (Math.random() - 0.5) * 0.5,
                            color: 'rgba(59, 130, 246, 0.8)',
                            size: 4,
                            life: 40
                        });
                    }
                }

                // Draw "Activate" text above pillar
                if (this.runeTrialPillarCharging) {
                    ctx.font = 'bold 14px Orbitron';
                    ctx.fillStyle = '#3b82f6';
                    ctx.textAlign = 'center';
                    ctx.fillText('‚ö° PILLAR ‚ö°', x, y - 55);
                }
            }
			drawRuneTrialPillar(ctx) {
                if (!this.runeTrialPillar || this.currentDungeon !== 'runetrial') return;

                // Initialize visual effects array if it doesn't exist
                if (!this.visualEffects) this.visualEffects = [];

                const pillar = this.runeTrialPillar;
                const pos = ISO.toScreen(pillar.gridX, pillar.gridY);
                const x = pos.x + this.offsetX;
                const y = pos.y + this.offsetY;

                const chargePercent = this.runeTrialPillarCharging ?
                    this.runeTrialPillarCharge / this.runeTrialPillarMaxCharge : 1;

                // Draw base platform (isometric diamond)
                ctx.fillStyle = '#1e293b';
                ctx.strokeStyle = '#334155';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y - 5);
                ctx.lineTo(x + 20, y + 5);
                ctx.lineTo(x, y + 15);
                ctx.lineTo(x - 20, y + 5);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Draw pillar shaft (isometric style)
                const pillarHeight = 50;
                ctx.fillStyle = '#475569';
                ctx.beginPath();
                ctx.moveTo(x - 8, y - 5);
                ctx.lineTo(x + 8, y - 5);
                ctx.lineTo(x + 8, y - pillarHeight);
                ctx.lineTo(x - 8, y - pillarHeight);
                ctx.closePath();
                ctx.fill();

                // Right side shading
                ctx.fillStyle = '#334155';
                ctx.beginPath();
                ctx.moveTo(x + 8, y - 5);
                ctx.lineTo(x + 12, y - 2);
                ctx.lineTo(x + 12, y - pillarHeight + 3);
                ctx.lineTo(x + 8, y - pillarHeight);
                ctx.closePath();
                ctx.fill();

                // Glowing crystal on top
                const crystalPulse = 0.8 + Math.sin(Date.now() / 300) * 0.2;
                const crystalGlow = ctx.createRadialGradient(x, y - pillarHeight - 10, 0, x, y - pillarHeight - 10, 25);
                crystalGlow.addColorStop(0, `rgba(59, 130, 246, ${crystalPulse * 0.8})`);
                crystalGlow.addColorStop(0.5, `rgba(59, 130, 246, ${crystalPulse * 0.4})`);
                crystalGlow.addColorStop(1, 'rgba(59, 130, 246, 0)');
                ctx.fillStyle = crystalGlow;
                ctx.beginPath();
                ctx.arc(x, y - pillarHeight - 10, 25, 0, Math.PI * 2);
                ctx.fill();

                // Crystal itself (diamond shape)
                ctx.fillStyle = `rgba(59, 130, 246, ${0.6 + crystalPulse * 0.4})`;
                ctx.strokeStyle = '#60a5fa';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y - pillarHeight - 20);
                ctx.lineTo(x + 10, y - pillarHeight - 10);
                ctx.lineTo(x, y - pillarHeight);
                ctx.lineTo(x - 10, y - pillarHeight - 10);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Charging effect - energy rings
                if (this.runeTrialPillarCharging && chargePercent > 0) {
                    for (let i = 0; i < 3; i++) {
                        const ringOffset = ((Date.now() / 800) + i * 0.33) % 1;
                        const ringY = y - 10 - (ringOffset * pillarHeight);
                        const ringAlpha = (1 - ringOffset) * 0.6;

                        ctx.strokeStyle = `rgba(59, 130, 246, ${ringAlpha})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.ellipse(x, ringY, 15, 8, 0, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    // Floating runes
                    if (Math.random() < 0.1) {
                        this.visualEffects.push({
                            type: 'sparkle',
                            x: x + (Math.random() - 0.5) * 40,
                            y: y + 5,
                            vy: -2,
                            vx: (Math.random() - 0.5) * 0.3,
                            color: 'rgba(59, 130, 246, 0.9)',
                            size: 5,
                            life: 50
                        });
                    }
                }

                // Charge percentage text above crystal
                if (this.runeTrialPillarCharging) {
                    const percent = Math.floor(chargePercent * 100);
                    ctx.font = 'bold 16px Orbitron';
                    ctx.fillStyle = '#60a5fa';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    ctx.textAlign = 'center';
                    ctx.strokeText(`${percent}%`, x, y - pillarHeight - 30);
                    ctx.fillText(`${percent}%`, x, y - pillarHeight - 30);
                }
            }
            drawVisualEffects(ctx) {
                if (!this.visualEffects || this.visualEffects.length === 0) return;

                this.visualEffects.forEach(effect => {
                    ctx.save();
                    const alpha = effect.life / 30;

                    switch(effect.type) {
                        case 'ring':
                            ctx.strokeStyle = effect.color.replace('0.6', alpha * 0.6);
                            ctx.lineWidth = effect.lineWidth;
                            ctx.beginPath();
                            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                            ctx.stroke();
                            break;
                        case 'line':
                            ctx.strokeStyle = effect.color.replace('0.8', alpha * 0.8);
                            ctx.lineWidth = effect.width;
                            ctx.beginPath();
                            ctx.moveTo(effect.x, effect.y);
                            ctx.lineTo(
                                effect.x + Math.cos(effect.angle) * effect.length,
                                effect.y + Math.sin(effect.angle) * effect.length
                            );
                            ctx.stroke();
                            break;
                        case 'slash':
                            const gradient = ctx.createLinearGradient(
                                effect.x - Math.cos(effect.angle) * effect.length / 2,
                                effect.y - Math.sin(effect.angle) * effect.length / 2,
                                effect.x + Math.cos(effect.angle) * effect.length / 2,
                                effect.y + Math.sin(effect.angle) * effect.length / 2
                            );
                            gradient.addColorStop(0, 'rgba(239, 68, 68, 0)');
                            gradient.addColorStop(0.5, effect.color.replace('0.9', alpha * 0.9));
                            gradient.addColorStop(1, 'rgba(239, 68, 68, 0)');
                            ctx.strokeStyle = gradient;
                            ctx.lineWidth = effect.width;
                            ctx.beginPath();
                            ctx.moveTo(
                                effect.x - Math.cos(effect.angle) * effect.length / 2,
                                effect.y - Math.sin(effect.angle) * effect.length / 2
                            );
                            ctx.lineTo(
                                effect.x + Math.cos(effect.angle) * effect.length / 2,
                                effect.y + Math.sin(effect.angle) * effect.length / 2
                            );
                            ctx.stroke();
                            break;
                        case 'projectile': {
                            // Draw trail (use effect color)
                            effect.trail.forEach((pos, i) => {
                                ctx.fillStyle = effect.color.replace(/[\d.]+\)$/, `${i * 0.1 * alpha})`);
                                ctx.beginPath();
                                ctx.arc(pos.x, pos.y, effect.size * (i / 5), 0, Math.PI * 2);
                                ctx.fill();
                            });
                            // Draw projectile with its specified color
                            ctx.fillStyle = effect.color;
                            ctx.shadowBlur = 8;
                            ctx.shadowColor = effect.color;
                            ctx.beginPath();
                            ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                            break;
                        }
                        case 'arrow-projectile': {
                            // Calculate arrow angle based on direction
                            const dx = effect.targetX - effect.x;
                            const dy = effect.targetY - effect.y;
                            effect.angle = Math.atan2(dy, dx);

                            // Draw arrow trail
                            effect.trail.forEach((pos, i) => {
                                ctx.fillStyle = effect.color.replace(/[\d.]+\)$/, `${i * 0.1 * alpha})`);
                                ctx.beginPath();
                                ctx.arc(pos.x, pos.y, 2, 0, Math.PI * 2);
                                ctx.fill();
                            });

                            // Draw arrow
                            ctx.save();
                            ctx.translate(effect.x, effect.y);
                            ctx.rotate(effect.angle);

                            // Arrow shaft
                            ctx.fillStyle = effect.color;
                            ctx.fillRect(-10, -1, 20, 2);

                            // Arrow head
                            ctx.beginPath();
                            ctx.moveTo(10, 0);
                            ctx.lineTo(5, -3);
                            ctx.lineTo(5, 3);
                            ctx.closePath();
                            ctx.fill();

                            // Fletching
                            ctx.fillStyle = 'rgba(220, 38, 38, 0.8)';
                            ctx.beginPath();
                            ctx.moveTo(-10, 0);
                            ctx.lineTo(-13, -3);
                            ctx.lineTo(-13, 3);
                            ctx.closePath();
                            ctx.fill();

                            ctx.restore();
                            break;
                        }
                        case 'sparkle':
                        case 'spark':
                            ctx.fillStyle = effect.color.replace('0.8', alpha * 0.8);
                            ctx.beginPath();
                            ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
                            ctx.fill();
                            break;
                        case 'glow':
                            if (isFinite(effect.radius) && effect.radius > 0) {
                                const glowGradient = ctx.createRadialGradient(effect.x, effect.y, 0, effect.x, effect.y, effect.radius);
                                glowGradient.addColorStop(0, effect.color.replace('0.3', alpha * 0.3));
                                glowGradient.addColorStop(1, 'rgba(16, 185, 129, 0)');
                                ctx.fillStyle = glowGradient;
                                ctx.beginPath();
                                ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            break;
							case 'dome':
                        case 'aura':
                        case 'void-portal':
                        case 'freeze':
                        case 'shadow-veil':
                        case 'poison-cloud':
                            if (isFinite(effect.radius) && effect.radius > 0) {
                                const auraGradient = ctx.createRadialGradient(effect.x, effect.y, 0, effect.x, effect.y, effect.radius);
                                auraGradient.addColorStop(0, effect.color);
                                auraGradient.addColorStop(1, effect.color.replace(/[\d.]+\)/, '0)'));
                                ctx.fillStyle = auraGradient;
                                ctx.beginPath();
                                ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            break;
                        case 'rotating-ring':
                            ctx.save();
                            ctx.translate(effect.x, effect.y);
                            ctx.rotate(effect.angle * Math.PI / 180);
                            ctx.strokeStyle = effect.color.replace(/[\d.]+\)/, alpha * 0.6 + ')');
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(0, 0, effect.radius, 0, Math.PI * 2);
                            ctx.stroke();
                            // Add some gaps for visual interest
                            ctx.strokeStyle = 'rgba(0,0,0,1)';
                            ctx.lineWidth = 5;
                            for (let i = 0; i < 4; i++) {
                                ctx.beginPath();
                                ctx.arc(0, 0, effect.radius, i * Math.PI/2 - 0.1, i * Math.PI/2 + 0.1);
                                ctx.stroke();
                            }
                            ctx.restore();
                            break;
                        case 'shockwave':
                            ctx.strokeStyle = effect.color.replace(/[\d.]+\)/, alpha * 0.8 + ')');
                            ctx.lineWidth = effect.lineWidth * (1 - effect.radius / effect.maxRadius);
                            ctx.beginPath();
                            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                            ctx.stroke();
                            break;
                        case 'spike':
                            ctx.fillStyle = effect.color.replace(/[\d.]+\)/, alpha * 0.9 + ')');
                            ctx.beginPath();
                            ctx.moveTo(effect.x - 5, effect.y);
                            ctx.lineTo(effect.x, effect.y - effect.height);
                            ctx.lineTo(effect.x + 5, effect.y);
                            ctx.closePath();
                            ctx.fill();
                            break;
                        case 'holy-pillar':
                            // Divine light pillar from above
                            const pillarGradient = ctx.createLinearGradient(
                                effect.x,
                                effect.y,
                                effect.x,
                                effect.targetY
                            );
                            pillarGradient.addColorStop(0, effect.color);
                            pillarGradient.addColorStop(1, effect.color.replace(/[\d.]+\)/, '0)'));

                            ctx.fillStyle = pillarGradient;
                            ctx.fillRect(
                                effect.x - effect.width / 2,
                                effect.y,
                                effect.width,
                                effect.height
                            );

                            // Bright core
                            ctx.fillStyle = 'rgba(254, 243, 199, 0.8)';
                            ctx.fillRect(
                                effect.x - 4,
                                effect.y,
                                8,
                                effect.height
                            );
                            break;
                        case 'blood-drop':
                        case 'ice-shard':
                        case 'poison-bubble':
                            ctx.fillStyle = effect.color.replace(/[\d.]+\)/, alpha * 0.8 + ')');
                            ctx.beginPath();
                            ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
                            ctx.fill();
                            break;
                        case 'tendril':
                        case 'cripple-slash':
                            const tendrilGradient = ctx.createLinearGradient(
                                effect.x,
                                effect.y,
                                effect.x + Math.cos(effect.angle) * effect.length,
                                effect.y + Math.sin(effect.angle) * effect.length
                            );
                            tendrilGradient.addColorStop(0, effect.color);
                            tendrilGradient.addColorStop(1, effect.color.replace(/[\d.]+\)/, '0)'));
                            ctx.strokeStyle = tendrilGradient;
                            ctx.lineWidth = effect.width || 3;
                            ctx.beginPath();
                            ctx.moveTo(effect.x, effect.y);
                            ctx.lineTo(
                                effect.x + Math.cos(effect.angle) * effect.length,
                                effect.y + Math.sin(effect.angle) * effect.length
                            );
                            ctx.stroke();
                            break;
                        case 'time-ripple':
                            ctx.strokeStyle = effect.color.replace(/[\d.]+\)/, alpha * 0.5 + ')');
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(effect.x, effect.y, effect.radius, effect.angle, effect.angle + Math.PI/3);
                            ctx.stroke();
                            break;
                        case 'afterimage':
                            ctx.fillStyle = effect.color.replace(/[\d.]+\)/, effect.alpha + ')');
                            ctx.fillRect(effect.x - 10, effect.y - 15, 20, 30);
                            break;
                        case 'dagger-stab':
    // Animate the stab
    const stabProgress = 1 - (effect.life / 10);

    if (stabProgress < 0.5) {
        // Stab forward
        effect.currentX = effect.startX + (effect.endX - effect.startX) * (stabProgress * 2);
    } else {
        // Pull back
        effect.currentX = effect.endX - (effect.endX - effect.startX) * ((stabProgress - 0.5) * 2);
    }

    const stabEndX = effect.x + effect.currentX;
    const stabEndY = effect.y + effect.offsetY;

    // Draw dagger line
    ctx.strokeStyle = effect.color;
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(effect.x, effect.y);
    ctx.lineTo(stabEndX, stabEndY);
    ctx.stroke();

    // Draw dagger tip (triangle)
    ctx.fillStyle = effect.color;
    ctx.beginPath();
    ctx.moveTo(stabEndX, stabEndY);
    ctx.lineTo(stabEndX + 4, stabEndY - 2);
    ctx.lineTo(stabEndX + 4, stabEndY + 2);
    ctx.closePath();
    ctx.fill();
    break;
case 'arm-swing':
                            // Animate the arm swing
                            const progress = 1 - (effect.life / (effect.startAngle === -45 ? 12 : 15));
                            effect.currentAngle = effect.startAngle + (effect.endAngle - effect.startAngle) * progress;

                            const radians = (effect.currentAngle * Math.PI) / 180;
                            const armEndX = effect.x + Math.cos(radians) * effect.armLength;
                            const armEndY = effect.y - 10 + Math.sin(radians) * effect.armLength;

                            // Draw arm
                            ctx.strokeStyle = effect.color;
                            ctx.lineWidth = 3;
                            ctx.lineCap = 'round';
                            ctx.beginPath();
                            ctx.moveTo(effect.x, effect.y - 10);
                            ctx.lineTo(armEndX, armEndY);
                            ctx.stroke();

                            // Draw weapon at end
                            ctx.fillStyle = effect.color;
                            ctx.fillRect(armEndX - 2, armEndY - 2, 4, 4);
                            break;
                        case 'debuff':
                            ctx.strokeStyle = effect.color.replace(/[\d.]+\)/, alpha * 0.5 + ')');
                            ctx.lineWidth = 2;
                            ctx.setLineDash([5, 5]);
                            ctx.beginPath();
                            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            break;
                        case 'ice-orbit':
                            ctx.fillStyle = effect.color.replace(/[\d.]+\)/, alpha * 0.9 + ')');
                            const orbitX = effect.x + Math.cos(effect.angle) * effect.radius;
                            const orbitY = effect.y + Math.sin(effect.angle) * effect.radius;
                            ctx.beginPath();
                            ctx.arc(orbitX, orbitY, effect.size, 0, Math.PI * 2);
                            ctx.fill();
                            break;
                        case 'lightning-bolt':
                            ctx.strokeStyle = effect.color.replace(/[\d.]+\)/, alpha * 0.9 + ')');
                            ctx.lineWidth = effect.width;
                            ctx.shadowBlur = 10;
                            ctx.shadowColor = effect.color;
                            ctx.beginPath();
                            ctx.moveTo(effect.x, effect.y);
                            // Jagged lightning path
                            const dx = effect.targetX - effect.x;
                            const dy = effect.targetY - effect.y;
                            const segments = 5;
                            for (let i = 1; i < segments; i++) {
                                const t = i / segments;
                                const jitter = (Math.random() - 0.5) * 20;
                                ctx.lineTo(
                                    effect.x + dx * t + jitter,
                                    effect.y + dy * t + jitter
                                );
                            }
                            ctx.lineTo(effect.targetX, effect.targetY);
                            ctx.stroke();
                            ctx.shadowBlur = 0;
                            break;
                    }

                    ctx.restore();
                });



            }



            battleTick() {
    // REMOVED OLD CHECK - this was blocking Rune Trial pillar phase!
    // The old code had: if (this.paused || !this.inBattle) return;
    // This prevented pillar charging from working!

    if (this.paused) return; // Only check paused, not inBattle

    const aliveParty = this.party.filter(m => m.isAlive);
    const aliveEnemies = this.enemies.filter(e => e.isAlive);

    // Handle Rune Trial pillar charging phase
    if (this.currentDungeon === 'runetrial' && this.runeTrialPillarCharging) {
        // Check if any party member is near pillar
        const pillar = this.runeTrialPillar;
        let anyoneNearPillar = false;

        this.party.forEach(member => {
            if (!member.isAlive || !member.sprite) return;

           const dx = pillar.gridX - member.sprite.gridX;
                    const dy = pillar.gridY - member.sprite.gridY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // Automatically move all party members towards pillar
            if (distance > 2) {
                // Move towards pillar
                const moveSpeed = 0.08;
                member.sprite.gridX += (dx / distance) * moveSpeed;
                member.sprite.gridY += (dy / distance) * moveSpeed;
            } else {
                // Close enough to charge
                anyoneNearPillar = true;
            }
        });

        // Only charge if someone is near
        if (anyoneNearPillar) {
            this.runeTrialPillarCharge++;

            // Charging visual effect
            if (this.runeTrialPillarCharge % 10 === 0) {
                const pos = ISO.toScreen(pillar.gridX, pillar.gridY);
                this.visualEffects.push({
                    type: 'ring',
                    x: pos.x + this.offsetX,
                    y: pos.y + this.offsetY,
                    radius: 20,
                    maxRadius: 50,
                    color: 'rgba(59, 130, 246, 0.6)',
                    lineWidth: 3,
                    life: 20
                });
            }
        }

        // Update pillar UI
        this.updateRuneTrialPillarUI();

        // When pillar fully charged, spawn boss
        if (this.runeTrialPillarCharge >= this.runeTrialPillarMaxCharge) {
            this.runeTrialPillarCharging = false;
            this.runeTrialPillar = null; // Remove pillar

            // Spawn the boss
            if (this.runeTrialBoss) {
                this.enemies.push(this.runeTrialBoss);
                this.addLog(`${this.runeTrialBoss.name} awakens!`, 'damage');

                // Boss spawn effect
                const pos = ISO.toScreen(this.runeTrialBoss.sprite.gridX, this.runeTrialBoss.sprite.gridY);
                for (let i = 0; i < 24; i++) {
                    const angle = (Math.PI * 2 * i) / 24;
                    this.visualEffects.push({
                        type: 'spark',
                        x: pos.x + this.offsetX,
                        y: pos.y + this.offsetY,
                        vx: Math.cos(angle) * 10,
                        vy: Math.sin(angle) * 10,
                        color: 'rgba(59, 130, 246, 0.9)',
                        size: 6,
                        life: 40
                    });
                }

                // START THE BATTLE!
                this.inBattle = true;
                this.battleTimer = 0;
                this.battleStartTime = Date.now();

                // Also initialize floor stats start time if not set
                if (!this.floorStats.startTime) {
                    this.floorStats.startTime = Date.now();
                }
            }

            // Hide pillar UI
            const pillarUI = document.getElementById('rune-trial-pillar-ui');
            if (pillarUI) pillarUI.remove();
        }

        // DON'T return here - we need to process bomber spawning!
    }

    // Handle Rune Trial bomber spawning - ONLY while boss is alive
    if (this.currentDungeon === 'runetrial') {
        const boss = this.enemies.find(e => e.isRuneTrialBoss && e.isAlive);

        // Only spawn bombers if boss is alive OR pillar is still charging
        if (boss || this.runeTrialPillarCharging) {
            // Check for enrage at 25% boss HP (only when boss exists)
            if (boss && !this.runeTrialBossEnraged && boss.hp <= boss.maxHp * 0.25) {
                this.runeTrialBossEnraged = true;
                this.runeTrialBomberSpawnRate = 60; // Double spawn rate (1 per second)
                this.showBossEnrageEffect(boss);
                this.addLog(`${boss.name} ENRAGES! Bombers spawn 2x faster!`, 'damage');
            }

            // Only spawn bombers after pillar is 10% charged
            const pillarPercent = this.runeTrialPillarCharging ?
                (this.runeTrialPillarCharge / this.runeTrialPillarMaxCharge) : 1;

            if (pillarPercent >= 0.1) {
                // Spawn bombers
                this.runeTrialBomberSpawnTimer++;
                if (this.runeTrialBomberSpawnTimer >= this.runeTrialBomberSpawnRate) {
                    this.runeTrialBomberSpawnTimer = 0;
                    this.spawnRuneTrialBomber();
                }
            }
        }

        // Update all bombers
        this.enemies.filter(e => e.isBomber && e.isAlive).forEach(bomber => {
            this.updateBomber(bomber);
        });
    }

    if (aliveParty.length === 0) {
        // In endless dungeon, party defeat ends the run
        if (this.currentDungeon === 'endlessblessings') {
            this.showEndlessBlessingsResults();
        }
        this.endBattle(false);
        return;
    }

    // Don't end battle if no enemies during Rune Trial (pillar charging or bombers only)
    if (aliveEnemies.length === 0) {
        // Special check for Divine Arena - never end, just keep spawning
        if (this.currentDungeon === 'endlessblessings') {
            // Don't end battle - enemies will keep spawning
            return;
        }
        // Special check for Rune Trial - don't end until boss is dead
        else if (this.currentDungeon === 'runetrial') {
            // Only end if pillar is done charging AND boss was spawned and died
            if (!this.runeTrialPillarCharging && this.runeTrialBoss && !this.runeTrialBoss.isAlive) {
                this.endBattle(true);
                return;
            }
            // Otherwise, continue - more bombers will spawn or boss hasn't spawned yet
        } else {
            this.endBattle(true);
            return;
        }
    }

                // Update all units independently based on their attack speed using real delta time

                [...this.party, ...this.enemies].forEach(unit => {
    if (!unit.isAlive || !unit.sprite) return;

                    // Initialize attack timer if needed
                    if (!unit.attackTimer) unit.attackTimer = 0;

                    // Increment attack timer based on attack speed (attacks per second)
                    const attackSpeed = unit.getTotalAttackSpeed ? unit.getTotalAttackSpeed() : unit.attackSpeed;
                    unit.attackTimer += attackSpeed * this.deltaTime * 100;

// Update Tank taunt buff
if (unit.tauntTimer && unit.tauntTimer > 0) {
    unit.tauntTimer -= this.deltaTime * 60;
    if (unit.tauntTimer <= 0) {
        unit.tauntTimer = 0;
        unit.tauntActive = false;
    }
}

// Update Berserker's Pact buff
if (unit.berserkerTimer && unit.berserkerTimer > 0) {
    unit.berserkerTimer -= this.deltaTime * 60;
    if (unit.berserkerTimer <= 0) {
        unit.berserkerTimer = 0;
        unit.berserkerActive = false;
    }
}

// Update Warden's Aegis invulnerability
if (unit.invulnerableTimer && unit.invulnerableTimer > 0) {
    unit.invulnerableTimer -= this.deltaTime * 60;
    if (unit.invulnerableTimer <= 0) {
        unit.invulnerableTimer = 0;
        unit.invulnerable = false;
    }
}

// Update defense debuff (Assassin's Mark)
if (unit.defenseDebuffTimer && unit.defenseDebuffTimer > 0) {
    unit.defenseDebuffTimer -= this.deltaTime * 60;
    if (unit.defenseDebuffTimer <= 0) {
        unit.defenseDebuffTimer = 0;
        unit.defenseDebuff = 0;
    }
}

// Update attack debuff (Earthshaker's Resolve)
if (unit.attackDebuffTimer && unit.attackDebuffTimer > 0) {
    unit.attackDebuffTimer -= this.deltaTime * 60;
    if (unit.attackDebuffTimer <= 0) {
        unit.attackDebuffTimer = 0;
        unit.attackDebuff = 0;
    }
}

// Update Arrow Storm (Rapid Quiver)
if (unit.arrowStormActive && unit.arrowStormArrows > 0) {
    unit.arrowStormTimer = (unit.arrowStormTimer || 0) + 1;
    if (unit.arrowStormTimer >= unit.arrowStormInterval) {
        unit.arrowStormTimer = 0;
        unit.arrowStormArrows--;

        // Fire an arrow at a random enemy
        const aliveEnemies = this.enemies.filter(e => e.isAlive);
        if (aliveEnemies.length > 0) {
            const target = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
            const dealt = target.takeDamage(unit.arrowStormDamage);
            this.createFloatingText(target.sprite, `-${dealt}`, 'damage-text');
            this.floorStats.damageDealt += dealt;

            // Track character-specific damage for all dungeons
            if (this.characterStats && this.characterStats[unit.name]) {
                this.characterStats[unit.name].damageDealt += dealt;
            }

            this.createArrowEffect(unit.sprite, target.sprite);
        }

        if (unit.arrowStormArrows === 0) {
            unit.arrowStormActive = false;
        }
    }
}

// Update Marked for Death
if (unit.markedTimer && unit.markedTimer > 0) {
    unit.markedTimer -= this.deltaTime * 60;
    if (unit.markedTimer <= 0) {
        unit.markedTimer = 0;
        unit.markedBy = null;
        unit.markedDamageBonus = 0;
        unit.markedLifesteal = 0;
    }
}

// Update Sacred Barrier defense buff
if (unit.sacredBarrierTimer && unit.sacredBarrierTimer > 0) {
    unit.sacredBarrierTimer -= this.deltaTime * 60;
    if (unit.sacredBarrierTimer <= 0) {
        unit.sacredBarrierTimer = 0;
        unit.sacredBarrierDefense = 0;
    }
}

// Update Righteous Fury attack speed buff
if (unit.righteousFuryTimer && unit.righteousFuryTimer > 0) {
    unit.righteousFuryTimer -= this.deltaTime * 60;
    if (unit.righteousFuryTimer <= 0) {
        unit.righteousFuryTimer = 0;
        unit.righteousFuryAS = 0;
    }
}

// Update Shield - check if shield has expired using real time
if (unit.shieldAmount > 0 && unit.shieldEndTime) {
    const now = Date.now();
    if (now >= unit.shieldEndTime) {
        unit.shieldAmount = 0;
        unit.shieldEndTime = null;
    }
}

// Reduce cooldowns using real time (like regen) - only when NOT paused
if (!unit.lastCooldownTime) unit.lastCooldownTime = Date.now();
if (unit.cooldown > 0 && !this.paused) {
    const now = Date.now();
    const elapsed = (now - unit.lastCooldownTime) / 1000; // Convert to seconds
    unit.lastCooldownTime = now;

    const cdr = unit.getTotalCDR ? unit.getTotalCDR() : 0;
    const cooldownMultiplier = 1 + (cdr / 100); // Faster reduction with CDR
    unit.cooldown -= elapsed * cooldownMultiplier;
    if (unit.cooldown < 0) unit.cooldown = 0;
} else if (this.paused) {
    // Reset cooldown timer when paused to prevent incorrect elapsed time when unpausing
    unit.lastCooldownTime = Date.now();
}

// HP/Mana regeneration - every 3 seconds (real time)
// Simple flat regen: stat value √∑ 2 = regen per 3 seconds
if (!this.lastRegenTime) this.lastRegenTime = Date.now();
const now = Date.now();
if (now - this.lastRegenTime >= 3000) {
    this.lastRegenTime = now;
    this.party.forEach(member => {
        if (member.isAlive) {
            const rawHpRegen = member.getTotalHpRegen();
            const rawManaRegen = member.getTotalManaRegen();

            // Simple formula: regen stat √∑ 2 = actual regen per 3 seconds
            const hpRegenAmount = Math.floor(rawHpRegen / 2);
            const manaRegenAmount = Math.floor(rawManaRegen / 2);

            const totalMaxMana = member.getTotalMaxMana();

            if (hpRegenAmount > 0) {
                member.heal(hpRegenAmount);

                // Track HP regen in stats
                if (this.characterStats && this.characterStats[member.name]) {
                    this.characterStats[member.name].healingDone += hpRegenAmount;
                    console.log(`üåø ${member.name} HP regen tracked: +${hpRegenAmount} (Total healing: ${this.characterStats[member.name].healingDone})`);
                }
            }
            if (manaRegenAmount > 0 && member.mana < totalMaxMana) {
                member.mana = Math.min(totalMaxMana, member.mana + manaRegenAmount);
            }
        }
    });
}

                    // Check if ready to attack (100 = ready)
                    if (unit.attackTimer >= 100) {
                        unit.attackTimer = 0;

                        // Determine if this is a party member or enemy
                        const isPartyMember = this.party.includes(unit);

                        if (isPartyMember) {
                            this.performPartyAttack(unit, aliveEnemies);
                        } else {
                            this.performEnemyAttack(unit, aliveParty);
                        }
                    }
});

                // Update ability indicators every tick (lightweight)
                // Only log if at least one keystone is on cooldown
                const keystonesOnCD = this.party.filter(m => m.keystoneCooldown > 0).length;
                if (keystonesOnCD > 0) {
                    const cdDetails = this.party.filter(m => m.keystoneCooldown > 0).map(m => `${m.name}:${m.keystoneCooldown.toFixed(1)}s`).join(', ');
                    console.log(`[TICK] Calling updateAbilityIndicators (inBattle=${this.inBattle}, keystones on CD: ${cdDetails})`);
                }
                this.updateAbilityIndicators();

// Only update UI every 3 ticks for performance
if (!this._tickCounter) this._tickCounter = 0;
this._tickCounter++;
if (this._tickCounter % 5 === 0) {
    this.updateUI();
}
            }

performPartyAttack(member, aliveEnemies) {
    if (aliveEnemies.length === 0 || !member.sprite) return;

    // Check battle timing for non-tank melee
    const battleTime = (Date.now() - this.battleStartTime) / 1000; // Time in seconds
    const tank = this.party.find(m => m.className === 'Tank' && m.isAlive);
    const tankHasEngaged = tank && tank.hasEngaged;

    // Rogue now attacks immediately - tank has taunt to pull aggro

    // Filter out enemies with null sprites first
    let validEnemies = aliveEnemies.filter(e => e.sprite && e.sprite.gridX !== undefined);
    if (validEnemies.length === 0) return;

    let target = null;

    // PRIORITY TARGETING FOR RUNE TRIAL BOMBERS
    // Mage ALWAYS prioritizes bombers first (absolute priority), then boss
    if (this.currentDungeon === 'runetrial' && member.className === 'Mage') {
        const bombers = validEnemies.filter(e => e.isBomber);
        if (bombers.length > 0) {
            // ONLY attack bombers, ignore everything else
            target = bombers.sort((a, b) => {
                const distA = Math.sqrt(Math.pow(a.sprite.gridX - member.sprite.gridX, 2) + Math.pow(a.sprite.gridY - member.sprite.gridY, 2));
                const distB = Math.sqrt(Math.pow(b.sprite.gridX - member.sprite.gridX, 2) + Math.pow(b.sprite.gridY - member.sprite.gridY, 2));
                return distA - distB;
            })[0];
        }
    }

    // Healer targets bombers if no one needs healing urgently
    if (this.currentDungeon === 'runetrial' && member.className === 'Healer' && !target) {
        const aliveParty = this.party.filter(m => m.isAlive);
        const criticalAlly = aliveParty.find(m => m.hp < m.getTotalMaxHp() * 0.5);

        // Only target bombers if no one is below 50% HP
        if (!criticalAlly) {
            const bombers = validEnemies.filter(e => e.isBomber);
            if (bombers.length > 0) {
                target = bombers.sort((a, b) => {
                    const distA = Math.sqrt(Math.pow(a.sprite.gridX - member.sprite.gridX, 2) + Math.pow(a.sprite.gridY - member.sprite.gridY, 2));
                    const distB = Math.sqrt(Math.pow(b.sprite.gridX - member.sprite.gridX, 2) + Math.pow(b.sprite.gridY - member.sprite.gridY, 2));
                    return distA - distB;
                })[0];
            }
        }
    }

    // Default targeting if no special target was set
    if (!target) {
        // Tank and Rogue ignore bombers - only target boss in Rune Trial
        if (this.currentDungeon === 'runetrial' && (member.className === 'Tank' || member.className === 'Rogue')) {
            const nonBombers = validEnemies.filter(e => !e.isBomber);
            if (nonBombers.length > 0) {
                target = member.className === 'Tank' ?
                    nonBombers.reduce((closest, enemy) =>
                        enemy.sprite.gridX < closest.sprite.gridX ? enemy : closest
                    ) : nonBombers[0];
            } else {
                // Fallback if only bombers exist
                target = validEnemies[0];
            }
        } else {
            target = member.className === 'Tank' ?
                validEnemies.reduce((closest, enemy) =>
                    enemy.sprite.gridX < closest.sprite.gridX ? enemy : closest
                ) : validEnemies[0];
        }
    }

                if (!target || !target.sprite) return;

                let damage = 0;
                let performedAction = false;

                // Smart ability usage based on class and situation
                if (member.className === 'Healer') {
                    const aliveParty = this.party.filter(m => m.isAlive);
                    const injured = aliveParty.filter(m => m.hp < m.getTotalMaxHp())
                        .sort((a, b) => a.hp/a.getTotalMaxHp() - b.hp/b.getTotalMaxHp())[0]; // Prioritize lowest HP%

                    // Heal if anyone is at 70% HP or less (using total max HP including all bonuses)
                    if (injured && injured.hp <= injured.getTotalMaxHp() * 0.7 && member.mana >= member.skillCost && member.cooldown === 0) {
                        const healAmount = member.useSkill(injured);
                        if (healAmount > 0) {
                            // Move briefly towards injured ally
                            const originalX = member.sprite.gridX;
                            const originalY = member.sprite.gridY;
                            member.sprite.moveTo(injured.sprite.gridX - 0.5, injured.sprite.gridY);

                            const healed = injured.heal(healAmount);
                            this.createFloatingText(injured.sprite, `+${healed}`, 'heal-text');
                            this.createHealEffect(injured.sprite);

                            // Track character-specific healing for all dungeons
                            if (this.characterStats && this.characterStats[member.name]) {
                                this.characterStats[member.name].healingDone += healed;
                            }

                            this.addLog(`${member.name} heals ${injured.name} for ${healed}`, 'heal');
                            performedAction = true;

                            // Return to position
                            setTimeout(() => {
                                member.sprite.moveTo(originalX, originalY);
                            }, 600);
                        }
                    }
                } else if (member.className === 'Mage' && member.mana >= member.skillCost && member.cooldown === 0) {
                    // Use Fireball if 2+ enemies or if single enemy has high HP
                    const shouldAOE = aliveEnemies.length >= 2 ||
                                     (aliveEnemies.length === 1 && aliveEnemies[0].hp > aliveEnemies[0].maxHp * 0.5);

                    if (shouldAOE) {
                        const aoeDamage = member.useSkill(aliveEnemies);
                        if (aoeDamage > 0) {
                            // Create fireball projectile
                            this.createFireballEffect(member.sprite, aliveEnemies);

                            aliveEnemies.forEach(enemy => {
                                const dealt = enemy.takeDamage(aoeDamage);

                                if (dealt !== 'DODGE') {
                                    // Check for critical hit on each enemy
                                    const isCrit = Math.random() * 100 < member.getTotalCritChance();
                                    let finalDamage = dealt;

                                    if (isCrit) {
                                        const critMultiplier = member.getTotalCritDamage() / 100;
                                        finalDamage = Math.floor(dealt * critMultiplier);
                                        enemy.hp = Math.max(0, enemy.hp - (finalDamage - dealt));
                                        if (enemy.hp === 0) enemy.isAlive = false;
                                        this.createFloatingText(enemy.sprite, `-${finalDamage} CRIT!`, 'damage-text');
                                    } else {
                                        this.createFloatingText(enemy.sprite, `-${dealt}`, 'damage-text');
                                    }

                                    // Track damage
                                    this.floorStats.damageDealt += finalDamage;

                                    // Track character-specific damage for all dungeons
                                    if (this.characterStats && this.characterStats[member.name]) {
                                        this.characterStats[member.name].damageDealt += finalDamage;
                                    }
                                } else {
                                    this.createFloatingText(enemy.sprite, 'DODGE', 'heal-text');
                                }
                            });
                            member.sprite.attacking = true;
                            this.addLog(`${member.name} casts Fireball!`, 'damage');
                            performedAction = true;
                        }
                    }
                } else if (member.className === 'Tank' && member.mana >= member.skillCost && member.cooldown === 0) {
                    // Use Taunt if not currently taunting and enemies aren't already targeting tank
                    const enemiesTargetingOthers = aliveEnemies.filter(e => {
                        // Check if enemy would target someone else
                        const otherTargets = this.party.filter(m => m.isAlive && m.className !== 'Tank');
                        return otherTargets.length > 0 && Math.random() > 0.85; // 15% chance they'd target others
                    });

                    if (!member.tauntActive && (aliveEnemies.length >= 2 || enemiesTargetingOthers.length > 0)) {
                        damage = member.useSkill(target);
                        if (damage >= 0) { // Taunt returns 0 but still succeeds
                            performedAction = true;
                            this.createTauntEffect(member.sprite);
                            this.addLog(`${member.name} taunts all enemies!`, 'damage');
                        }
                    }
                } else if (member.className === 'Rogue' && member.mana >= member.skillCost && member.cooldown === 0) {
                    // NEVER use Double Strike on bombers (they have 1 HP, waste of mana)
                    if (!target.isBomber) {
                        // Use Double Strike on high HP targets or when it would kill
                        const potentialDamage = member.getTotalAttack() * 1.5;
                        const wouldKill = target.hp <= potentialDamage;
                        const highValueTarget = target.isBoss || target.hp > 100;

                        if (wouldKill || highValueTarget) {
                            damage = member.useSkill(target);
                            if (damage > 0) {
                                performedAction = true;
                                this.createDoubleStrikeEffect(target.sprite);
                            }
                        }
                    }
                } else if (member.className === 'Archer' && member.mana >= member.skillCost && member.cooldown === 0) {
                    // Use Multi-Shot when there are 2+ enemies (AOE ability)
                    if (aliveEnemies.length >= 2) {
                        const multiShotDamage = member.useSkill(aliveEnemies);
                        if (multiShotDamage > 0) {
                            // Create multi-shot arrow effect
                            this.createMultiShotEffect(member.sprite, aliveEnemies);

                            // Damage each enemy hit (up to 3)
                            const targets = aliveEnemies.slice(0, 3);
                            targets.forEach(enemy => {
                                const dealt = enemy.takeDamage(multiShotDamage / 3); // Divide by 3 since total damage is 3x

                                if (dealt !== 'DODGE') {
                                    // Check for critical hit
                                    const isCrit = Math.random() * 100 < member.getTotalCritChance();
                                    let finalDamage = dealt;

                                    if (isCrit) {
                                        const critMultiplier = member.getTotalCritDamage() / 100;
                                        finalDamage = Math.floor(dealt * critMultiplier);
                                        enemy.hp = Math.max(0, enemy.hp - (finalDamage - dealt));
                                        if (enemy.hp === 0) enemy.isAlive = false;
                                        this.createFloatingText(enemy.sprite, `-${finalDamage} CRIT!`, 'damage-text');
                                    } else {
                                        this.createFloatingText(enemy.sprite, `-${dealt}`, 'damage-text');
                                    }

                                    // Track damage
                                    this.floorStats.damageDealt += finalDamage;

                                    // Track character-specific damage for all dungeons
                                    if (this.characterStats && this.characterStats[member.name]) {
                                        this.characterStats[member.name].damageDealt += finalDamage;
                                    }
                                } else {
                                    this.createFloatingText(enemy.sprite, 'DODGE', 'heal-text');
                                }
                            });

                            member.sprite.attacking = true;
                            this.addLog(`${member.name} fires Multi-Shot at ${targets.length} enemies!`, 'damage');
                            performedAction = true;
                        }
                    }
                } else if (member.className === 'Paladin' && member.mana >= member.skillCost && member.cooldown === 0) {
                    // Use Divine Shield when party is taking damage (any ally below 60% HP)
                    const injuredParty = this.party.filter(m => m.isAlive && m.hp < m.getTotalMaxHp() * 0.6);

                    if (injuredParty.length > 0) {
                        member.useSkill(member); // Divine Shield doesn't return damage
                        this.createDivineShieldEffect(member.sprite);
                        member.sprite.attacking = true;
                        this.addLog(`${member.name} casts Divine Shield! All allies gain shields!`, 'heal');
                        performedAction = true;
                    }
                }

                // Check for keystone ability usage
                // FIX: Use member.className.toLowerCase() instead of hardcoded party order
                const keystoneType = member.className.toLowerCase();
                const equippedKeystone = this.equippedKeystones[keystoneType];

                if (equippedKeystone && !performedAction) {
                    // Initialize keystone cooldown if needed
                    if (member.keystoneCooldown === undefined) member.keystoneCooldown = 0;
                    if (member.keystoneMaxCooldown === undefined) member.keystoneMaxCooldown = equippedKeystone.ability.cooldown;

                    // Check if keystone is off cooldown AND member has enough mana
                    const keystoneManaCost = equippedKeystone.ability.manaCost;
                    if (member.keystoneCooldown === 0 && member.mana >= keystoneManaCost) {
                        let shouldUseKeystone = false;

                        // Tank keystones
                        if (equippedKeystone.internalName === 'wardens-aegis') {
                            // Use if below 40% HP or facing boss
                            shouldUseKeystone = member.hp < member.getTotalMaxHp() * 0.4 || aliveEnemies.some(e => e.isBoss);
                        } else if (equippedKeystone.internalName === 'berserkers-pact') {
                            // Use if above 40% HP and (facing boss OR 2+ enemies)
                            shouldUseKeystone = member.hp > member.getTotalMaxHp() * 0.4 && (target.isBoss || aliveEnemies.length >= 2);
                        } else if (equippedKeystone.internalName === 'earthshakers-resolve') {
                            // Use on bosses OR when 2+ enemies
                            shouldUseKeystone = target.isBoss || aliveEnemies.length >= 2;
                        }

                        // Healer keystones
                        else if (equippedKeystone.internalName === 'arcanists-conduit') {
                            // Use if mage or healer below 40% mana
                            const lowManaAlly = this.party.find(m => m.isAlive &&
                                (m.className === 'Mage' || m.className === 'Healer') &&
                                m.mana < m.getTotalMaxMana() * 0.4);
                            shouldUseKeystone = lowManaAlly !== undefined;
                        } else if (equippedKeystone.internalName === 'martyrs-blessing') {
                            // Use if 2+ allies below 60% HP and healer above 50% HP
                            const lowHpAllies = this.party.filter(m => m.isAlive && m.hp < m.getTotalMaxHp() * 0.6);
                            shouldUseKeystone = lowHpAllies.length >= 2 && member.hp > member.getTotalMaxHp() * 0.5;
                        } else if (equippedKeystone.internalName === 'phoenix-heart') {
                            // Use if an ally is dead (only once per battle)
                            const deadAlly = this.party.find(m => !m.isAlive);
                            shouldUseKeystone = deadAlly !== undefined && !member.phoenixUsedThisBattle;
                        }

                        // Mage keystones
                        else if (equippedKeystone.internalName === 'winters-wrath') {
                            // Use on bosses OR when 2+ enemies
                            shouldUseKeystone = target.isBoss || aliveEnemies.length >= 2;
                        } else if (equippedKeystone.internalName === 'voidwalkers-gift') {
                            // Use against bosses or high defense enemies
                            const highDefEnemy = aliveEnemies.find(e => e.defense > 15 || e.isBoss);
                            shouldUseKeystone = highDefEnemy !== undefined;
                        } else if (equippedKeystone.internalName === 'timeweavers-paradox') {
                            // Use if 2+ allies have abilities on cooldown OR 2+ allies below 50% HP
                            const alliesOnCooldown = this.party.filter(m => m.isAlive && m.cooldown > 0);
                            const alliesLowHp = this.party.filter(m => m.isAlive && m.hp < m.getTotalMaxHp() * 0.5);
                            shouldUseKeystone = alliesOnCooldown.length >= 2 || alliesLowHp.length >= 2;
                        }

                        // Rogue keystones
                        else if (equippedKeystone.internalName === 'assassins-mark') {
                            // Use on bosses or high HP targets
                            shouldUseKeystone = target.isBoss || target.hp > target.maxHp * 0.7;
                        } else if (equippedKeystone.internalName === 'shadow-dancer') {
                            // Use when below 60% HP or against 2+ enemies
                            shouldUseKeystone = member.hp < member.getTotalMaxHp() * 0.6 || aliveEnemies.length >= 2;
                        } else if (equippedKeystone.internalName === 'serpents-venom') {
                            // Use on any enemy that doesn't have poison yet
                            shouldUseKeystone = !target.poisonStacks || target.poisonStacks < 3;
                        }

                        // Archer keystones
                        else if (equippedKeystone.internalName === 'hawkeyes-precision') {
                            // Use on bosses or high HP targets for maximum impact
                            shouldUseKeystone = target.isBoss || (target.hp > target.maxHp * 0.6 && aliveEnemies.length <= 2);
                        } else if (equippedKeystone.internalName === 'rapid-quiver') {
                            // Use on bosses OR when 2+ enemies for AOE value
                            shouldUseKeystone = target.isBoss || aliveEnemies.length >= 2;
                        } else if (equippedKeystone.internalName === 'hunters-focus') {
                            // Use on bosses or when facing tough enemies
                            shouldUseKeystone = target.isBoss || (target.hp > target.maxHp * 0.7 && target.defense > 10);
                        }

                        // Paladin keystones
                        else if (equippedKeystone.internalName === 'holy-avenger') {
                            // Use on bosses OR when 2+ enemies, AND party needs healing
                            const injuredCount = this.party.filter(m => m.isAlive && m.hp < m.getTotalMaxHp() * 0.7).length;
                            shouldUseKeystone = (target.isBoss || aliveEnemies.length >= 2) && injuredCount >= 1;
                        } else if (equippedKeystone.internalName === 'divine-guardian') {
                            // Use when 2+ allies are injured or facing boss
                            const injuredCount = this.party.filter(m => m.isAlive && m.hp < m.getTotalMaxHp() * 0.6).length;
                            shouldUseKeystone = injuredCount >= 2 || (target.isBoss && injuredCount >= 1);
                        } else if (equippedKeystone.internalName === 'righteous-fury') {
                            // Use on bosses OR when 2+ enemies for AOE damage + team AS buff
                            shouldUseKeystone = target.isBoss || aliveEnemies.length >= 2;
                        }

                        if (shouldUseKeystone) {
                            // Ensure keystoneMaxCooldown is properly set before using ability
                            if (!member.keystoneMaxCooldown || member.keystoneMaxCooldown !== equippedKeystone.ability.cooldown) {
                                member.keystoneMaxCooldown = equippedKeystone.ability.cooldown;
                            }

                            // Use the keystone ability
                            member.keystoneCooldown = member.keystoneMaxCooldown;
                            member.lastKeystoneCooldownTime = Date.now(); // Reset the time tracker when keystone activates
                            console.log(`[KEYSTONE] ${member.name} used ${equippedKeystone.internalName}, cooldown set to ${member.keystoneCooldown}s (max: ${member.keystoneMaxCooldown}s)`);

                            if (keystoneManaCost > 0) {
                                member.mana -= keystoneManaCost; // Deduct mana cost only if > 0
                            }
                            performedAction = true;

                            // Execute keystone effects
                            if (equippedKeystone.internalName === 'wardens-aegis') {
                                this.createInvulnerabilityEffect(member.sprite);
                                member.invulnerable = true;
                                member.invulnerableTimer = 180; // 3 seconds
                                this.addLog(`${member.name} becomes invulnerable!`, 'heal');

                            } else if (equippedKeystone.internalName === 'berserkers-pact') {
                                this.createBloodFrenzyEffect(member.sprite);
                                const hpCost = Math.floor(member.hp * 0.3);
                                member.hp -= hpCost;
                                member.berserkerActive = true;
                                member.berserkerTimer = 480; // 8 seconds
                                this.addLog(`${member.name} enters blood frenzy!`, 'damage');

                            } else if (equippedKeystone.internalName === 'earthshakers-resolve') {
                                this.createSeismicSlamEffect(member.sprite);
                                aliveEnemies.forEach(enemy => {
                                    enemy.stunned = true;
                                    enemy.stunnedTimer = 150; // 2.5 seconds
                                    enemy.attackDebuff = 0.6; // -40% attack
                                    enemy.attackDebuffTimer = 300; // 5 seconds
                                });
                                this.addLog(`${member.name} slams the ground!`, 'damage');

                            } else if (equippedKeystone.internalName === 'arcanists-conduit') {
                                const lowestManaAlly = this.party.filter(m => m.isAlive)
                                    .sort((a, b) => (a.mana / a.getTotalMaxMana()) - (b.mana / b.getTotalMaxMana()))[0];
                                if (lowestManaAlly) {
                                    const manaRestored = Math.floor(lowestManaAlly.getTotalMaxMana() * 0.75);
                                    lowestManaAlly.mana = Math.min(lowestManaAlly.getTotalMaxMana(), lowestManaAlly.mana + manaRestored);
                                    this.createHealEffect(lowestManaAlly.sprite);
                                    this.addLog(`${member.name} restores ${manaRestored} mana to ${lowestManaAlly.name}!`, 'heal');
                                }

                            } else if (equippedKeystone.internalName === 'martyrs-blessing') {
                                const hpSacrificed = Math.floor(member.hp * 0.4);
                                member.hp -= hpSacrificed;
                                const healPerAlly = Math.floor((hpSacrificed * 2) / this.party.filter(m => m.isAlive).length);
                                this.party.filter(m => m.isAlive).forEach(ally => {
                                    ally.heal(healPerAlly);
                                    this.createHealEffect(ally.sprite);
                                    this.createFloatingText(ally.sprite, `+${healPerAlly}`, 'heal-text');

                                    // Track character-specific healing for all dungeons
                                    if (this.characterStats && this.characterStats[member.name]) {
                                        this.characterStats[member.name].healingDone += healPerAlly;
                                    }
                                });
                                this.addLog(`${member.name} sacrifices HP to heal the party!`, 'heal');

                            } else if (equippedKeystone.internalName === 'phoenix-heart') {
                                const deadAlly = this.party.find(m => !m.isAlive);
                                if (deadAlly) {
                                    deadAlly.isAlive = true;
                                    deadAlly.hp = Math.floor(deadAlly.getTotalMaxHp() * 0.4);
                                    deadAlly.mana = Math.floor(deadAlly.getTotalMaxMana() * 0.3);
                                    this.createHealEffect(deadAlly.sprite);
                                    member.phoenixUsedThisBattle = true;
                                    this.addLog(`${member.name} resurrects ${deadAlly.name}!`, 'heal');
                                }

                            } else if (equippedKeystone.internalName === 'winters-wrath') {
                                this.createBlizzardEffect(aliveEnemies);
                                aliveEnemies.forEach(enemy => {
                                    enemy.frozen = true;
                                    enemy.frozenTimer = 120; // 2 seconds
                                    const damage = member.getTotalAttack() * 1.2;
                                    const dealt = enemy.takeDamage(damage);
                                    this.createFloatingText(enemy.sprite, `-${dealt}`, 'damage-text');
                                    this.floorStats.damageDealt += dealt;

                                    // Track character-specific damage for all dungeons
                                    if (this.characterStats && this.characterStats[member.name]) {
                                        this.characterStats[member.name].damageDealt += dealt;
                                    }
                                });
                                this.addLog(`${member.name} casts Blizzard!`, 'damage');

                            } else if (equippedKeystone.internalName === 'voidwalkers-gift') {
                                this.createVoidSurgeEffect(member.sprite);
                                member.voidSurgeActive = true;
                                member.voidSurgeStacks = 5;
                                this.addLog(`${member.name} channels void energy!`, 'damage');

                            } else if (equippedKeystone.internalName === 'timeweavers-paradox') {
                                this.createTemporalRewindEffect();
                                this.party.filter(m => m.isAlive).forEach(ally => {
                                    // Reset cooldowns for everyone EXCEPT the caster
                                    if (ally !== member) {
                                        ally.cooldown = 0;
                                        if (ally.keystoneCooldown) ally.keystoneCooldown = 0;
                                    }
                                    const healAmount = Math.floor(ally.getTotalMaxHp() * 0.25);
                                    ally.heal(healAmount);
                                    this.createHealEffect(ally.sprite);

                                    // Track character-specific healing for all dungeons
                                    if (this.characterStats && this.characterStats[member.name]) {
                                        this.characterStats[member.name].healingDone += healAmount;
                                    }
                                });
                                this.addLog(`${member.name} rewinds time for allies!`, 'heal');

                            } else if (equippedKeystone.internalName === 'assassins-mark') {
                                this.createCrippleEffect(target.sprite);
                                const damage = member.getTotalAttack() * 1.5;
                                const dealt = target.takeDamage(damage);
                                this.createFloatingText(target.sprite, `-${dealt}`, 'damage-text');
                                this.floorStats.damageDealt += dealt;

                                // Track character-specific damage for all dungeons
                                if (this.characterStats && this.characterStats[member.name]) {
                                    this.characterStats[member.name].damageDealt += dealt;
                                }

                                target.defenseDebuff = 20;
                                target.defenseDebuffTimer = 300; // 5 seconds
                                this.addLog(`${member.name} cripples ${target.name}!`, 'damage');

                            } else if (equippedKeystone.internalName === 'shadow-dancer') {
                                this.createShadowStepEffect(member.sprite);
                                member.shadowDancerActive = true;
                                member.shadowDancerStacks = 3;
                                this.addLog(`${member.name} enters the shadows!`, 'damage');

                            } else if (equippedKeystone.internalName === 'serpents-venom') {
                                this.createToxicCascadeEffect(target.sprite);
                                if (!target.poisonStacks) target.poisonStacks = 0;
                                if (!target.poisonDamage) target.poisonDamage = 0;
                                target.poisonStacks = Math.min(3, target.poisonStacks + 1);
                                target.poisonDamage = member.getTotalAttack() * 0.4;
                                target.poisonTimer = 600; // 10 seconds
                                target.poisonAttackSpeedDebuff = 0.85; // -15% attack speed
                                this.addLog(`${member.name} poisons ${target.name}!`, 'damage');
                            }

                            // ARCHER KEYSTONES
                            else if (equippedKeystone.internalName === 'hawkeyes-precision') {
                                // Perfect Shot - 250% attack, 100% crit, ignores defense
                                member.sprite.attacking = true;
                                this.createPerfectShotEffect(member.sprite, target.sprite);

                                const baseDamage = member.getTotalAttack() * 2.5;
                                const critMultiplier = member.getTotalCritDamage() / 100;
                                const finalDamage = Math.floor(baseDamage * critMultiplier);

                                // Bypass defense completely
                                target.hp = Math.max(0, target.hp - finalDamage);
                                if (target.hp === 0) target.isAlive = false;

                                this.createFloatingText(target.sprite, `-${finalDamage} PERFECT!`, 'damage-text');
                                this.floorStats.damageDealt += finalDamage;

                                // Track character-specific damage for all dungeons
                                if (this.characterStats && this.characterStats[member.name]) {
                                    this.characterStats[member.name].damageDealt += finalDamage;
                                }

                                this.addLog(`${member.name} fires a Perfect Shot at ${target.name}!`, 'damage');

                            } else if (equippedKeystone.internalName === 'rapid-quiver') {
                                // Arrow Storm - 8 arrows over 2 seconds
                                member.sprite.attacking = true;
                                member.arrowStormActive = true;
                                member.arrowStormArrows = 8;
                                member.arrowStormTimer = 0;
                                member.arrowStormInterval = 15; // Fire arrow every 15 frames (0.25s)
                                member.arrowStormDamage = Math.floor(member.getTotalAttack() * 0.6);
                                this.addLog(`${member.name} unleashes Arrow Storm!`, 'damage');

                            } else if (equippedKeystone.internalName === 'hunters-focus') {
                                // Marked for Death - +80% damage, +30% lifesteal for 6s
                                this.createMarkEffect(target.sprite);
                                target.markedBy = member;
                                target.markedTimer = 360; // 6 seconds
                                target.markedDamageBonus = 0.8; // +80% damage
                                target.markedLifesteal = 0.3; // +30% lifesteal
                                this.addLog(`${member.name} marks ${target.name} for death!`, 'damage');
                            }

                            // PALADIN KEYSTONES
                            else if (equippedKeystone.internalName === 'holy-avenger') {
                                // Divine Wrath - 160% AOE damage + 15% heal to all allies
                                member.sprite.attacking = true;
                                this.createDivineWrathEffect(member.sprite);

                                const aoeDamage = Math.floor(member.getTotalAttack() * 1.6);
                                aliveEnemies.forEach(enemy => {
                                    const dealt = enemy.takeDamage(aoeDamage);
                                    this.createFloatingText(enemy.sprite, `-${dealt}`, 'damage-text');
                                    this.floorStats.damageDealt += dealt;

                                    // Track character-specific damage for all dungeons
                                    if (this.characterStats && this.characterStats[member.name]) {
                                        this.characterStats[member.name].damageDealt += dealt;
                                    }
                                });

                                this.party.filter(m => m.isAlive).forEach(ally => {
                                    const healAmount = Math.floor(ally.getTotalMaxHp() * 0.15);
                                    ally.heal(healAmount);
                                    this.createHealEffect(ally.sprite);
                                    this.createFloatingText(ally.sprite, `+${healAmount}`, 'heal-text');

                                    // Track character-specific healing for all dungeons
                                    if (this.characterStats && this.characterStats[member.name]) {
                                        this.characterStats[member.name].healingDone += healAmount;
                                    }
                                });

                                this.addLog(`${member.name} smites all enemies with Divine Wrath!`, 'heal');

                            } else if (equippedKeystone.internalName === 'divine-guardian') {
                                // Sacred Barrier - 20% max HP shields + 30% defense for 6s
                                this.createSacredBarrierEffect(member.sprite);

                                let totalShieldAmount = 0;
                                this.party.filter(m => m.isAlive).forEach(ally => {
                                    const now = Date.now();
                                    const shieldAmount = Math.floor(ally.getTotalMaxHp() * 0.2);
                                    ally.shieldAmount = (ally.shieldAmount || 0) + shieldAmount;
                                    ally.shieldEndTime = now + 6000; // 6 seconds
                                    ally.sacredBarrierDefense = 0.3; // +30% defense
                                    ally.sacredBarrierTimer = 360;
                                    this.createFloatingText(ally.sprite, `+${shieldAmount} SHIELD`, 'heal-text');
                                    totalShieldAmount += shieldAmount;
                                });

                                // Track total shields granted in stats
                                if (this.characterStats && this.characterStats[member.name]) {
                                    this.characterStats[member.name].healingDone += totalShieldAmount;
                                    console.log(`‚úÖ ${member.name} Divine Guardian shield tracked: +${totalShieldAmount} to healing (Total: ${this.characterStats[member.name].healingDone})`);
                                } else {
                                    console.warn(`‚ö†Ô∏è Failed to track ${member.name} Divine Guardian shields - characterStats not initialized`);
                                }

                                this.addLog(`${member.name} grants Sacred Barrier to all allies!`, 'heal');

                            } else if (equippedKeystone.internalName === 'righteous-fury') {
                                // Holy Fire - 150% AOE damage + 35% AS to all allies for 5s
                                member.sprite.attacking = true;
                                this.createHolyFireEffect(member.sprite);

                                const aoeDamage = Math.floor(member.getTotalAttack() * 1.5);
                                aliveEnemies.forEach(enemy => {
                                    const dealt = enemy.takeDamage(aoeDamage);
                                    this.createFloatingText(enemy.sprite, `-${dealt}`, 'damage-text');
                                    this.floorStats.damageDealt += dealt;

                                    // Track character-specific damage for all dungeons
                                    if (this.characterStats && this.characterStats[member.name]) {
                                        this.characterStats[member.name].damageDealt += dealt;
                                    }
                                });

                                this.party.filter(m => m.isAlive).forEach(ally => {
                                    ally.righteousFuryAS = 0.35; // +35% attack speed
                                    ally.righteousFuryTimer = 300; // 5 seconds
                                });

                                this.addLog(`${member.name} ignites Holy Fire! Allies gain +35% Attack Speed!`, 'damage');
                            }
                        }
                    }

                    // Log before checking cooldown to verify we reach this code
                    if (member.keystoneCooldown !== undefined && member.keystoneCooldown !== 0) {
                        console.log(`[CD CHECK] ${member.name} has keystoneCooldown=${member.keystoneCooldown}, about to reduce...`);
                    }

                    // Reduce keystone cooldown using real time (consistent with regular abilities)
                    if (member.keystoneCooldown > 0) {
                        if (!member.lastKeystoneCooldownTime) member.lastKeystoneCooldownTime = Date.now();

                        const now = Date.now();
                        const elapsed = (now - member.lastKeystoneCooldownTime) / 1000;
                        member.lastKeystoneCooldownTime = now;

                        const cdr = member.getTotalCDR ? member.getTotalCDR() : 0;
                        const cooldownMultiplier = 1 + (cdr / 100);
                        const reduction = elapsed * cooldownMultiplier;

                        // Log every reduction to see if it's happening
                        console.log(`[CD REDUCTION] ${member.name} keystone: ${member.keystoneCooldown.toFixed(2)}s -> ${(member.keystoneCooldown - reduction).toFixed(2)}s (elapsed: ${elapsed.toFixed(3)}s, reduction: ${reduction.toFixed(3)}s, CDR: ${cdr}%)`);

                        member.keystoneCooldown -= reduction;

                        if (member.keystoneCooldown <= 0) {
                            console.log(`[CD COMPLETE] ${member.name} keystone cooldown finished!`);
                            member.keystoneCooldown = 0;
                            member.lastKeystoneCooldownTime = undefined; // Reset tracker when cooldown completes
                            member._lastCDLog = undefined;
                        }
                    }
                }

                // Regular attack if no skill
if (!performedAction) {
    damage = member.getTotalAttack();
}

                // Deal damage and handle movement
                if (damage > 0 && target) {
                    // Store original position
                    const originalX = member.sprite.gridX;
                    const originalY = member.sprite.gridY;

                    // Don't move during Rune Trial pillar charging - stay at pillar!
                    const stayAtPillar = this.currentDungeon === 'runetrial' && this.runeTrialPillarCharging;

                    // Don't move towards bombers in Rune Trial - Tank/Rogue stay put
                    const dontChase = this.currentDungeon === 'runetrial' && target.isBomber && (member.className === 'Tank' || member.className === 'Rogue');

                    // Move based on class
                    if (member.className === 'Tank' && !stayAtPillar && !dontChase) {
                        // Tank moves close but keeps distance from large bosses
                        const isBigBoss = target.isRuneTrialBoss || target.name === 'Keystone Warden' || target.name === 'Rune Guardian';
                        const offset = isBigBoss ? 3 : 1; // Keep more distance from big bosses
                        member.sprite.moveTo(target.sprite.gridX - offset, target.sprite.gridY);
                        member.hasEngaged = true;
                    } else if (member.className === 'Paladin' && !stayAtPillar && !dontChase) {
                        // Paladin moves close to engage in melee like Tank
                        const isBigBoss = target.isRuneTrialBoss || target.name === 'Keystone Warden' || target.name === 'Rune Guardian';
                        const offset = isBigBoss ? 3 : 1;
                        member.sprite.moveTo(target.sprite.gridX - offset, target.sprite.gridY);
                        member.hasEngaged = true;
                    } else if (member.className === 'Rogue' && !stayAtPillar && !dontChase) {
                        // Rogue only moves in if tank has engaged or after initial period
                        if (tankHasEngaged || battleTime > 2) {
                            // Attacks from flank
                            member.sprite.moveTo(target.sprite.gridX - 1, target.sprite.gridY + 0.5);
                        } else {
                            // Throws daggers from range
                            damage = Math.floor(damage * 0.7);
                            member.sprite.attacking = true;
                        }
                    } else {
                        // Ranged stays in place
                        member.sprite.attacking = true;
                    }

                    // Create subtle basic attack animation
if (member.className === 'Healer') {
    // Only show animation if attack is ready
    if (!member._lastAttackTime || Date.now() - member._lastAttackTime >= 1000 / member.getTotalAttackSpeed()) {
        member._lastAttackTime = Date.now();

        // Small light bolt
        const startPos = ISO.toScreen(member.sprite.gridX, member.sprite.gridY);
        const endPos = ISO.toScreen(target.sprite.gridX, target.sprite.gridY);
        this.visualEffects.push({
            type: 'projectile',
            x: startPos.x + this.offsetX,
            y: startPos.y + this.offsetY - 20,
            targetX: endPos.x + this.offsetX,
            targetY: endPos.y + this.offsetY,
            speed: 12,
            color: 'rgba(16, 185, 129, 0.4)',
            size: 4,
            trail: [],
            life: 60
        });
    }
} else if (member.className === 'Mage') {
    // Only show animation if attack is ready
    if (!member._lastAttackTime || Date.now() - member._lastAttackTime >= 1000 / member.getTotalAttackSpeed()) {
        member._lastAttackTime = Date.now();

        // Small purple arcane bolt
        const startPos = ISO.toScreen(member.sprite.gridX, member.sprite.gridY);
        const endPos = ISO.toScreen(target.sprite.gridX, target.sprite.gridY);
        this.visualEffects.push({
            type: 'projectile',
            x: startPos.x + this.offsetX,
            y: startPos.y + this.offsetY - 20,
            targetX: endPos.x + this.offsetX,
            targetY: endPos.y + this.offsetY,
            speed: 14,
            color: 'rgba(168, 85, 247, 0.6)',
            size: 5,
            trail: [],
            life: 60
        });
    }
} else if (member.className === 'Rogue') {
    // Double dagger stab animation - positioned at target level
    const pos = ISO.toScreen(member.sprite.gridX, member.sprite.gridY);

    // Only show animation if not on cooldown (matches attack speed)
    if (!member._lastAttackTime || Date.now() - member._lastAttackTime >= 1000 / member.getTotalAttackSpeed()) {
        member._lastAttackTime = Date.now();

        // Hide weapons during animation
        member.sprite.hideWeapons = true;

        // Left dagger stab
        this.visualEffects.push({
            type: 'dagger-stab',
            x: pos.x + this.offsetX + 18,  // Right side
            y: pos.y + this.offsetY - 5,   // At target level (lowered from -25)
            startX: 0,
            endX: 15,
            currentX: 0,
            offsetY: -3,
            color: '#d4d4d8',  // Silver weapon color
            life: 10,
            delay: 0
        });

        // Right dagger stab (slightly delayed)
        setTimeout(() => {
            this.visualEffects.push({
                type: 'dagger-stab',
                x: pos.x + this.offsetX + 18,
                y: pos.y + this.offsetY - 5,  // At target level (lowered from -25)
                startX: 0,
                endX: 15,
                currentX: 0,
                offsetY: 3,
                color: '#d4d4d8',  // Silver weapon color
                life: 10,
                delay: 0
            });
        }, 100);

        // Show weapons again after animation
        setTimeout(() => {
            member.sprite.hideWeapons = false;
        }, 300);
    }

} else if (member.className === 'Tank') {
    // Arm swing animation (heavier) - positioned on far right and high
    const pos = ISO.toScreen(member.sprite.gridX, member.sprite.gridY);
    this.visualEffects.push({
        type: 'arm-swing',
        x: pos.x + this.offsetX + 22,  // Much further right
        y: pos.y + this.offsetY - 15,  // Much higher
        startAngle: -60,
        endAngle: 60,
        currentAngle: -60,
        armLength: 18,
        color: '#d4d4d8',
        life: 15
    });
} else if (member.className === 'Paladin') {
    // Holy weapon swing animation - similar to Tank but with golden glow
    const pos = ISO.toScreen(member.sprite.gridX, member.sprite.gridY);
    this.visualEffects.push({
        type: 'arm-swing',
        x: pos.x + this.offsetX + 22,
        y: pos.y + this.offsetY - 15,
        startAngle: -60,
        endAngle: 60,
        currentAngle: -60,
        armLength: 18,
        color: '#fbbf24',  // Golden color for holy effect
        life: 15
    });
    // Add holy light flash effect
    this.visualEffects.push({
        type: 'flash',
        x: pos.x + this.offsetX + 25,
        y: pos.y + this.offsetY - 10,
        color: 'rgba(251, 191, 36, 0.6)',
        radius: 20,
        life: 8
    });
}

                // Deal damage after short delay
                    setTimeout(() => {
                        // Voidwalker's Gift: Ignore defense and boost crit
                        let tempDefense = null;
                        let critBonus = 0;
                        if (member.voidSurgeActive && member.voidSurgeStacks > 0) {
                            tempDefense = target.defense;
                            target.defense = 0; // Ignore 100% defense
                            critBonus = 50; // +50% crit chance
                            member.voidSurgeStacks--;
                            if (member.voidSurgeStacks === 0) {
                                member.voidSurgeActive = false;
                            }
                        }

                        // Apply Marked for Death damage bonus
                        if (target.markedBy && target.markedDamageBonus) {
                            damage = Math.floor(damage * (1 + target.markedDamageBonus));
                        }

                        const dealt = target.takeDamage(damage);

                        // Restore defense if it was modified
                        if (tempDefense !== null) {
                            target.defense = tempDefense;
                        }

                        if (dealt === 'DODGE') {
                            this.createFloatingText(target.sprite, 'DODGE', 'heal-text');
                        } else if (dealt === 0 && target.invulnerable) {
                            this.createFloatingText(target.sprite, 'INVULNERABLE', 'gold-text');
                        } else {
                            // Check for critical hit (with void surge bonus)
                            const isCrit = Math.random() * 100 < (member.getTotalCritChance() + critBonus);
                            let finalDamage = dealt;

                            if (isCrit) {
                                const critMultiplier = member.getTotalCritDamage() / 100;
                                finalDamage = Math.floor(dealt * critMultiplier);
                                target.hp = Math.max(0, target.hp - (finalDamage - dealt));
                                if (target.hp === 0) target.isAlive = false;
                                this.createFloatingText(target.sprite, `-${finalDamage} CRIT!`, 'damage-text');
                            } else {
                                this.createFloatingText(target.sprite, `-${dealt}`, 'damage-text');
                            }

                            // Track damage dealt
                            this.floorStats.damageDealt += finalDamage;

                            // Track character-specific damage for all dungeons
                            if (this.characterStats && this.characterStats[member.name]) {
                                this.characterStats[member.name].damageDealt += finalDamage;
                            }

                            // Apply lifesteal (base + marked bonus)
                            let lifesteal = member.getTotalLifesteal();
                            if (target.markedBy === member && target.markedLifesteal) {
                                lifesteal += target.markedLifesteal * 100; // Convert 0.3 to 30%
                            }
                            if (lifesteal > 0) {
                                const healAmount = Math.floor(finalDamage * (lifesteal / 100));
                                if (healAmount > 0) {
                                    member.heal(healAmount);
                                    this.createFloatingText(member.sprite, `+${healAmount}`, 'heal-text');

                                    // Track lifesteal healing in stats
                                    if (this.characterStats && this.characterStats[member.name]) {
                                        this.characterStats[member.name].healingDone += healAmount;
                                        console.log(`üíâ ${member.name} lifesteal tracked: +${healAmount} (Total healing: ${this.characterStats[member.name].healingDone})`);
                                    }
                                }
                            }

                            member.sprite.attacking = true;
                        }

                        if (!target.isAlive) {
                            this._unitPositionsChanged = true; // Mark for re-sort
                            this.addLog(`${member.name} defeats ${target.name}!`, 'damage');

                            // Track kills for endless dungeon
                            if (this.currentDungeon === 'endlessblessings' && this.updateEndlessWave) {
                                this.updateEndlessWave();
                            }

                            // Track kills
                            this.floorStats.enemiesKilled++;

                            // Share XP equally among all living party members
                            const aliveParty = this.party.filter(m => m.isAlive);
                            const xpPerMember = Math.max(1, Math.floor(target.xpReward / aliveParty.length));
                            aliveParty.forEach(partyMember => {
                                partyMember.gainXP(xpPerMember);
                            });

                            // Track gold earned
                            this.floorStats.goldEarned += target.goldReward;
                            this.gold += target.goldReward;
                            this.createFloatingText(target.sprite, `+${target.goldReward}g`, 'gold-text');

                            // Individual enemy loot drop
                            this.rollEnemyLoot(target);
                        }

                        // Return to position for melee
                        if (member.className === 'Tank' ||
                            member.className === 'Paladin' ||
                            (member.className === 'Rogue' && (tankHasEngaged || battleTime > 2))) {
                            setTimeout(() => {
                                member.sprite.moveTo(originalX, originalY);
                            }, 400);
                        }
                    }, 200);
                }
            }

performEnemyAttack(enemy, aliveParty) {
    if (!enemy || !enemy.sprite || aliveParty.length === 0) return;

    // Rune Trial Boss - Simple tank and spank, no special mechanics
    // All challenge comes from managing bomber minions

    // Enemies target based on threat - tank first if alive
    const tank = aliveParty.find(m => m.className === 'Tank');
    let target;

    // If tank has taunt active, 100% target tank, otherwise 85% chance
    if (tank && tank.isAlive && tank.tauntActive) {
        target = tank;
    } else if (tank && tank.isAlive && Math.random() > 0.15) {
        target = tank;
    } else {
        target = aliveParty[Math.floor(Math.random() * aliveParty.length)];
    }

    if (target && target.sprite) {
        let damage = enemy.getTotalAttack();

        // Rune Trial Boss phase modifiers
        if (enemy.isRuneTrialBoss) {
            if (enemy.elementalPhase === 'fire') {
                damage = Math.floor(damage * 1.3);
            } else if (enemy.elementalPhase === 'ice') {
                // Ice phase slows attack speed (handled in attack timer)
            } else if (enemy.elementalPhase === 'lightning') {
                // Lightning phase increases attack speed (handled in attack timer)
            }
        }

        // Store original position
        const originalX = enemy.sprite.gridX;
        const originalY = enemy.sprite.gridY;

        // Find an available position around the target to prevent stacking
        const findAttackPosition = () => {
            // Try positions around the target in order of preference
            const offsets = [
                {x: 1, y: 0},   // Right
                {x: -1, y: 0},  // Left
                {x: 0, y: 1},   // Below
                {x: 0, y: -1},  // Above
                {x: 1, y: 1},   // Diagonal bottom-right
                {x: -1, y: 1},  // Diagonal bottom-left
                {x: 1, y: -1},  // Diagonal top-right
                {x: -1, y: -1}  // Diagonal top-left
            ];

            for (const offset of offsets) {
                const testX = target.sprite.gridX + offset.x;
                const testY = target.sprite.gridY + offset.y;

                // Check if this position is occupied by another enemy
                let occupied = false;
                for (const otherEnemy of this.enemies) {
                    if (otherEnemy === enemy || !otherEnemy.sprite) continue;
                    const dx = Math.abs(otherEnemy.sprite.targetX - testX);
                    const dy = Math.abs(otherEnemy.sprite.targetY - testY);
                    if (dx < 0.5 && dy < 0.5) {
                        occupied = true;
                        break;
                    }
                }

                if (!occupied) {
                    return {x: testX, y: testY};
                }
            }

            // Fallback if all positions are occupied
            return {x: target.sprite.gridX + 1, y: target.sprite.gridY};
        };

        const attackPos = findAttackPosition();

        // Move towards target
        enemy.sprite.moveTo(attackPos.x, attackPos.y);

        // Deal damage after delay
        setTimeout(() => {
            const dealt = target.takeDamage(damage);
            enemy.sprite.attacking = true;
            this.createFloatingText(target.sprite, `-${dealt}`, 'damage-text');

            // Return to position
            setTimeout(() => {
                enemy.sprite.moveTo(originalX, originalY);
            }, 400);
        }, 200);
    }
}


endBattle(victory) {
    this.inBattle = false;

    // Clean up vault summoning timers
    if (this.vaultSummonInterval) {
        clearInterval(this.vaultSummonInterval);
        this.vaultSummonInterval = null;
    }
    if (this.vaultSummonTimeout) {
        clearTimeout(this.vaultSummonTimeout);
        this.vaultSummonTimeout = null;
    }

    // Immediately clear enemy health bars
    const healthBarContainer = document.getElementById('enemy-health-bars');
    if (healthBarContainer) healthBarContainer.innerHTML = '';

    // Ensure dead party members show 0 HP
    this.party.forEach(member => {
        if (!member.isAlive) {
            member.hp = 0;
        }
    });

    // Update UI immediately to reflect death state
    this.updateUI();

    // Remove dead enemies immediately - no delay needed
    this.enemies = this.enemies.filter(e => e.isAlive);


if (victory && this.currentDungeon !== 'endlessblessings') {
                    this.addLog('Victory!', 'room');

// Handle Rune Trial victory
                if (this.currentDungeon === 'runetrial') {
                    this.addLog('Rune Trial conquered!', 'loot');

                    // Award gold and XP
                    const goldReward = this.runeTrialTier * 100;
                    this.gold += goldReward;
                    this.floorStats.goldEarned += goldReward;

                    const xpReward = this.runeTrialTier * 500;
                    this.party.forEach(member => {
                        member.gainXP(xpReward);
                    });

                    // Drop 1 guaranteed rune
                    const rune = this.rollRuneFromTrial(this.runeTrialTier);

                    // Drop 3 guaranteed loot items
                    const baseLootTable = ['helmet', 'chest', 'gloves', 'boots', 'belt', 'amulet', 'ring', 'wand', 'dagger', 'greatsword', 'staff', 'bow', 'warhammer'];
                    const lootTable = this.getFilteredLootTable(baseLootTable);
                    const runeTrialLoot = [];
                    for (let i = 0; i < 3; i++) {
                        // Skip if no valid items
                        if (lootTable.length === 0) continue;

                        const type = lootTable[Math.floor(Math.random() * lootTable.length)];

                        let rarity;
                        const roll = Math.random() * 100;

                        if (roll < 10) rarity = 'legendary';
                        else if (roll < 50) rarity = 'epic';
                        else rarity = 'rare';

                        // Loot level based on tier
                        const levelRange = RUNE_TRIAL_CONFIG.LOOT_LEVEL_RANGE[this.runeTrialTier];
                        const minLevel = levelRange.min;
                        const maxLevel = levelRange.max;
                        const itemLevel = minLevel + Math.floor(Math.random() * (maxLevel - minLevel + 1));
                        const item = new Item(type, rarity, itemLevel);
                        runeTrialLoot.push(item);

                        if (!this.lootFilter[rarity] || item.level < this.lootFilter.minLevel) {
                            const sellPrices = {
    common: 5,
    uncommon: 10,
    rare: 15,
    epic: 20,
    legendary: 25,
    mythic: 10000
};
                            const sellPrice = sellPrices[rarity] || 15;
                            this.gold += sellPrice;
                            this.floorStats.goldEarned += sellPrice;
                        } else {
                            this.loot.push(item);
                            this.floorStats.lootObtained++;
                            if (rarity === 'legendary') this.globalStats.legendariesFound++;

                            // Auto-sell lowest gear score item if loot exceeds 50 items
                            if (this.loot.length > 50) {
                                this.autoSellLowestGearScore();
                            }
                        }
                    }

                    // Show victory screen
                    setTimeout(() => {
                        this.showRuneTrialVictoryScreen(goldReward, xpReward, rune, runeTrialLoot);
                    }, 2000);

                    // Track rune trial boss kill for leaderboard
                    if (!this.dungeonProgress) this.dungeonProgress = {};
                    if (!this.dungeonProgress.runetrial) this.dungeonProgress.runetrial = { bossKills: 0 };
                    this.dungeonProgress.runetrial.bossKills++;

                    // Update stats
                    this.successfulRuns++;
                    this.globalStats.totalFloorsCleared++;
                    this.globalStats.totalGoldEarned += this.floorStats.goldEarned;

                    return;
                }

                // Handle Vault victory differently (no dungeon layout)
                if (this.currentDungeon === 'vault') {
                    // Vault victory - award gold and XP
                    this.addLog('Vault conquered!', 'loot');

                    // Award gold (200 per vault level)
                    const goldReward = this.vaultLevel * VAULT_KEY_CONFIG.GOLD_PER_LEVEL;
                    this.gold += goldReward;
                    this.floorStats.goldEarned += goldReward;

                    // Award XP (200 per vault level, to ALL party members dead or alive)
                    const xpReward = this.vaultLevel * 200;
                    this.party.forEach(member => {
                        member.gainXP(xpReward);
                    });

                    // Drop keystone at vault level
                    const keystone = this.rollKeystoneFromVault(this.vaultLevel);

                    // Drop 3 guaranteed loot items at vault level
                    const vaultLoot = [];
                    const baseLootTable = ['helmet', 'chest', 'gloves', 'boots', 'belt', 'amulet', 'ring', 'wand', 'dagger', 'greatsword', 'staff', 'bow', 'warhammer'];
                    const lootTable = this.getFilteredLootTable(baseLootTable);

                    for (let i = 0; i < 3; i++) {
                        // Skip if no valid items
                        if (lootTable.length === 0) continue;

                        const type = lootTable[Math.floor(Math.random() * lootTable.length)];

                        let rarity;
                        const roll = Math.random() * 100;

                        if (roll < KEYSTONE_CONFIG.RARITY_BOOST.legendary) rarity = 'legendary';
                        else if (roll < KEYSTONE_CONFIG.RARITY_BOOST.legendary + KEYSTONE_CONFIG.RARITY_BOOST.epic) rarity = 'epic';
                        else rarity = 'rare';

                        // Loot level in range: (vaultLevel * 5 + 3) to (vaultLevel * 5 + 5)
                        const minLevel = this.vaultLevel * 5 + 3;
                        const maxLevel = this.vaultLevel * 5 + 5;
                        const itemLevel = minLevel + Math.floor(Math.random() * (maxLevel - minLevel + 1));
                        const item = new Item(type, rarity, itemLevel);
                        vaultLoot.push(item);

                        if (!this.lootFilter[rarity] || item.level < this.lootFilter.minLevel) {
                            const sellPrices = {
    common: 5,
    uncommon: 10,
    rare: 15,
    epic: 20,
    legendary: 25,
    mythic: 10000
};
                            const sellPrice = sellPrices[rarity] || 15;
                            this.gold += sellPrice;
                            this.floorStats.goldEarned += sellPrice;
                        } else {
                            this.loot.push(item);
                            this.floorStats.lootObtained++;
                            if (rarity === 'legendary') this.globalStats.legendariesFound++;
                        }
                    }

                    // Show epic vault victory screen
                    this.showVaultVictoryScreen(goldReward, xpReward, keystone, vaultLoot);

                    // Track vault boss kill for leaderboard
                    if (!this.dungeonProgress) this.dungeonProgress = {};
                    if (!this.dungeonProgress.vault) this.dungeonProgress.vault = { bossKills: 0 };
                    this.dungeonProgress.vault.bossKills++;

                    // Update stats
                    this.successfulRuns++;
                    this.globalStats.totalFloorsCleared++;
                    this.globalStats.totalGoldEarned += this.floorStats.goldEarned;

                    return;
                }

                    // Only try to clear room if we have a dungeon layout (not in Vault)
                    let currentRoom = null;
                    if (this.dungeonLayout && this.dungeonLayout.getCurrentRoom) {
                        try {
                            currentRoom = this.dungeonLayout.getCurrentRoom();
                            if (currentRoom) {
                                currentRoom.cleared = true;
                            }
                        } catch (e) {
                            console.warn('Failed to get current room:', e);
                        }
                    }

                    // Show loot if any was collected during battle
                    if (this.loot.length > 0) {
                        this.showLoot();
                    }

                    // Only do room progression for normal dungeons (not Vault and only if we have a valid dungeon layout)
if (this.currentDungeon && this.currentDungeon !== 'vault' && this.dungeonLayout && currentRoom) {
    // Check if boss was defeated
    if (currentRoom.type === ROOM_TYPES.BOSS) {
        this.addLog('Boss defeated! Floor complete!', 'room');
        // Show summary after boss defeat
        setTimeout(() => this.completeDungeon(), 2000);
    } else {
        // Auto-progress to next room after a delay ONLY if not moving already
        if (this.hasUnvisitedRooms() && !this.movingToNextRoom) {
            setTimeout(() => {
                if (!this.movingToNextRoom && !this.inBattle) {
                    this.moveToNextRoom();
                }
            }, 2000);
        } else if (!this.hasUnvisitedRooms()) {
            // All rooms cleared, go to next floor
            setTimeout(() => this.completeDungeon(), 2000);
        }
    }

    this.drawMinimap();
}
                } else {
                    // Show defeat for endless dungeon with custom summary
                    if (this.currentDungeon === 'endlessblessings') {
                        this.addLog('Party defeated!', 'damage');
                        // Show endless-specific summary after a delay
                        setTimeout(() => this.showEndlessSummary(), 2000);
                        return;
                    }

                    this.addLog('Party defeated!', 'damage');

                    // Update dungeon-specific progress based on gear score
                    if (this.currentDungeon && ['everfall', 'stoneforge', 'umbral'].includes(this.currentDungeon)) {
                        const progress = this.dungeonProgress[this.currentDungeon];

                        // Calculate combined gear score (total level of all equipped items across all 4 characters)
                        const totalGearScore = this.party.reduce((total, member) => {
                            let memberGearScore = 0;
                            for (const slot in member.equipment) {
                                if (member.equipment[slot]) {
                                    memberGearScore += member.equipment[slot].level || 0;
                                }
                            }
                            return total + memberGearScore;
                        }, 0);

                        // Update farthest floor reached
                        if (this.dungeonFloor > progress.farthestFloor) {
                            progress.farthestFloor = this.dungeonFloor;
                        }

                        // Start floor remains as player selected (no automatic changes)
                        this.addLog(`üíé Gear Score: ${totalGearScore} - Best floor reached: ${progress.farthestFloor}`, 'heal');
                    }

                    // Show defeat summary
                    setTimeout(() => this.showSummary(false), 2000);
                }
            }

respawnParty() {
    // Clean up vault timers first
    if (this.vaultSummonInterval) {
        clearInterval(this.vaultSummonInterval);
        this.vaultSummonInterval = null;
    }
    if (this.vaultSummonTimeout) {
        clearTimeout(this.vaultSummonTimeout);
        this.vaultSummonTimeout = null;
    }

    // Reset room label color
    const roomLabel = document.getElementById('room-label');
    if (roomLabel) {
        roomLabel.style.color = '';
    }

    // Track death
    this.globalStats.totalDeaths++;

    // Track gold earned even on failed floors
    this.globalStats.totalGoldEarned += this.floorStats.goldEarned;

    // Restore all party members to life with full HP and Mana
    this.party.forEach(member => {
        member.isAlive = true;
        member.hp = member.getTotalMaxHp();
        member.mana = member.getTotalMaxMana();
    });

    // On death, reset to dungeon's start floor (don't lose all progress)
    if (this.currentDungeon && this.dungeonProgress[this.currentDungeon]) {
        this.dungeonFloor = this.dungeonProgress[this.currentDungeon].startFloor;
    } else {
        this.dungeonFloor = 1;
    }
    document.getElementById('current-floor-display').textContent = this.dungeonFloor;

// If in Vault, show dungeon selector
                if (this.currentDungeon === 'vault') {
                    this.addLog('Party defeated in Vault!', 'damage');

                    // Reset vault state and all flags
                    this.currentDungeon = null;
                    this.vaultLevel = null;
                    this.dungeonFloor = 1;
                    this.inBattle = false;
                    this.movingToNextRoom = false;
                    this.transitioningFloor = false;

                    // Clear the current room and visual elements
                    this.room = null;
                    this.dungeonLayout = null;
                    this.enemies = [];
                    this.hallways = [];  // Clear ghost floors
                    this.adjacentRooms = [];  // Clear invisible rooms

                    // Hide room label and reset color
                    const roomLabel = document.getElementById('room-label');
                    roomLabel.style.display = 'none';
                    roomLabel.style.color = '';

                    // Show dungeon selector
                    setTimeout(() => {
                        this.showDungeonSelector();
                    }, 500);
                    return;
                }

                // If in Rune Trial, show dungeon selector
                if (this.currentDungeon === 'runetrial') {
                    this.addLog('Party defeated in Rune Trial!', 'damage');

                    // Reset trial state and all flags
                    this.currentDungeon = null;
                    this.runeTrialTier = null;
                    this.dungeonFloor = 1;
                    this.inBattle = false;
                    this.movingToNextRoom = false;
                    this.transitioningFloor = false;

                    // Clear the current room and visual elements
                    this.room = null;
                    this.dungeonLayout = null;
                    this.enemies = [];
                    this.hallways = [];  // Clear ghost floors
                    this.adjacentRooms = [];  // Clear invisible rooms

                    // Hide room label and reset color
                    const roomLabel = document.getElementById('room-label');
                    roomLabel.style.display = 'none';
                    roomLabel.style.color = '';

                    // Show dungeon selector
                    setTimeout(() => {
                        this.showDungeonSelector();
                    }, 500);
                    return;
                }

                this.addLog('Party respawns...', 'room');

                // Reset transition flag before generating new dungeon
                this.transitioningFloor = false;

                // Continue with the same dungeon automatically
                setTimeout(() => {
                    this.generateDungeon();
                }, 500);
            }

rollEnemyLoot(enemy) {
    // Bombers don't drop loot
    if (enemy.isBomber) return [];

    const isBoss = enemy.isBoss;
                const isVaultBoss = enemy.isVaultBoss;

                if (isVaultBoss) {
                    const baseLootTable = ['helmet', 'chest', 'gloves', 'boots', 'belt', 'amulet', 'ring', 'wand', 'dagger', 'greatsword', 'staff', 'bow', 'warhammer'];
                    const lootTable = this.getFilteredLootTable(baseLootTable);

                    for (let i = 0; i < 3; i++) {
                        // Skip if no valid items
                        if (lootTable.length === 0) continue;

                        const type = lootTable[Math.floor(Math.random() * lootTable.length)];

                        let rarity;
                        const roll = Math.random() * 100;

                        if (roll < KEYSTONE_CONFIG.RARITY_BOOST.legendary) rarity = 'legendary';
                        else if (roll < KEYSTONE_CONFIG.RARITY_BOOST.legendary + KEYSTONE_CONFIG.RARITY_BOOST.epic) rarity = 'epic';
                        else rarity = 'rare';

                        // Loot level in range: (vaultLevel * 5 + 3) to (vaultLevel * 5 + 5)
                        const minLevel = this.vaultLevel * 5 + 3;
                        const maxLevel = this.vaultLevel * 5 + 5;
                        const itemLevel = minLevel + Math.floor(Math.random() * (maxLevel - minLevel + 1));
                        const item = new Item(type, rarity, itemLevel);

                        if (!this.lootFilter[rarity]) {
                            const sellPrices = {
    common: 5,
    uncommon: 10,
    rare: 15,
    epic: 20,
    legendary: 25,
    mythic: 10000
};
                            const sellPrice = sellPrices[rarity] || 5;
                            this.gold += sellPrice;
                            this.floorStats.goldEarned += sellPrice;
                            this.updateUI();
                            this.addLog(`Auto-sold ${rarity} item for ${sellPrice}g (filtered)`, 'loot');
                            continue;
                        }

                        this.loot.push(item);
                        this.floorStats.lootObtained++;
                        if (rarity === 'legendary') this.globalStats.legendariesFound++;
                        this.addLog(`Vault Guardian drops ${item.name}!`, 'loot');
                    }
                    return;
                }

                let shouldDrop = false;

                if (isBoss) {
                    // Bosses always drop exactly 1 item
                    shouldDrop = true;
                } else {
                    // Non-boss enemies have 5% drop chance
                    shouldDrop = Math.random() < 0.05;
            }

            if (shouldDrop) {
                // Check for Mythic drop from Treasure Guardian (0.1% chance)
                const isMythicDrop = enemy.name === 'Treasure Guardian' && Math.random() < 0.001;

                // Get loot table for current dungeon
                const baseLootTable = this.dungeonLootTables[this.currentDungeon];
                const lootTable = this.getFilteredLootTable(baseLootTable);

                // If no valid items can drop, skip loot generation
                if (lootTable.length === 0) return;

                const type = lootTable[Math.floor(Math.random() * lootTable.length)];

                let rarity;
                const roll = Math.random() * 100; // 0-100 for percentage

                // Determine item level - bosses drop +1 level items, mythics drop +5 levels
                const itemLevel = isMythicDrop ? this.dungeonFloor + 5 : (isBoss ? this.dungeonFloor + 1 : this.dungeonFloor);

                if (isMythicDrop) {
                    // Force mythic rarity
                    rarity = 'mythic';
                } else if (isBoss) {
                        // Boss rarity distribution
                        if (roll < 30) rarity = 'common';
                        else if (roll < 60) rarity = 'uncommon';
                        else if (roll < 90) rarity = 'rare';
                        else if (roll < 99) rarity = 'epic';
                        else rarity = 'legendary'; // 1%
                    } else {
    // Non-boss rarity distribution - improves slightly with floor
    const floorBonus = Math.min(this.dungeonFloor * 0.2, 20); // Up to +20% at floor 100

    // Common drops less, uncommon drops more
    if (roll < (69.9 - floorBonus)) rarity = 'common';
    else if (roll < 89.9) rarity = 'uncommon';
    else if (roll < 97.9) rarity = 'rare';
    else if (roll < 99.9) rarity = 'epic';
    else rarity = 'legendary';
}

                    // Check if this rarity is filtered out
                    if (!this.lootFilter[rarity]) {
                        // Auto-sell filtered items
                        const sellPrices = {
    common: 5,
    uncommon: 10,
    rare: 15,
    epic: 20,
    legendary: 25,
    mythic: 10000
};
                        const sellPrice = sellPrices[rarity] || 5;
                        this.gold += sellPrice;
                        this.floorStats.goldEarned += sellPrice;
                        this.updateUI();
                        this.addLog(`Auto-sold ${rarity} item for ${sellPrice}g (rarity filtered)`, 'loot');
                        return;
                    }

const item = new Item(type, rarity, itemLevel);

// Check if item level is below minimum
if (item.level < this.lootFilter.minLevel) {
    const sellPrices = {
    common: 5,
    uncommon: 10,
    rare: 15,
    epic: 20,
    legendary: 25,
    mythic: 10000
};
    const sellPrice = sellPrices[rarity] || 5;
    this.gold += sellPrice;
    this.floorStats.goldEarned += sellPrice;
    this.updateUI();
    this.addLog(`Auto-sold level ${item.level} item for ${sellPrice}g (level filtered)`, 'loot');
    return;
}

this.loot.push(item);
this.floorStats.lootObtained++; // Track loot
if (rarity === 'legendary') {
    this.globalStats.legendariesFound++;
}

// Track loot for Divine Arena summary
if (this.currentDungeon === 'endlessblessings' && this.endlessRunLoot) {
    this.endlessRunLoot.push(item);
}

// Auto-sell lowest gear score item if loot exceeds 50 items
if (this.loot.length > 50) {
    this.autoSellLowestGearScore();
}

this.addLog(`${enemy.name} drops ${item.name}!`, 'loot');
                }
            }

            showLoot() {
    // Hide any visible tooltips
    const lootTooltip = document.getElementById('loot-tooltip');
    if (lootTooltip) lootTooltip.classList.remove('show');

    const container = document.getElementById('loot-container');

    // Create array with items and their original indices
    let sortedLoot = this.loot.map((item, index) => ({ item, index }));

    if (this.lootSortBy.length > 0) {
        sortedLoot.sort((a, b) => {
            const rarityOrder = { 'common': 0, 'rare': 1, 'epic': 2, 'legendary': 3, 'mythic': 4 };

            // Helper to get rarity score (perfect mythics get higher score)
            const getRarityScore = (item) => {
                let score = rarityOrder[item.rarity] || 0;
                if (item.rarity === 'mythic' && item.mythicStats && item.mythicStats.length === 4) {
                    score += 0.5; // Perfect mythics rank higher
                }
                return score;
            };

            // If both filters active, prioritize rarity then level
            if (this.lootSortBy.includes('rarity') && this.lootSortBy.includes('level')) {
                const rarityDiff = getRarityScore(b.item) - getRarityScore(a.item);
                if (rarityDiff !== 0) {
                    return rarityDiff;
                }
                return b.item.level - a.item.level;
            }

            // Single filter
            if (this.lootSortBy.includes('rarity')) {
                return getRarityScore(b.item) - getRarityScore(a.item);
            }
            if (this.lootSortBy.includes('level')) {
                return b.item.level - a.item.level;
            }

            return 0;
        });
    }

    if (sortedLoot.length === 0) {
        container.innerHTML = '<div style="color: #888; text-align: center; padding: 20px;">No loot available</div>';
        return;
    }

    // Proper cleanup of old elements and listeners
    while (container.firstChild) {
        container.removeChild(container.firstChild);
    }

                sortedLoot.forEach(({ item, index: i }) => {
                    const div = document.createElement('div');
                    div.className = `loot-item ${item.rarity}`;
                    div.style.borderColor = this.getRarityColor(item.rarity);

                    const sellPrices = {
    common: 5,
    uncommon: 10,
    rare: 15,
    epic: 20,
    legendary: 25,
    mythic: 10000
};
                    const sellPrice = sellPrices[item.rarity] || 5;

                    div.innerHTML = `
                        <div style="font-size: 13px; font-weight: 600; margin-bottom: 3px; line-height: 1.2;">${item.name}</div>
                        <div style="font-size: 10px; color: #e2e8f0; line-height: 1.4; margin-bottom: 6px; font-weight: 500;">${item.getStatsDisplay()}</div>
                        <div class="loot-item-actions">
                            <select class="loot-item-select" style="flex: 2; padding: 4px 6px; background: rgba(30, 41, 59, 0.9); color: #e2e8f0; border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; font-family: 'Rajdhani', sans-serif; font-size: 10px; cursor: pointer;">
                                <option value="auto">Auto-Equip Best</option>
                                ${this.party.map((m, idx) => `<option value="${idx}">${m.name}${!m.isAlive ? ' (Dead)' : ''}</option>`).join('')}
                            </select>
                            <button class="loot-item-btn equip-btn" style="flex: 1;">Equip</button>
                            <button class="loot-item-btn sell-btn" style="flex: 1;">Sell ${sellPrice}g</button>
                        </div>
                    `;


// Track dropdown changes for tooltip stability
                    div.querySelector('.loot-item-select').addEventListener('change', (e) => {
                        div._lastSelectedValue = e.target.value;
                    });

// Equip button
div.querySelector('.equip-btn').onclick = (e) => {
    e.stopPropagation();
    const selectedChar = div._lastSelectedValue || div.querySelector('.loot-item-select').value;
    if (selectedChar === 'auto') {
        this.equipItem(item, i);
    } else {
        this.equipItemToCharacter(item, i, parseInt(selectedChar));
    }
};

                    // Sell button
                    div.querySelector('.sell-btn').onclick = (e) => {
                        e.stopPropagation();
                        this.sellItem(item, i, 'loot');
                    };

                    // Add comparison tooltip
                    div.addEventListener('mouseenter', (e) => {
                        this.showLootComparison(item, e);
                    });

                    div.addEventListener('mouseleave', () => {
                        document.getElementById('loot-tooltip').classList.remove('show');
                    });

                    container.appendChild(div);
                });

                // Add event listeners to equip buttons
                document.querySelectorAll('[data-keystone-index]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const index = parseInt(btn.getAttribute('data-keystone-index'));
                        this.equipKeystone(index);
                    });
                });

                // Add event listeners to sell buttons
        document.querySelectorAll('[data-sell-keystone]').forEach(btn => {
            btn.addEventListener('click', () => {
                const index = parseInt(btn.getAttribute('data-sell-keystone'));
                this.sellKeystone(index);
            });
        });

        // Add tooltip event listeners for all keystone icons
        document.querySelectorAll('.keystone-icon[data-keystone-info]').forEach(icon => {
            icon.addEventListener('mouseenter', (e) => {
                const data = JSON.parse(icon.getAttribute('data-keystone-info'));
                this.showKeystoneTooltip(data, e);
            });

            icon.addEventListener('mouseleave', () => {
                document.getElementById('equipment-tooltip').classList.remove('show');
            });
        });
    }calculateGearScore(item) {
                let score = 0;

                // Base score from item level (1 point per level)
                score += item.level;

                // Rarity multipliers
                const rarityScores = {
                    common: 1,
                    uncommon: 2,
                    rare: 3,
                    epic: 4,
                    legendary: 6,
                    mythic: 10
                };
                score *= (rarityScores[item.rarity] || 1);

                // Add stat values
                const statProps = ['attack', 'attackSpeed', 'hp', 'mana', 'defense', 'critChance', 'critDamage', 'dodgeChance', 'lifesteal', 'hpRegen', 'manaRegen', 'cdr'];
                statProps.forEach(stat => {
                    if (item[stat]) {
                        score += item[stat];
                    }
                });

                return Math.floor(score);
            }

            autoSellLowestGearScore() {
                if (this.loot.length === 0) return;

                // Calculate gear scores for all items
                const itemsWithScores = this.loot.map((item, index) => ({
                    item: item,
                    index: index,
                    score: this.calculateGearScore(item)
                }));

                // Sort by gear score (lowest first)
                itemsWithScores.sort((a, b) => a.score - b.score);

                // Get the lowest gear score item
                const lowestItem = itemsWithScores[0];
                const sellPrices = {
                    common: 5,
                    uncommon: 10,
                    rare: 15,
                    epic: 20,
                    legendary: 25,
                    mythic: 10000
                };
                const sellPrice = sellPrices[lowestItem.item.rarity] || 5;

                // Remove from loot array
                this.loot.splice(lowestItem.index, 1);

                // Add gold
                this.gold += sellPrice;

                this.addLog(`Auto-sold ${lowestItem.item.name} for ${sellPrice}g (lowest gear score: ${lowestItem.score})`, 'loot');
                this.updateUI();
            }
generateRuneTabs() {
    const container = document.getElementById('rune-char-tabs-container');
    if (!container) return;

    container.innerHTML = '';

    const charImages = {
        tank: 'tank.png',
        healer: 'healer.png',
        mage: 'mage.png',
        rogue: 'rogue.png',
        archer: 'archer.png',
        paladin: 'paladin.png'
    };

    // Generate tabs for each party member
    this.party.forEach((char, index) => {
        const charType = char.className.toLowerCase();
        const button = document.createElement('button');
        button.className = 'rune-char-tab' + (index === 0 ? ' active' : '');
        button.setAttribute('data-rune-char', charType);
        button.innerHTML = `<img src="${charImages[charType]}" alt="${char.className}">`;
        container.appendChild(button);
    });

    // Setup event listeners for the new tabs
    document.querySelectorAll('.rune-char-tab').forEach(tab => {
        tab.addEventListener('click', () => {
            // Remove active from all tabs
            document.querySelectorAll('.rune-char-tab').forEach(t => t.classList.remove('active'));

            // Activate clicked tab
            tab.classList.add('active');
            const charType = tab.getAttribute('data-rune-char');
            this.showRunesForCharacter(charType);
        });
    });
}
showKeystones() {
    // Hide any visible tooltips
    const lootTooltip = document.getElementById('loot-tooltip');
    if (lootTooltip) lootTooltip.classList.remove('show');
    const equipTooltip = document.getElementById('equipment-tooltip');
    if (equipTooltip) equipTooltip.classList.remove('show');

    // Update slots display
    const slotsGrid = document.getElementById('keystone-slots-grid');
    if (slotsGrid) {
        slotsGrid.innerHTML = '';

        // Only show slots for characters in the party
        const slotTypes = this.party.map(char => char.className.toLowerCase());
        const slotIcons = { tank: 'üõ°Ô∏è', healer: 'üíä', mage: 'üîÆ', rogue: 'üó°Ô∏è', archer: 'üèπ', paladin: '‚öîÔ∏è' };
        const slotNames = { tank: 'Tank', healer: 'Healer', mage: 'Mage', rogue: 'Rogue', archer: 'Archer', paladin: 'Paladin' };

        slotTypes.forEach(type => {
            const slotDiv = document.createElement('div');
            const isUnlocked = this.keystoneSlots[type];
            const equipped = this.equippedKeystones[type];

            slotDiv.style.cssText = 'background: rgba(30, 41, 59, 0.6); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; padding: 10px; text-align: center;';

            if (!equipped) {
                slotDiv.innerHTML = `
                    <div class="keystone-icon empty"></div>
                    <div style="font-size: 11px; color: #94a3b8; margin-top: 5px;">${slotNames[type]}</div>
                    <div style="font-size: 9px; color: #64748b;">Empty</div>
                `;
            } else {
                const keystoneData = {
                    name: equipped.name,
                    ability: equipped.ability.name,
                    description: equipped.ability.description,
                    cooldown: equipped.ability.cooldown,
                    manaCost: equipped.ability.manaCost,
                    stats: equipped.getStatsDisplay(),
                    rarity: equipped.rarity
                };

                slotDiv.innerHTML = `
                    <div class="keystone-icon ${equipped.internalName} rarity-${equipped.rarity}"></div>
                    <div style="font-size: 10px; color: #f59e0b; font-weight: 600;">Lvl ${equipped.level}</div>
                    <div style="font-size: 9px; color: #94a3b8;">${equipped.ability.name}</div>
                    <button class="unequip-keystone-btn" data-keystone-type="${type}" style="margin-top: 5px; padding: 3px 8px; font-size: 9px; background: #ef4444; border: none; border-radius: 4px; color: white; cursor: pointer;">Unequip</button>
                `;

                // Add tooltip listener directly to the icon after adding to DOM
                const icon = slotDiv.querySelector('.keystone-icon');
                icon.addEventListener('mouseenter', (e) => {
                    this.showKeystoneTooltip(keystoneData, e);
                });
                icon.addEventListener('mouseleave', () => {
                    document.getElementById('equipment-tooltip').classList.remove('show');
                });
            }

            slotsGrid.appendChild(slotDiv);
        });

        // Add unequip event listeners
        document.querySelectorAll('.unequip-keystone-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const type = btn.getAttribute('data-keystone-type');
                this.unequipKeystone(type);
            });
        });
    }

    // Update inventory display
    const container = document.getElementById('keystone-list');
    if (!container) return;

    if (this.keystones.length === 0) {
        container.innerHTML = '<div style="color: #888; text-align: center; padding: 20px;">No keystones found</div>';
        return;
    }

    // Proper cleanup of old elements and listeners
    while (container.firstChild) {
        container.removeChild(container.firstChild);
    }

    this.keystones.forEach((keystone, index) => {
        const div = document.createElement('div');
        div.className = `loot-item ${keystone.rarity}`;

        const typeIcons = { tank: 'üõ°Ô∏è', healer: 'üíä', mage: 'üîÆ', rogue: 'üó°Ô∏è', archer: 'üèπ', paladin: '‚öîÔ∏è' };
        const typeNames = { tank: 'Tank', healer: 'Healer', mage: 'Mage', rogue: 'Rogue', archer: 'Archer', paladin: 'Paladin' };
        const typeColors = {
            tank: '#6b7280',
            healer: '#10b981',
            mage: '#52525b',
            rogue: '#ef4444',
            archer: '#f59e0b',
            paladin: '#3b82f6'
        };

        div.innerHTML = `
            <div style="display: flex; gap: 12px; align-items: center; margin-bottom: 8px;">
                <div class="keystone-icon ${keystone.internalName} rarity-${keystone.rarity}" style="width: 50px; height: 50px; flex-shrink: 0;" data-keystone-info='${JSON.stringify({
                    name: keystone.name,
                    ability: keystone.ability.name,
                    description: keystone.ability.description,
                    cooldown: keystone.ability.cooldown,
                    manaCost: keystone.ability.manaCost,
                    stats: keystone.getStatsDisplay(),
                    rarity: keystone.rarity
                })}'></div>
                <div style="flex: 1;">
                    <div style="font-weight: 700; font-size: 13px; color: ${this.getRarityColor(keystone.rarity)};">
                        ${keystone.name}
                    </div>
                    <div style="display: inline-block; padding: 2px 8px; background: ${typeColors[keystone.type]}; border-radius: 4px; font-size: 10px; font-weight: 600; color: #fff; margin-top: 4px;">
                        ${typeIcons[keystone.type]} ${typeNames[keystone.type]}
                    </div>
                </div>
            </div>
            <div style="font-size: 11px; color: #f59e0b; margin-bottom: 6px; font-weight: 600;">
                ${keystone.ability.name} (${keystone.ability.cooldown}s CD | ${keystone.ability.manaCost === 0 ? '<span style="color: #10b981;">Free</span>' : keystone.ability.manaCost + ' Mana'})
            </div>
            <div style="font-size: 10px; color: #94a3b8; margin-bottom: 8px;">
                ${keystone.ability.description}
            </div>
            <div style="font-size: 11px; color: #e2e8f0; margin-bottom: 8px;">
                ${keystone.getStatsDisplay()}
            </div>
            <div class="loot-item-actions">
                <button class="loot-item-btn equip-btn" data-keystone-index="${index}" ${this.equippedKeystones[keystone.type] ? 'disabled' : ''}>
                    Equip
                </button>
                <button class="loot-item-btn sell-btn" data-sell-keystone="${index}">
                    Sell ${keystone.getSellPrice()}g
                </button>
            </div>
        `;

        container.appendChild(div);
    });

    // Add event listeners to equip buttons
    document.querySelectorAll('[data-keystone-index]').forEach(btn => {
        btn.addEventListener('click', () => {
            const index = parseInt(btn.getAttribute('data-keystone-index'));
            this.equipKeystone(index);
        });
    });

    // Add event listeners to sell buttons
    document.querySelectorAll('[data-sell-keystone]').forEach(btn => {
        btn.addEventListener('click', () => {
            const index = parseInt(btn.getAttribute('data-sell-keystone'));
            this.sellKeystone(index);
        });
    });
}

showKeystoneTooltip(data, event) {
                const tooltip = document.getElementById('equipment-tooltip');

                let tooltipHTML = `
                    <div class="tooltip-header ${data.rarity}">${data.name}</div>
                    <div class="tooltip-stats">
                        <div style="font-weight: 700; color: #f59e0b; margin-bottom: 8px; font-size: 13px;">
                            ${data.ability}
                        </div>
                        <div style="color: #94a3b8; margin-bottom: 8px; font-size: 12px; line-height: 1.4;">
                            ${data.description}
                        </div>
                        <div style="color: #a855f7; margin-bottom: 8px; font-size: 11px;">
                            Cooldown: ${data.cooldown}s | Mana Cost: ${data.manaCost === 0 ? '<span style="color: #10b981;">Free</span>' : data.manaCost}
                        </div>
                `;

                if (data.stats && data.stats !== 'No stats') {
                    tooltipHTML += `
                        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(99, 102, 241, 0.3);">
                            <div style="color: #e2e8f0; font-size: 11px;">
                                ${data.stats}
                            </div>
                        </div>
                    `;
                }

                tooltipHTML += `</div>`;

                tooltip.innerHTML = tooltipHTML;
                tooltip.classList.add('show');

                // Position tooltip
                const rect = event.target.getBoundingClientRect();
                const tooltipWidth = 300;
                const tooltipHeight = 200;
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;

                if (rect.right + tooltipWidth + 10 > screenWidth) {
                    tooltip.style.left = `${rect.left - tooltipWidth - 10}px`;
                } else {
                    tooltip.style.left = `${rect.right + 10}px`;
                }

                if (rect.bottom + tooltipHeight + 10 > screenHeight) {
                    tooltip.style.top = `${rect.top - tooltipHeight - 10}px`;
                } else {
                    tooltip.style.top = `${rect.top}px`;
                }
            }

            equipKeystone(index) {
                const keystone = this.keystones[index];
                if (!keystone) return;

                // ... rest of equipKeystone function continues here

    // Check if slot already has keystone
    if (this.equippedKeystones[keystone.type]) {
        this.addLog(`${keystone.type} slot already has a keystone equipped!`, 'damage');
        return;
    }

    // Equip keystone
    this.equippedKeystones[keystone.type] = keystone;
    this.keystones.splice(index, 1);

    // Apply keystone stats to the corresponding character
    const member = this.party.find(m => m.className.toLowerCase() === keystone.type);
    if (member && keystone.stats) {
        // Store current HP/Mana percentages
        const hpPercent = member.hp / member.maxHp;
        const manaPercent = member.mana / member.maxMana;

        // Apply stats
        for (const [stat, value] of Object.entries(keystone.stats)) {
            if (stat === 'hp') {
                member.maxHp += value;
            } else if (stat === 'mana') {
                member.maxMana += value;
            } else if (stat === 'attack') {
                member.attack += value;
            } else if (stat === 'defense') {
                member.defense += value;
            } else if (stat === 'attackSpeed') {
                member.attackSpeed += value / 100;
            } else if (stat === 'critChance') {
                member.critChance += value;
            } else if (stat === 'critDamage') {
                member.critDamage += value;
            } else if (stat === 'dodge') {
                member.dodgeChance += value;
            } else if (stat === 'lifesteal') {
                member.lifesteal += value;
            } else if (stat === 'hpRegen') {
                member.hpRegen += value;
            } else if (stat === 'manaRegen') {
                member.manaRegen += value;
            } else if (stat === 'cdr') {
                member.cdr += value;
            }
        }

        // Restore HP/Mana percentages
        member.hp = Math.floor(member.maxHp * hpPercent);
        member.mana = Math.floor(member.maxMana * manaPercent);
    }

    this.addLog(`Equipped ${keystone.name}!`, 'loot');
    this.rebuildUI();
    this.showKeystones();
}

            showRunesForCharacter(charType) {
                const slotsGrid = document.getElementById('rune-slots-grid');
                const runeList = document.getElementById('rune-list');

                if (!slotsGrid || !runeList) return;

                // Debug: Log current state
                console.log(`Showing runes for ${charType}:`, {
                    slots: this.runeSlots[charType],
                    equipped: this.equippedRunes[charType]
                });

                // Clear existing content
                slotsGrid.innerHTML = '';
                runeList.innerHTML = '';

                // Show equipped rune slots
                for (let i = 0; i < 5; i++) {
                    const slotDiv = document.createElement('div');
                    const isUnlocked = this.runeSlots[charType][i];
                    const equippedRune = this.equippedRunes[charType][i];

                    if (i === 4) {
                        slotDiv.style.gridColumn = '1 / -1';
                    }

                    if (!isUnlocked) {
                        slotDiv.style.cssText = (i === 4 ? 'grid-column: 1 / -1; ' : '') + 'background: rgba(30, 41, 59, 0.6); border: 2px dashed rgba(100, 116, 139, 0.3); border-radius: 8px; padding: 12px; text-align: center;';
                        slotDiv.innerHTML = `
                            <div style="font-size: 28px; margin-bottom: 5px; opacity: 0.3;">?</div>
                            <div style="font-size: 9px; color: #64748b;">Slot ${i + 1}</div>
                            <div style="font-size: 8px; color: #475569; margin-top: 3px;">Unlock in Skill Tree</div>
                        `;
                    } else if (!equippedRune) {
                        slotDiv.style.cssText = (i === 4 ? 'grid-column: 1 / -1; ' : '') + 'background: rgba(30, 41, 59, 0.6); border: 2px solid rgba(168, 85, 247, 0.3); border-radius: 8px; padding: 12px; text-align: center; cursor: pointer;';
                        slotDiv.innerHTML = `
                            <div style="font-size: 28px; margin-bottom: 5px; color: #a855f7;">üíé</div>
                            <div style="font-size: 9px; color: #a855f7;">Slot ${i + 1}</div>
                            <div style="font-size: 8px; color: #94a3b8; margin-top: 3px;">Empty</div>
                        `;
                    } else {
                        slotDiv.style.cssText = (i === 4 ? 'grid-column: 1 / -1; ' : '') + 'background: rgba(168, 85, 247, 0.15); border: 2px solid #a855f7; border-radius: 8px; padding: 10px; text-align: center;';
                        slotDiv.innerHTML = `
                            <div style="font-size: 11px; font-weight: 700; color: ${this.getRarityColor(equippedRune.rarity)}; margin-bottom: 3px;">${equippedRune.name}</div>
                            <div style="font-size: 9px; color: #e2e8f0; margin-bottom: 5px;">${equippedRune.getStatsDisplay()}</div>
                            <button class="unequip-rune-btn" data-char="${charType}" data-slot="${i}" style="padding: 3px 10px; font-size: 8px; background: #ef4444; border: none; border-radius: 4px; color: white; cursor: pointer; font-weight: 600;">Unequip</button>
                        `;
                    }

                    slotsGrid.appendChild(slotDiv);
                }

                // Add unequip event listeners
                document.querySelectorAll('.unequip-rune-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const char = btn.getAttribute('data-char');
                        const slot = parseInt(btn.getAttribute('data-slot'));
                        this.unequipRune(char, slot);
                    });
                });

                // Show rune inventory
                if (this.runes.length === 0) {
                    runeList.innerHTML = '<div style="color: #64748b; text-align: center; padding: 30px; font-size: 12px; font-style: italic;">No Runes found<br><span style="font-size: 10px;">Unlock Rune Slots in the Skill Tree</span></div>';
                    return;
                }

                this.runes.forEach((rune, index) => {
                    const div = document.createElement('div');
                    div.className = `loot-item ${rune.rarity}`;

                    // Check if rune is already equipped
                    const isEquipped = this.equippedRunes[charType].some(r => r === rune);

                    div.innerHTML = `
                        <div style="font-weight: 700; font-size: 13px; color: #3b82f6; margin-bottom: 5px;">
                            ${rune.emoji} ${rune.name}
                            ${isEquipped ? '<span class="rune-equipped-indicator">EQUIPPED</span>' : ''}
                        </div>
                        <div style="font-size: 11px; color: #e2e8f0; margin-bottom: 8px;">
                            ${rune.getStatsDisplay()}
                        </div>
                        <div class="loot-item-actions">
                            <button class="loot-item-btn equip-btn" data-rune-index="${index}" ${isEquipped ? 'disabled' : ''} ${!this.runeSlots[charType].some(s => s) ? 'style="opacity: 0.5; cursor: not-allowed;"' : ''}>
                                ${this.runeSlots[charType].some(s => s) ? 'Equip' : 'No Slots'}
                            </button>
                            <button class="loot-item-btn sell-btn" data-sell-rune="${index}">
                                Sell ${rune.getSellPrice()}g
                            </button>
                        </div>
                    `;

                    runeList.appendChild(div);
                });

                // Add equip event listeners
                document.querySelectorAll('[data-rune-index]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const index = parseInt(btn.getAttribute('data-rune-index'));
                        this.equipRune(charType, index);
                    });
                });

                // Add sell event listeners
                document.querySelectorAll('[data-sell-rune]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const index = parseInt(btn.getAttribute('data-sell-rune'));
                        this.sellRune(index);
                    });
                });
            }

            equipRune(charType, runeIndex) {
                const rune = this.runes[runeIndex];
                if (!rune) return;

                // Check if character has any unlocked slots
                const hasUnlockedSlot = this.runeSlots[charType].some(slot => slot === true);
                if (!hasUnlockedSlot) {
                    this.addLog(`No rune slots unlocked for ${charType}! Unlock slots in the Skill Tree.`, 'damage');
                    return;
                }

                // Find first available unlocked slot
                let slotIndex = -1;
                for (let i = 0; i < 5; i++) {
                    if (this.runeSlots[charType][i] && !this.equippedRunes[charType][i]) {
                        slotIndex = i;
                        break;
                    }
                }

                if (slotIndex === -1) {
                    this.addLog('All rune slots are full!', 'damage');
                    return;
                }

                // Equip the rune
                this.equippedRunes[charType][slotIndex] = rune;
                this.runes.splice(runeIndex, 1);

                // Apply rune stats to character
                const member = this.party.find(m => m.className.toLowerCase() === charType);
                if (member) {
                    // Store current HP/Mana percentages
                    const hpPercent = member.hp / member.maxHp;
                    const manaPercent = member.mana / member.maxMana;

                    // Ability runes don't modify stats - they enhance abilities during use
                    if (rune.isAbilityRune) {
                        // No stat changes needed
                    } else if (rune.statType) {
                        // Stat runes apply percentage bonuses - store the bonus on the member
                        if (!member.runePercentBonuses) member.runePercentBonuses = {};

                        // Track the bonus (we'll recalculate in getTotalX functions)
                        if (!member.runePercentBonuses[rune.statType]) {
                            member.runePercentBonuses[rune.statType] = 0;
                        }
                        member.runePercentBonuses[rune.statType] += rune.percentBonus;

                        // Handle secondary stat for crit runes
                        if (rune.secondaryStatType) {
                            if (!member.runePercentBonuses[rune.secondaryStatType]) {
                                member.runePercentBonuses[rune.secondaryStatType] = 0;
                            }
                            member.runePercentBonuses[rune.secondaryStatType] += rune.secondaryPercentBonus;
                        }
                    }

                    // Restore HP/Mana percentages
                    member.hp = Math.floor(member.maxHp * hpPercent);
                    member.mana = Math.floor(member.maxMana * manaPercent);
                }

                this.addLog(`Equipped ${rune.name} to ${charType}!`, 'loot');
                this.rebuildUI();
                this.showRunesForCharacter(charType);
            }

            unequipRune(charType, slotIndex) {
                const rune = this.equippedRunes[charType][slotIndex];
                if (!rune) return;

                // Remove rune stats from character
                const member = this.party.find(m => m.className.toLowerCase() === charType);
                if (member) {
                    // Store current HP/Mana percentages
                    const hpPercent = member.hp / member.maxHp;
                    const manaPercent = member.mana / member.maxMana;

                    // Ability runes don't modify stats
                    if (rune.isAbilityRune) {
                        // No stat changes needed
                    } else if (rune.statType && member.runePercentBonuses) {
                        // Remove percentage bonus
                        if (member.runePercentBonuses[rune.statType]) {
                            member.runePercentBonuses[rune.statType] -= rune.percentBonus;
                            if (member.runePercentBonuses[rune.statType] <= 0) {
                                delete member.runePercentBonuses[rune.statType];
                            }
                        }

                        // Handle secondary stat for crit runes
                        if (rune.secondaryStatType && member.runePercentBonuses[rune.secondaryStatType]) {
                            member.runePercentBonuses[rune.secondaryStatType] -= rune.secondaryPercentBonus;
                            if (member.runePercentBonuses[rune.secondaryStatType] <= 0) {
                                delete member.runePercentBonuses[rune.secondaryStatType];
                            }
                        }
                    }

                    // Restore HP/Mana percentages
                    member.hp = Math.floor(member.maxHp * hpPercent);
                    member.mana = Math.floor(member.maxMana * manaPercent);
                }

                // Unequip and return to inventory
                this.equippedRunes[charType][slotIndex] = null;
                this.runes.push(rune);

                this.addLog(`Unequipped ${rune.name}`, 'loot');
                this.rebuildUI();
                this.showRunesForCharacter(charType);
            }

            sellRune(index) {
                const rune = this.runes[index];
                if (!rune) return;

                const sellPrice = rune.getSellPrice();
                this.gold += sellPrice;
                this.runes.splice(index, 1);

                this.addLog(`Sold ${rune.name} for ${sellPrice}g`, 'loot');

                // Refresh the current character's rune view
                const activeTab = document.querySelector('.rune-char-tab.active');
                if (activeTab) {
                    const charType = activeTab.getAttribute('data-rune-char');
                    this.showRunesForCharacter(charType);
                }

                this.updateUI();
            }

            unequipKeystone(type) {
                const keystone = this.equippedKeystones[type];
                if (!keystone) return;

                // Remove keystone stats from the corresponding character
                const member = this.party.find(m => m.className.toLowerCase() === type);
                if (member && keystone.stats) {
                    // Store current HP/Mana percentages
                    const hpPercent = member.hp / member.maxHp;
                    const manaPercent = member.mana / member.maxMana;

                    // Remove stats
                    for (const [stat, value] of Object.entries(keystone.stats)) {
                        if (stat === 'hp') {
                            member.maxHp -= value;
                        } else if (stat === 'mana') {
                            member.maxMana -= value;
                        } else if (stat === 'attack') {
                            member.attack -= value;
                        } else if (stat === 'defense') {
                            member.defense -= value;
                        } else if (stat === 'attackSpeed') {
                            member.attackSpeed -= value / 100;
                        } else if (stat === 'critChance') {
                            member.critChance -= value;
                        } else if (stat === 'critDamage') {
                            member.critDamage -= value;
                        } else if (stat === 'dodge') {
                            member.dodgeChance -= value;
                        } else if (stat === 'lifesteal') {
                            member.lifesteal -= value;
                        } else if (stat === 'hpRegen') {
                            member.hpRegen -= value;
                        } else if (stat === 'manaRegen') {
                            member.manaRegen -= value;
                        } else if (stat === 'cdr') {
                            member.cdr -= value;
                        }
                    }

                    // Restore HP/Mana percentages
                    member.hp = Math.floor(member.maxHp * hpPercent);
                    member.mana = Math.floor(member.maxMana * manaPercent);
                }

                // Unequip and return to inventory
                this.equippedKeystones[type] = null;
                this.keystones.push(keystone);

                this.addLog(`Unequipped ${keystone.name}`, 'loot');
                this.rebuildUI();
                this.showKeystones();
            }








            sellKeystone(index) {
                const keystone = this.keystones[index];
                if (!keystone) return;

                const sellPrice = keystone.getSellPrice();
                this.gold += sellPrice;
                this.keystones.splice(index, 1);

                this.addLog(`Sold ${keystone.name} for ${sellPrice}g`, 'loot');
                this.showKeystones();
                this.updateUI();
            }

            showChests() {
    // === RUNE TRIAL KEYS ===
    const runeKeysGrid = document.getElementById('rune-trial-keys-grid');
    const noRuneKeysMsg = document.getElementById('no-rune-keys');

    if (runeKeysGrid) {
        runeKeysGrid.innerHTML = '';

        if (this.runeTrialKeys.length === 0) {
            if (noRuneKeysMsg) noRuneKeysMsg.style.display = 'block';
        } else {
            if (noRuneKeysMsg) noRuneKeysMsg.style.display = 'none';

            this.runeTrialKeys.forEach(key => {
                const keyCard = document.createElement('div');
                keyCard.className = 'vault-key-card';
                keyCard.style.borderColor = '#3b82f6';
                keyCard.style.background = 'linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(37, 99, 235, 0.1))';

                keyCard.innerHTML = `
                    <div style="font-size: 20px; margin-bottom: 3px; filter: drop-shadow(0 2px 4px rgba(59, 130, 246, 0.5));"></div>
                    <div style="font-size: 11px; font-weight: 800; color: #60a5fa; font-family: 'Orbitron', sans-serif; margin-bottom: 4px;">TIER ${key.tier}</div>
                    <button class="vault-enter-btn" style="width: 100%; padding: 3px; font-size: 7px; background: linear-gradient(135deg, #3b82f6, #2563eb); border: none; border-radius: 3px; color: #fff; font-weight: 700; cursor: pointer; font-family: 'Orbitron', sans-serif; margin-bottom: 2px;">GO</button>
                    <button class="vault-sell-btn" style="width: 100%; padding: 3px; font-size: 7px; background: linear-gradient(135deg, #ef4444, #dc2626); border: none; border-radius: 3px; color: #fff; font-weight: 700; cursor: pointer; font-family: 'Orbitron', sans-serif;">SELL</button>
                `;

                keyCard.querySelector('.vault-enter-btn').onclick = (e) => {
                    e.stopPropagation();
                    this.showRuneTrialConfirmation(key);
                };

                keyCard.querySelector('.vault-sell-btn').onclick = (e) => {
                    e.stopPropagation();
                    this.sellRuneTrialKey(key.id);
                };

                runeKeysGrid.appendChild(keyCard);
            });
        }
    }

    // === VAULT KEYS ===
    const vaultKeysGrid = document.getElementById('vault-keys-grid');
    const noVaultKeysMsg = document.getElementById('no-keys');

    vaultKeysGrid.innerHTML = '';

    if (this.vaultKeys.length === 0) {
        noVaultKeysMsg.style.display = 'block';
    } else {
        noVaultKeysMsg.style.display = 'none';

        this.vaultKeys.forEach(key => {
            const vaultCard = document.createElement('div');
            vaultCard.className = 'vault-key-card';
            vaultCard.setAttribute('title', 'Vault is 5x harder!\nDefeat boss to earn Keystone');

            vaultCard.innerHTML = `
                <div style="font-size: 11px; font-weight: 800; color: #fbbf24; font-family: 'Orbitron', sans-serif; margin-bottom: 4px;">LVL ${key.level}</div>
                <button class="vault-enter-btn" style="width: 100%; padding: 3px; font-size: 7px; background: linear-gradient(135deg, #10b981, #059669); border: none; border-radius: 3px; color: #fff; font-weight: 700; cursor: pointer; font-family: 'Orbitron', sans-serif; margin-bottom: 2px;">GO</button>
                <button class="vault-sell-btn" style="width: 100%; padding: 3px; font-size: 7px; background: linear-gradient(135deg, #ef4444, #dc2626); border: none; border-radius: 3px; color: #fff; font-weight: 700; cursor: pointer; font-family: 'Orbitron', sans-serif;">SELL</button>
            `;

            vaultCard.querySelector('.vault-enter-btn').onclick = (e) => {
                e.stopPropagation();
                this.showVaultKeyConfirmDialog(key, () => {
                    this.enterVaultWithKeyConfirmed(key.id);
                });
            };

            vaultCard.querySelector('.vault-sell-btn').onclick = (e) => {
                e.stopPropagation();
                this.sellVaultKey(key.id);
            };

            vaultKeysGrid.appendChild(vaultCard);
        });
    }

    // === CHESTS ===
    const chestsGrid = document.getElementById('chests-grid');
    const noChestsMsg = document.getElementById('no-chests');

    chestsGrid.innerHTML = '';

    if (this.playerChests.length === 0) {
        noChestsMsg.style.display = 'block';
    } else {
        noChestsMsg.style.display = 'none';

        const dungeonNames = {
            umbral: 'Umbral',
            everfall: 'Everfall',
            stoneforge: 'Stoneforge'
        };

        this.playerChests.forEach(chest => {
    const chestCard = document.createElement('div');
    chestCard.className = chest.isMythic ? 'chest-card mythic-chest' : 'chest-card';
    const canAfford = this.gold >= chest.openCost;

    // Build odds display based on chest type
    // Format numbers with commas
function formatGold(amount) {
    return amount.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

let oddsHTML = '';
if (chest.isMythic) {
    oddsHTML = '<span style="color: #d8b4fe;">E ' + chest.rarityOdds.epic + '%</span> ‚Ä¢ <span style="color: #fbbf24;">L ' + chest.rarityOdds.legendary + '%</span> ‚Ä¢ <span style="color: #f0abfc;">M ' + chest.rarityOdds.mythic + '%</span>';
} else {
    oddsHTML = '<span style="color: #60a5fa;">R ' + chest.rarityOdds.rare + '%</span> ‚Ä¢ <span style="color: #c084fc;">E ' + chest.rarityOdds.epic + '%</span> ‚Ä¢ <span style="color: #fbbf24;">L ' + chest.rarityOdds.legendary + '%</span>';
}

let chestImage = chest.isMythic ? 'chest%20mythic.png' : 'chest.png';

let imageBackgroundStyle = chest.isMythic ? 'background: radial-gradient(circle, rgba(168, 85, 247, 0.3) 0%, rgba(168, 85, 247, 0.1) 50%, transparent 100%); padding: 8px; border-radius: 8px;' : '';

chestCard.innerHTML = '<div style="margin-bottom: 4px; ' + imageBackgroundStyle + '"><img src="' + chestImage + '" style="width: 48px; height: 48px;"></div><div class="chest-level">LVL ' + chest.level + '</div><div class="chest-odds">' + oddsHTML + '</div><div class="chest-actions"><button class="chest-btn open" ' + (!canAfford ? 'disabled' : '') + '>OPEN<br>' + formatGold(chest.openCost) + '</button><button class="chest-btn sell">SELL<br>' + formatGold(chest.sellValue) + '</button></div>';

    chestCard.querySelector('.chest-btn.open').onclick = () => this.openChest(chest.id);
    chestCard.querySelector('.chest-btn.sell').onclick = () => this.sellChest(chest.id);

    chestsGrid.appendChild(chestCard);
});
    }
}

            openChest(chestId) {
    const chestIndex = this.playerChests.findIndex(c => c.id === chestId);
    if (chestIndex === -1) return;

    const chest = this.playerChests[chestIndex];

    // Check if player has enough gold
    if (this.gold < chest.openCost) {
        this.addLog('Not enough gold to open chest', 'damage');
        return;
    }

    // Deduct gold
    this.gold -= chest.openCost;
    this.updateUI();

    // Show opening animation
    this.showChestOpeningAnimation(chest, chestIndex);
}

showChestOpeningAnimation(chest, chestIndex) {
    // Roll rarity based on chest's odds
const roll = Math.random() * 100;
let rarity;

if (chest.isMythic) {
    // Mythic chest: epic 50%, legendary 49.9%, mythic 0.1%
    if (roll < chest.rarityOdds.mythic) {
        rarity = 'mythic';
    } else if (roll < chest.rarityOdds.mythic + chest.rarityOdds.legendary) {
        rarity = 'legendary';
    } else {
        rarity = 'epic';
    }
} else {
    // Regular chest: rare 75%, epic 20%, legendary 5%
    if (roll < chest.rarityOdds.legendary) {
        rarity = 'legendary';
    } else if (roll < chest.rarityOdds.legendary + chest.rarityOdds.epic) {
        rarity = 'epic';
    } else {
        rarity = 'rare';
    }

}

                // All possible gear slots (ignore dungeon restrictions for chests)
                const allSlots = ['helmet', 'chest', 'gloves', 'boots', 'belt', 'amulet', 'ring', 'wand', 'dagger', 'greatsword', 'staff', 'bow', 'warhammer'];
                const filteredSlots = this.getFilteredLootTable(allSlots);

                // If no valid items, use a random armor piece as fallback
                const slotType = filteredSlots.length > 0
                    ? filteredSlots[Math.floor(Math.random() * filteredSlots.length)]
                    : ['helmet', 'chest', 'gloves', 'boots', 'belt', 'amulet', 'ring'][Math.floor(Math.random() * 7)];

                // Generate item at chest's level
const item = new Item(slotType, rarity, chest.level);

// Create opening animation overlay
const overlay = document.createElement('div');
overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 3000;
    opacity: 0;
    transition: opacity 0.3s ease;
`;

const chestImage = chest.isMythic ? 'chest%20open%20mythic.png' : 'open%20chest.png';
const rarityColors = {
    rare: '#3b82f6',
    epic: '#a855f7',
    legendary: '#f59e0b',
    mythic: '#c910a7'
};

overlay.innerHTML = `
    <div style="text-align: center;">
        <div id="chest-emoji" style="margin-bottom: 20px; animation: chest-shake 0.5s ease-in-out;"><img src="${chestImage}" style="width: 160px; height: 160px;"></div>
        <div id="item-reveal" style="opacity: 0; transform: scale(0.5); transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);">
            <div style="font-size: 48px; margin-bottom: 15px; color: ${rarityColors[rarity]}; font-weight: 800; font-family: 'Orbitron', sans-serif; text-shadow: 0 0 20px ${rarityColors[rarity]};">${item.name}</div>
            <div style="font-size: 18px; color: #e2e8f0; font-weight: 600;">${item.getStatsDisplay()}</div>
        </div>
    </div>
`;

document.body.appendChild(overlay);

// Trigger animations
setTimeout(() => overlay.style.opacity = '1', 10);

// Chest shake and open
setTimeout(() => {
    const chestElem = document.getElementById('chest-emoji');
    chestElem.style.animation = 'chest-open 0.6s ease-out forwards';
}, 500);

// Item reveal
setTimeout(() => {
    const itemReveal = document.getElementById('item-reveal');
    itemReveal.style.opacity = '1';
    itemReveal.style.transform = 'scale(1)';
}, 1200);

// Close and cleanup
setTimeout(() => {
    overlay.style.opacity = '0';
    setTimeout(() => {
        overlay.remove();

        // Add to loot
        this.loot.push(item);

        // Remove chest from inventory
        this.playerChests.splice(chestIndex, 1);

        // Log the result
        const chestType = chest.isMythic ? '‚ú® Mythic Chest' : 'Chest';
        this.addLog(`Opened Level ${chest.level} ${chestType} ‚Üí ${item.name}`, 'loot');

        // Refresh displays
        this.showChests();
        this.showLoot();
     }, 300);
}, 3500);
}

            sellChest(chestId) {
    const chestIndex = this.playerChests.findIndex(c => c.id === chestId);
    if (chestIndex === -1) return;

    const chest = this.playerChests[chestIndex];

    // Add gold
    this.gold += chest.sellValue;

    // Remove chest
    this.playerChests.splice(chestIndex, 1);

    // Log with mythic indicator if applicable
    const chestType = chest.isMythic ? '‚ú® Mythic Chest' : 'Chest';
    this.addLog(`Sold Level ${chest.level} ${chestType} for ${chest.sellValue}g`, 'loot');

    // Refresh displays
    this.showChests();
    this.updateUI();
}

sellVaultKey(keyId) {
    const keyIndex = this.vaultKeys.findIndex(k => k.id === keyId);
    if (keyIndex === -1) return;

    const key = this.vaultKeys[keyIndex];
    const sellPrice = key.level * 100;

    // Add gold
    this.gold += sellPrice;

    // Remove key
    this.vaultKeys.splice(keyIndex, 1);

    // Log
    this.addLog(`Sold Level ${key.level} Vault Key for ${sellPrice}g`, 'loot');

    // Refresh displays
    this.showChests();
    this.updateUI();
}

sellRuneTrialKey(keyId) {
    const keyIndex = this.runeTrialKeys.findIndex(k => k.id === keyId);
    if (keyIndex === -1) return;

    const key = this.runeTrialKeys[keyIndex];
    const sellPrice = key.tier * 150;

    // Add gold
    this.gold += sellPrice;

    // Remove key
    this.runeTrialKeys.splice(keyIndex, 1);

    // Log
    this.addLog(`Sold Tier ${key.tier} Rune Trial Key for ${sellPrice}g`, 'loot');

    // Refresh displays
    this.showChests();
    this.updateUI();
}

showLootComparison(newItem, event) {
    const tooltip = document.getElementById('loot-tooltip');

    // Find which character would equip this and what they currently have
    let bestMember = null;
    let currentItem = null;

    // Check if there's a dropdown selection on the loot item
    const lootItemElement = event.target.closest('.loot-item');
    const dropdown = lootItemElement?.querySelector('.loot-item-select');
    const selectedValue = dropdown?.value;

    // Store the last selected value to prevent flickering
    if (!lootItemElement._lastSelectedValue) {
        lootItemElement._lastSelectedValue = selectedValue;
    }

    // Use stored value for stability
    const valueToUse = lootItemElement._lastSelectedValue || selectedValue;

    // If user selected a specific character, use that
    if (valueToUse && valueToUse !== 'auto') {
        bestMember = this.party[parseInt(valueToUse)];
    } else {
    // Otherwise use auto-equip logic to find best match

    // For weapons, directly match to class
    if (newItem.weaponType) {
        const weaponToClass = {
            'wand': 'Mage',
            'dagger': 'Rogue',
            'greatsword': 'Tank',
            'staff': 'Healer'
        };

        const targetClass = weaponToClass[newItem.weaponType];
        if (targetClass) {
            bestMember = this.party.find(m => m.isAlive && m.className === targetClass);
        }
    }

    // For non-weapons or if no match found, find best upgrade
    if (!bestMember) {
        let worstCurrentScore = Infinity;

        this.party.forEach(member => {
            if (!member.isAlive) return;

            // Get current item in slot
            let currentSlotItem = null;
            if (newItem.type === 'ring') {
                if (!member.equipment.ring1) {
                    currentSlotItem = null;
                } else if (!member.equipment.ring2) {
                    currentSlotItem = null;
                } else {
                    const ring1Score = this.calculateItemScore(member.equipment.ring1);
                    const ring2Score = this.calculateItemScore(member.equipment.ring2);
                    currentSlotItem = ring1Score < ring2Score ? member.equipment.ring1 : member.equipment.ring2;
                }
            } else {
                currentSlotItem = member.equipment[newItem.type];
            }

            const currentScore = this.calculateItemScore(currentSlotItem);
            const newScore = this.calculateItemScore(newItem);

            // Only consider if new item is better
            if (newScore > currentScore && currentScore < worstCurrentScore) {
                worstCurrentScore = currentScore;
                bestMember = member;
            }
        });
    }
}

                if (bestMember) {
                    if (newItem.type === 'ring') {
                        // Get the weaker ring (same logic as selection)
                        if (!bestMember.equipment.ring1) {
                            currentItem = null;
                        } else if (!bestMember.equipment.ring2) {
                            currentItem = null;
                        } else {
                            const ring1Score = this.calculateItemScore(bestMember.equipment.ring1);
                            const ring2Score = this.calculateItemScore(bestMember.equipment.ring2);
                            currentItem = ring1Score < ring2Score ? bestMember.equipment.ring1 : bestMember.equipment.ring2;
                        }
                    } else {
                        currentItem = bestMember.equipment[newItem.type];
                    }
                }

                // Build comparison tooltip
                let tooltipHTML = '<div class="comparison-container">';

                // Current item side
                tooltipHTML += '<div class="comparison-side">';
                if (currentItem) {
    tooltipHTML += `<div class="tooltip-header ${currentItem.rarity}">CURRENT: ${currentItem.name}</div>`;
    tooltipHTML += '<div class="tooltip-stats">';

    // Add mythic stat indicator for current item
if (currentItem.rarity === 'mythic' && (currentItem.mythicStat || currentItem.mythicStats)) {
    const mythicStatNames = currentItem.mythicStats ? currentItem.mythicStats.map(s => s.toUpperCase()).join(', ') : currentItem.mythicStat.toUpperCase();
    const isPerfect = currentItem.mythicStats && currentItem.mythicStats.length === 4;
    const prefix = isPerfect ? '‚ú® PERFECT MYTHIC' : '‚ö° MYTHIC';
    const color = isPerfect ? '#ffd700' : '#c910a7';
    const borderColor = isPerfect ? '#ffd700' : '#c910a7';
    const bgColor = isPerfect ? 'rgba(255, 215, 0, 0.15)' : 'rgba(201, 16, 167, 0.1)';

    tooltipHTML += `<div style="color: ${color}; font-size: 11px; font-weight: 700; margin-bottom: 8px; text-align: center; border: 1px solid ${borderColor}; border-radius: 4px; padding: 4px; background: ${bgColor};">${prefix}: ${mythicStatNames} (200%) ‚ú®</div>`;
}

if (currentItem.attack) tooltipHTML += `<div class="tooltip-stat">+${currentItem.attack} Attack ${this.getStatRollPercent(currentItem, 'attack')}</div>`;
                if (currentItem.attackSpeed) tooltipHTML += `<div class="tooltip-stat">+${currentItem.attackSpeed} Attack Speed ${this.getStatRollPercent(currentItem, 'attackSpeed')}</div>`;
                if (currentItem.hp) tooltipHTML += `<div class="tooltip-stat">+${currentItem.hp} HP ${this.getStatRollPercent(currentItem, 'hp')}</div>`;
                if (currentItem.mana) tooltipHTML += `<div class="tooltip-stat">+${currentItem.mana} Mana ${this.getStatRollPercent(currentItem, 'mana')}</div>`;
                if (currentItem.defense) tooltipHTML += `<div class="tooltip-stat">+${currentItem.defense} Defense ${this.getStatRollPercent(currentItem, 'defense')}</div>`;
                if (currentItem.critChance) tooltipHTML += `<div class="tooltip-stat">+${currentItem.critChance}% Crit Chance ${this.getStatRollPercent(currentItem, 'critChance')}</div>`;
                if (currentItem.critDamage) tooltipHTML += `<div class="tooltip-stat">+${currentItem.critDamage}% Crit Damage ${this.getStatRollPercent(currentItem, 'critDamage')}</div>`;
                if (currentItem.dodgeChance) tooltipHTML += `<div class="tooltip-stat">+${currentItem.dodgeChance}% Dodge ${this.getStatRollPercent(currentItem, 'dodgeChance')}</div>`;
                if (currentItem.lifesteal) tooltipHTML += `<div class="tooltip-stat">+${currentItem.lifesteal}% Lifesteal ${this.getStatRollPercent(currentItem, 'lifesteal')}</div>`;
                if (currentItem.hpRegen) tooltipHTML += `<div class="tooltip-stat">+${currentItem.hpRegen} HP Regen ${this.getStatRollPercent(currentItem, 'hpRegen')}</div>`;
if (currentItem.manaRegen) tooltipHTML += `<div class="tooltip-stat">+${currentItem.manaRegen} Mana Regen ${this.getStatRollPercent(currentItem, 'manaRegen')}</div>`;
                if (currentItem.cdr) tooltipHTML += `<div class="tooltip-stat">+${currentItem.cdr}% CDR ${this.getStatRollPercent(currentItem, 'cdr')}</div>`;
                tooltipHTML += '</div>';
                } else {
                    tooltipHTML += '<div class="tooltip-header">CURRENT: None</div>';
                    tooltipHTML += '<div class="tooltip-stats"><div style="color: #888;">Empty Slot</div></div>';
                }
                tooltipHTML += '</div>';

                // Arrow
                tooltipHTML += '<div class="comparison-divider"></div>';

                // New item side
tooltipHTML += '<div class="comparison-side">';
tooltipHTML += `<div class="tooltip-header ${newItem.rarity}">NEW: ${newItem.name}</div>`;
tooltipHTML += '<div class="tooltip-stats">';

// Add mythic stat indicator for new item
if (newItem.rarity === 'mythic' && (newItem.mythicStat || newItem.mythicStats)) {
    const mythicStatNames = newItem.mythicStats ? newItem.mythicStats.map(s => s.toUpperCase()).join(', ') : newItem.mythicStat.toUpperCase();
    const isPerfect = newItem.mythicStats && newItem.mythicStats.length === 4;
    const prefix = isPerfect ? '‚ú® PERFECT MYTHIC' : '‚ö° MYTHIC';
    const color = isPerfect ? '#ffd700' : '#c910a7';
    const borderColor = isPerfect ? '#ffd700' : '#c910a7';
    const bgColor = isPerfect ? 'rgba(255, 215, 0, 0.15)' : 'rgba(201, 16, 167, 0.1)';

    tooltipHTML += `<div style="color: ${color}; font-size: 11px; font-weight: 700; margin-bottom: 8px; text-align: center; border: 1px solid ${borderColor}; border-radius: 4px; padding: 4px; background: ${bgColor};">${prefix}: ${mythicStatNames} (200%) ‚ú®</div>`;
}

if (newItem.attack) tooltipHTML += `<div class="tooltip-stat">+${newItem.attack} Attack ${this.getStatRollPercent(newItem, 'attack')}</div>`;
                if (newItem.attackSpeed) tooltipHTML += `<div class="tooltip-stat">+${newItem.attackSpeed} Attack Speed ${this.getStatRollPercent(newItem, 'attackSpeed')}</div>`;
                if (newItem.hp) tooltipHTML += `<div class="tooltip-stat">+${newItem.hp} HP ${this.getStatRollPercent(newItem, 'hp')}</div>`;
                if (newItem.mana) tooltipHTML += `<div class="tooltip-stat">+${newItem.mana} Mana ${this.getStatRollPercent(newItem, 'mana')}</div>`;
                if (newItem.defense) tooltipHTML += `<div class="tooltip-stat">+${newItem.defense} Defense ${this.getStatRollPercent(newItem, 'defense')}</div>`;
                if (newItem.critChance) tooltipHTML += `<div class="tooltip-stat">+${newItem.critChance}% Crit Chance ${this.getStatRollPercent(newItem, 'critChance')}</div>`;
                if (newItem.critDamage) tooltipHTML += `<div class="tooltip-stat">+${newItem.critDamage}% Crit Damage ${this.getStatRollPercent(newItem, 'critDamage')}</div>`;
                if (newItem.dodgeChance) tooltipHTML += `<div class="tooltip-stat">+${newItem.dodgeChance}% Dodge ${this.getStatRollPercent(newItem, 'dodgeChance')}</div>`;
                if (newItem.lifesteal) tooltipHTML += `<div class="tooltip-stat">+${newItem.lifesteal}% Lifesteal ${this.getStatRollPercent(newItem, 'lifesteal')}</div>`;
                if (newItem.hpRegen) tooltipHTML += `<div class="tooltip-stat">+${newItem.hpRegen}% HP Regen ${this.getStatRollPercent(newItem, 'hpRegen')}</div>`;
                if (newItem.manaRegen) tooltipHTML += `<div class="tooltip-stat">+${newItem.manaRegen}% Mana Regen ${this.getStatRollPercent(newItem, 'manaRegen')}</div>`;
                if (newItem.cdr) tooltipHTML += `<div class="tooltip-stat">+${newItem.cdr}% CDR ${this.getStatRollPercent(newItem, 'cdr')}</div>`;
                tooltipHTML += '</div>';
                tooltipHTML += '</div>';

                tooltipHTML += '</div>';

                // Add who will equip it - determine correct member based on same logic as equipItem
                let displayMember = null;
                if (newItem.weaponType) {
                    const validWeapons = {
                        'Tank': 'greatsword',
                        'Healer': 'staff',
                        'Mage': 'wand',
                        'Rogue': 'dagger',
                        'Archer': 'bow',
                        'Paladin': 'warhammer'
                    };

                    // Find the class that matches this weapon
                    for (const [className, weaponType] of Object.entries(validWeapons)) {
                        if (weaponType === newItem.weaponType) {
                            displayMember = this.party.find(m => m.className === className);
                            break;
                        }
                    }
                } else {
                    displayMember = bestMember;
                }

                if (displayMember) {
                    tooltipHTML += `<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #444; text-align: center; color: #888;">Will equip to: ${displayMember.name}</div>`;
                }

                tooltip.innerHTML = tooltipHTML;
                tooltip.classList.add('show');

                // Position tooltip on the LEFT SIDE over the gameplay area
                // Fixed position relative to the viewport
                tooltip.style.left = '20px';
                tooltip.style.top = '50%';
                tooltip.style.transform = 'translateY(-50%)';
            }

            equipItem(item, index) {
    // Hide loot tooltip immediately
    document.getElementById('loot-tooltip').classList.remove('show');

    const newItemScore = this.calculateItemScore(item);
    let bestMember = null;

    // For weapons, directly match to class but check gear score
    if (item.weaponType) {
        const validWeapons = {
            'Tank': 'greatsword',
            'Healer': 'staff',
            'Mage': 'wand',
            'Rogue': 'dagger',
            'Archer': 'bow',
            'Paladin': 'warhammer'
        };

        // Find the class that matches this weapon
        for (const [className, weaponType] of Object.entries(validWeapons)) {
            if (weaponType === item.weaponType) {
                bestMember = this.party.find(m => m.className === className);
                break;
            }
        }

        if (bestMember) {
    const currentWeapon = bestMember.equipment.weapon;
    const currentScore = this.calculateItemScore(currentWeapon);

    // Mythics always equip (they're always upgrades)
    // Only equip if new item has higher gear score
    if (item.rarity === 'mythic' || newItemScore > currentScore) {
        this.equipItemToMember(item, index, bestMember);
        return;
    } else {
                // Not an upgrade - send to inventory
                this.loot.splice(index, 1);
                this.inventory.push(item);
                this.addLog(`${item.name} sent to inventory (not an upgrade)`, 'loot');
                this.showLoot();
                this.showInventory();
                return;
            }
        }
    }

    // For non-weapons, find character where item is best upgrade
    let bestUpgradeValue = 0;

    this.party.forEach(member => {
        // Get current item in slot
        let currentItem = null;
        if (item.type === 'ring') {
            if (!member.equipment.ring1) {
                currentItem = null;
            } else if (!member.equipment.ring2) {
                currentItem = null;
            } else {
                // Compare with weaker ring
                const ring1Score = this.calculateItemScore(member.equipment.ring1);
                const ring2Score = this.calculateItemScore(member.equipment.ring2);
                currentItem = ring1Score < ring2Score ? member.equipment.ring1 : member.equipment.ring2;
            }
        } else {
            currentItem = member.equipment[item.type];
        }

        const currentScore = this.calculateItemScore(currentItem);
        const upgradeValue = newItemScore - currentScore;

        // Only consider if new item is better AND it's the best upgrade we've found
        if (upgradeValue > 0 && upgradeValue > bestUpgradeValue) {
            bestUpgradeValue = upgradeValue;
            bestMember = member;
        }
    });

    if (bestMember) {
        this.equipItemToMember(item, index, bestMember);
    } else {
        // Not an upgrade for anyone - send to inventory
        this.loot.splice(index, 1);
        this.inventory.push(item);
        this.addLog(`${item.name} sent to inventory (not an upgrade)`, 'loot');
        this.showLoot();
        this.showInventory();
    }
}

            equipItemToCharacter(item, index, characterIndex) {
                // Hide loot tooltip immediately
                document.getElementById('loot-tooltip').classList.remove('show');

                const member = this.party[characterIndex];
                if (!member) {
                    this.addLog('Character not available', 'loot');
                    return;
                }

                this.equipItemToMember(item, index, member);
            }

equipItemToMember(item, index, member) {  // Fix typo first!
    // Validate weapon type for class
    if (item.weaponType) {
        const validWeapons = {
            'Tank': 'greatsword',
            'Healer': 'staff',
            'Mage': 'wand',
            'Rogue': 'dagger',
            'Archer': 'bow',
            'Paladin': 'warhammer'
        };
        if (validWeapons[member.className] !== item.weaponType) {
            this.addLog(`${member.className} cannot equip ${item.weaponType}!`, 'damage');
            return;
        }
    }

    // ‚úÖ USE CORRECT FUNCTION NAMES
    const oldMaxHP = member.getTotalMaxHp();
    const oldMaxMana = member.getTotalMaxMana();
    const hpPercent = member.hp / oldMaxHP;
    const manaPercent = member.mana / oldMaxMana;

    let replacedItem = null;

    // Equip the item
    if (item.type === 'ring') {
        if (!member.equipment.ring1) {
            member.equipment.ring1 = item;
        } else if (!member.equipment.ring2) {
            member.equipment.ring2 = item;
        } else {
            const ring1Score = this.calculateItemScore(member.equipment.ring1);
            const ring2Score = this.calculateItemScore(member.equipment.ring2);
            if (ring1Score < ring2Score) {
                replacedItem = member.equipment.ring1;
                member.equipment.ring1 = item;
            } else {
                replacedItem = member.equipment.ring2;
                member.equipment.ring2 = item;
            }
        }
    } else {
        replacedItem = member.equipment[item.type];
        member.equipment[item.type] = item;
    }

    // ‚úÖ USE CORRECT FUNCTION NAMES
    const newMaxHP = member.getTotalMaxHp();
    const newMaxMana = member.getTotalMaxMana();

    member.hp = Math.floor(newMaxHP * hpPercent);
    member.mana = Math.floor(newMaxMana * manaPercent);

    // Clamp to valid ranges
    member.hp = Math.max(1, Math.min(member.hp, newMaxHP));
    member.mana = Math.max(0, Math.min(member.mana, newMaxMana));

    // Add replaced item to inventory
    if (replacedItem) {
        this.inventory.push(replacedItem);
    }

    this.loot.splice(index, 1);

    // Recalculate skill tree stats (including perEpic bonuses) after equipment change
    this.applySkillTreeStats(member);

    // Update UI AFTER all HP/Mana changes
    this.showLoot();
    this.showInventory();
    this.rebuildUI();

    this.addLog(`${member.name} equips ${item.name}`, 'loot');
}
equipItemToMemberFromInventory(item, member) {
    // Validate weapon type for class
    if (item.weaponType) {
        const validWeapons = {
            'Tank': 'greatsword',
            'Healer': 'staff',
            'Mage': 'wand',
            'Rogue': 'dagger',
            'Archer': 'bow',
            'Paladin': 'warhammer'
        };
        if (validWeapons[member.className] !== item.weaponType) {
            this.addLog(`${member.className} cannot equip ${item.weaponType}!`, 'damage');
            return false;
        }
    }

    // Store percentages BEFORE equipping
    const oldMaxHP = member.getTotalMaxHp();
    const oldMaxMana = member.getTotalMaxMana();
    const hpPercent = member.hp / oldMaxHP;
    const manaPercent = member.mana / oldMaxMana;

    let replacedItem = null;

    // Equip the item
    if (item.type === 'ring') {
        if (!member.equipment.ring1) {
            member.equipment.ring1 = item;
        } else if (!member.equipment.ring2) {
            member.equipment.ring2 = item;
        } else {
            // Replace weaker ring
            const ring1Score = this.calculateItemScore(member.equipment.ring1);
            const ring2Score = this.calculateItemScore(member.equipment.ring2);
            if (ring1Score < ring2Score) {
                replacedItem = member.equipment.ring1;
                member.equipment.ring1 = item;
            } else {
                replacedItem = member.equipment.ring2;
                member.equipment.ring2 = item;
            }
        }
    } else {
        replacedItem = member.equipment[item.type];
        member.equipment[item.type] = item;
    }

   // Restore HP/Mana as PERCENTAGES after equipping
const newMaxHp = Math.round(member.getTotalMaxHp());
const newMaxMana = Math.round(member.getTotalMaxMana());

member.hp = Math.round(newMaxHp * hpPercent);
member.mana = Math.round(newMaxMana * manaPercent);

// Clamp to valid ranges
member.hp = Math.max(1, Math.min(member.hp, newMaxHp));
member.mana = Math.max(0, Math.min(member.mana, newMaxMana));

    // Add replaced item to inventory
    if (replacedItem) {
        this.inventory.push(replacedItem);
    }

    // Recalculate skill tree stats (including perEpic bonuses) after equipment change
    this.applySkillTreeStats(member);

    this.addLog(`${member.name} equips ${item.name}`, 'loot');
    return true;
}

            showInventory() {
    // Hide any visible tooltips
    const lootTooltip = document.getElementById('loot-tooltip');
    if (lootTooltip) lootTooltip.classList.remove('show');

    const container = document.getElementById('inventory-container');

    if (this.inventory.length === 0) {
        container.innerHTML = '<div style="color: #888; text-align: center; padding: 20px;">Inventory is empty</div>';
        return;
    }

    // Proper cleanup of old elements and listeners
    while (container.firstChild) {
        container.removeChild(container.firstChild);
    }

    // Sort inventory based on active filters
    let sortedInventory = [...this.inventory];

    if (this.inventorySortBy.length > 0) {
        sortedInventory.sort((a, b) => {
            for (const filter of this.inventorySortBy) {
                if (filter === 'rarity') {
                    const rarityOrder = { mythic: 6, legendary: 5, epic: 4, rare: 3, uncommon: 2, common: 1 };
                    const diff = rarityOrder[b.rarity] - rarityOrder[a.rarity];
                    if (diff !== 0) return diff;
                } else if (filter === 'level') {
                    const diff = b.level - a.level;
                    if (diff !== 0) return diff;
                }
            }
            return 0;
        });
    }

                sortedInventory.forEach((item, displayIndex) => {
                    const div = document.createElement('div');
                    div.className = `loot-item ${item.rarity}`;
                    div.style.borderColor = this.getRarityColor(item.rarity);

                    const sellPrices = {
    common: 5,
    uncommon: 10,
    rare: 15,
    epic: 20,
    legendary: 25,
    mythic: 10000
};
                    const sellPrice = sellPrices[item.rarity] || 5;

                    div.innerHTML = `
                        <div class="equipment-name ${item.rarity}" style="font-size: 13px; font-weight: 600; margin-bottom: 3px; line-height: 1.2;">${item.name}</div>
                       <div style="font-size: 10px; color: #e2e8f0; line-height: 1.4; margin-bottom: 6px; font-weight: 500;">${item.getStatsDisplay()}</div>
                        <div class="loot-item-actions">
                            <select class="loot-item-select" style="flex: 2; padding: 4px 6px; background: rgba(30, 41, 59, 0.9); color: #e2e8f0; border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; font-family: 'Rajdhani', sans-serif; font-size: 10px; cursor: pointer;">
                                <option value="auto">Auto-Equip Best</option>
                                ${this.party.filter(m => m.isAlive).map((m, idx) => `<option value="${idx}">${m.name}</option>`).join('')}
                            </select>
                            <button class="loot-item-btn equip-btn" style="flex: 1;">Equip</button>
                            <button class="loot-item-btn sell-btn" style="flex: 1;">Sell ${sellPrice}g</button>
                        </div>
                    `;

// Track dropdown changes for tooltip stability
                    div.querySelector('.loot-item-select').addEventListener('change', (e) => {
                        div._lastSelectedValue = e.target.value;
                    });

                    // Equip button - CRITICAL FIX: Find actual inventory index at click time
                    div.querySelector('.equip-btn').onclick = (e) => {
                        e.stopPropagation();
                        const selectedChar = div.querySelector('.loot-item-select').value;
                        // Find actual index in current inventory state (not cached)
                        const actualIndex = this.inventory.findIndex(invItem => invItem === item);
                        if (actualIndex === -1) {
                            this.addLog('Item no longer in inventory', 'damage');
                            this.showInventory();
                            return;
                        }
                        if (selectedChar === 'auto') {
                            this.equipFromInventory(item, actualIndex);
                        } else {
                            this.equipFromInventoryToCharacter(item, actualIndex, parseInt(selectedChar));
                        }
                    };

                    // Sell button - CRITICAL FIX: Find actual inventory index at click time
                    div.querySelector('.sell-btn').onclick = (e) => {
                        e.stopPropagation();
                        // Find actual index in current inventory state (not cached)
                        const actualIndex = this.inventory.findIndex(invItem => invItem === item);
                        if (actualIndex === -1) {
                            this.addLog('Item no longer in inventory', 'damage');
                            this.showInventory();
                            return;
                        }
                        this.sellItem(item, actualIndex, 'inventory');
                    };

                    // Add comparison tooltip for inventory items too
                    div.addEventListener('mouseenter', (e) => {
                        this.showLootComparison(item, e);
                    });

                    div.addEventListener('mouseleave', () => {
                        document.getElementById('loot-tooltip').classList.remove('show');
                    });

                    container.appendChild(div);
                });
            }

            sellItem(item, index, source) {
    const sellPrices = {
    common: 5,
    uncommon: 10,
    rare: 15,
    epic: 20,
    legendary: 25,
    mythic: 10000
};
    const sellPrice = sellPrices[item.rarity] || 5;

    // Add gold and track it
    this.gold += sellPrice;
    this.floorStats.goldEarned += sellPrice;
    this.globalStats.totalGoldEarned += sellPrice;

                // Remove item from loot or inventory
                if (source === 'loot') {
                    this.loot.splice(index, 1);
                    this.showLoot();
                } else if (source === 'inventory') {
                    this.inventory.splice(index, 1);
                    this.showInventory();
                }

                // Update UI and log
                this.updateUI();
                this.addLog(`Sold ${item.name} for ${sellPrice}g`, 'loot');
            }

equipFromInventory(item, index) {
    // Hide tooltip
    document.getElementById('loot-tooltip').classList.remove('show');

    const newItemScore = this.calculateItemScore(item);
    let bestMember = null;

    // For weapons, directly match to class but check gear score
    if (item.weaponType) {
        const validWeapons = {
            'Tank': 'greatsword',
            'Healer': 'staff',
            'Mage': 'wand',
            'Rogue': 'dagger',
            'Archer': 'bow',
            'Paladin': 'warhammer'
        };

        // Find the class that matches this weapon
        for (const [className, weaponType] of Object.entries(validWeapons)) {
            if (weaponType === item.weaponType) {
                bestMember = this.party.find(m => m.className === className);
                break;
            }
        }

        if (bestMember) {
            const currentWeapon = bestMember.equipment.weapon;
            const currentScore = this.calculateItemScore(currentWeapon);

            // Only equip if new item has higher gear score
            if (newItemScore > currentScore) {
                const success = this.equipItemToMemberFromInventory(item, bestMember);
                if (success) {
                    this.inventory.splice(index, 1);
                } else {
                    this.addLog('Failed to equip item', 'damage');
                }
            } else {
                // Not an upgrade
                this.addLog(`${item.name} is not an upgrade`, 'loot');
            }
            this.rebuildUI();
            this.showInventory();
            return;
        }
    }

    // For non-weapons, find character where item is best upgrade
    let bestUpgradeValue = 0;

    this.party.forEach(member => {
        // Get current item in slot
        let currentItem = null;
        if (item.type === 'ring') {
            if (!member.equipment.ring1) {
                currentItem = null;
            } else if (!member.equipment.ring2) {
                currentItem = null;
            } else {
                const ring1Score = this.calculateItemScore(member.equipment.ring1);
                const ring2Score = this.calculateItemScore(member.equipment.ring2);
                currentItem = ring1Score < ring2Score ? member.equipment.ring1 : member.equipment.ring2;
            }
        } else {
            currentItem = member.equipment[item.type];
        }

        const currentScore = this.calculateItemScore(currentItem);
        const upgradeValue = newItemScore - currentScore;

        // Only consider if new item is better AND it's the best upgrade we've found
        if (upgradeValue > 0 && upgradeValue > bestUpgradeValue) {
            bestUpgradeValue = upgradeValue;
            bestMember = member;
        }
    });

    if (bestMember) {
        const success = this.equipItemToMemberFromInventory(item, bestMember);
        if (success) {
            this.inventory.splice(index, 1);
        } else {
            this.addLog('Failed to equip item', 'damage');
        }
    } else {
        this.addLog(`${item.name} is not an upgrade for any character`, 'loot');
    }

    // Force full rebuild BEFORE showing inventory to ensure fresh data
    this.rebuildUI();
    this.showInventory();
}

            equipFromInventoryToCharacter(item, index, characterIndex) {
    // Hide tooltip
    document.getElementById('loot-tooltip').classList.remove('show');

    const member = this.party[characterIndex];
    if (!member) {
        this.addLog('Character not available', 'loot');
        return;
    }

    const success = this.equipItemToMemberFromInventory(item, member);

    if (success) {
        this.inventory.splice(index, 1);  // ‚Üê Remove AFTER equipping
    }

    // Update displays
    this.showInventory();
    this.updateUI();
}


            equipItemToMember(item, index, member) {
    // Validate weapon type for class
    if (item.weaponType) {
        const validWeapons = {
            'Tank': 'greatsword',
            'Healer': 'staff',
            'Mage': 'wand',
            'Rogue': 'dagger',
            'Archer': 'bow',
            'Paladin': 'warhammer'
        };
        if (validWeapons[member.className] !== item.weaponType) {
            this.addLog(`${member.className} cannot equip ${item.weaponType}!`, 'damage');
            return;
        }
    }

    // Store HP/Mana as PERCENTAGES before equipping
    const hpPercent = member.hp / member.getTotalMaxHp();
    const manaPercent = member.mana / member.getTotalMaxMana();

    let replacedItem = null;

    // Equip the item
    if (item.type === 'ring') {
        if (!member.equipment.ring1) {
            member.equipment.ring1 = item;
        } else if (!member.equipment.ring2) {
            member.equipment.ring2 = item;
        } else {
            // Replace weaker ring
            const ring1Score = this.calculateItemScore(member.equipment.ring1);
            const ring2Score = this.calculateItemScore(member.equipment.ring2);
            if (ring1Score < ring2Score) {
                replacedItem = member.equipment.ring1;
                member.equipment.ring1 = item;
            } else {
                replacedItem = member.equipment.ring2;
                member.equipment.ring2 = item;
            }
        }
    } else {
        replacedItem = member.equipment[item.type];
        member.equipment[item.type] = item;
    }

    // Restore HP/Mana as PERCENTAGES after equipping
const newMaxHp = Math.round(member.getTotalMaxHp());
const newMaxMana = Math.round(member.getTotalMaxMana());

member.hp = Math.round(newMaxHp * hpPercent);
member.mana = Math.round(newMaxMana * manaPercent);

// Clamp to valid ranges
member.hp = Math.max(1, Math.min(member.hp, newMaxHp));
member.mana = Math.max(0, Math.min(member.mana, newMaxMana));

    // Add replaced item to inventory
    if (replacedItem) {
        this.inventory.push(replacedItem);
    }

    this.loot.splice(index, 1);

    // Update UI AFTER all HP/Mana changes
    this.showLoot();
    this.showInventory();
    this.rebuildUI();

    this.addLog(`${member.name} equips ${item.name}`, 'loot');
}


equipFromInventory(item, index) {
    // Hide tooltip
    document.getElementById('loot-tooltip').classList.remove('show');

    const newItemScore = this.calculateItemScore(item);
    let bestMember = null;

    // For weapons, directly match to class but check gear score
    if (item.weaponType) {
        const validWeapons = {
            'Tank': 'greatsword',
            'Healer': 'staff',
            'Mage': 'wand',
            'Rogue': 'dagger',
            'Archer': 'bow',
            'Paladin': 'warhammer'
        };

        // Find the class that matches this weapon
        for (const [className, weaponType] of Object.entries(validWeapons)) {
            if (weaponType === item.weaponType) {
                bestMember = this.party.find(m => m.className === className);
                break;
            }
        }

        if (bestMember) {
            const currentWeapon = bestMember.equipment.weapon;
            const currentScore = this.calculateItemScore(currentWeapon);

            // Only equip if new item has higher gear score
            if (newItemScore > currentScore) {
                const success = this.equipItemToMemberFromInventory(item, bestMember);
                if (success) {
                    this.inventory.splice(index, 1);  // ‚Üê Remove AFTER equipping
                }
            } else {
                this.addLog(`${item.name} is not an upgrade`, 'loot');
            }
            this.rebuildUI();
            this.showInventory();
            return;
        }
    }

    // For non-weapons, find character where item is best upgrade
    let bestUpgradeValue = 0;

    this.party.forEach(member => {
        let currentItem = null;
        if (item.type === 'ring') {
            if (!member.equipment.ring1) {
                currentItem = null;
            } else if (!member.equipment.ring2) {
                currentItem = null;
            } else {
                const ring1Score = this.calculateItemScore(member.equipment.ring1);
                const ring2Score = this.calculateItemScore(member.equipment.ring2);
                currentItem = ring1Score < ring2Score ? member.equipment.ring1 : member.equipment.ring2;
            }
        } else {
            currentItem = member.equipment[item.type];
        }

        const currentScore = this.calculateItemScore(currentItem);
        const upgradeValue = newItemScore - currentScore;

        if (upgradeValue > 0 && upgradeValue > bestUpgradeValue) {
            bestUpgradeValue = upgradeValue;
            bestMember = member;
        }
    });

    if (bestMember) {
        const success = this.equipItemToMemberFromInventory(item, bestMember);
        if (success) {
            this.inventory.splice(index, 1);  // ‚Üê Remove AFTER equipping
        }
    } else {
        this.addLog(`${item.name} is not an upgrade for any character`, 'loot');
    }

    this.rebuildUI();
    this.showInventory();
}
            calculateItemScore(item) {
    if (!item) return 0;
    // Use the same gear score calculation shown in UI
    const rarityPoints = { common: 2, uncommon: 4, rare: 6, epic: 8, legendary: 12, mythic: 20 };
    const basePoints = rarityPoints[item.rarity] || 0;
    const multiplier = 1 + (item.level - 1) * 0.1;
    return basePoints * multiplier;
}

createFloatingText(sprite, text, className) {
    if (!sprite) return;

    const mainView = document.getElementById('main-view');
    const elem = document.createElement('div');
    elem.className = `floating-text ${className}`;

    // Round numbers properly
    if (typeof text === 'string' && (text.includes('-') || text.includes('+'))) {
        const match = text.match(/^([+-]?)(\d+\.?\d*)(.*)/);
        if (match) {
            const sign = match[1];
            const number = parseFloat(match[2]);
            const suffix = match[3];
            elem.textContent = sign + Math.round(number) + suffix;
        } else {
            elem.textContent = text;
        }
    } else {
        elem.textContent = text;
    }

    elem.style.left = `${sprite.screenX + this.offsetX}px`;
    elem.style.top = `${sprite.screenY + this.offsetY - 30}px`;
    mainView.appendChild(elem);

    setTimeout(() => {
        elem.remove(); // Simple removal
    }, 1000);
}

createBlessingParticle(x, y) {
    const particle = document.createElement('div');
    particle.style.position = 'fixed';
    particle.style.left = x + 'px';
    particle.style.top = y + 'px';
    particle.style.width = '8px';
    particle.style.height = '8px';
    particle.style.borderRadius = '50%';
    particle.style.background = 'radial-gradient(circle, #e9d5ff, #a855f7)';
    particle.style.pointerEvents = 'none';
    particle.style.zIndex = '10000';
    particle.style.boxShadow = '0 0 10px rgba(168, 85, 247, 0.8)';

    // Random direction
    const angle = Math.random() * Math.PI * 2;
    const distance = 50 + Math.random() * 50;
    const endX = x + Math.cos(angle) * distance;
    const endY = y + Math.sin(angle) * distance - 50; // Bias upward

    particle.style.transition = 'all 0.8s ease-out';
    document.body.appendChild(particle);

    // Trigger animation
    setTimeout(() => {
        particle.style.left = endX + 'px';
        particle.style.top = endY + 'px';
        particle.style.opacity = '0';
        particle.style.transform = 'scale(0)';
    }, 10);

    setTimeout(() => {
        particle.remove();
    }, 900);
}

addLog(message, type = '') {
    const container = document.getElementById('log-container');

    // Remove oldest if we're at limit BEFORE adding new
    if (container.children.length >= 15) {
        container.removeChild(container.firstChild);
    }

    const entry = document.createElement('div');
    entry.className = `log-entry ${type}`;
    entry.textContent = message;
    container.appendChild(entry);
}

            togglePause() {
                this.paused = !this.paused;
                document.getElementById('pause-btn').textContent = this.paused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
            }

            updateAbilityIndicators() {
                // REMOVED: Early return that prevented cooldown display outside of battle
                // Cooldowns should always be visible so players can see when abilities are ready

                // Only log if keystones are actually on cooldown
                const keystonesOnCD = this.party.filter(m => m.keystoneCooldown > 0);
                if (keystonesOnCD.length > 0) {
                    const cdDetails = keystonesOnCD.map(m => `${m.name}:${m.keystoneCooldown.toFixed(1)}s`).join(', ');
                    console.log(`[UI UPDATE] Updating ability indicators (${keystonesOnCD.length} keystones on CD: ${cdDetails})`);
                }

                this.party.forEach((member, index) => {
                    const container = document.querySelector(`.ability-status[data-member-index="${index}"]`);
                    if (!container) return;

                    // Update ability 1 (class skill)
                    const ability1 = container.querySelector('.ability-indicator[data-ability="1"]');
                    if (ability1) {
                        const cooldownPercent = member.maxCooldown > 0 ? ((member.maxCooldown - member.cooldown) / member.maxCooldown) * 100 : 100;
                        const fill = ability1.querySelector('.ability-cooldown-fill');
                        const text = ability1.querySelector('.ability-cooldown-text');

                        if (fill) fill.setAttribute('stroke-dasharray', `${cooldownPercent}, 100`);

                        if (member.cooldown > 0) {
    ability1.className = 'ability-indicator on-cooldown';
} else if (member.mana >= member.skillCost) {
    ability1.className = 'ability-indicator ready';
} else {
    ability1.className = 'ability-indicator no-mana';
}
                    }

                    // Update ability 2 (keystone)
                    const ability2 = container.querySelector('.ability-indicator[data-ability="2"]');
                    if (ability2) {
                        const keystoneType = member.className.toLowerCase();
                        const equippedKeystone = this.equippedKeystones[keystoneType];

                        // Log if this member has a keystone on cooldown
                        if (member.keystoneCooldown > 0) {
                            console.log(`[UI MEMBER] ${member.name} (index ${index}) has keystoneCooldown=${member.keystoneCooldown.toFixed(2)}s, equippedKeystone=${!!equippedKeystone}`);
                        }

                        if (equippedKeystone) {
                            const fill = ability2.querySelector('.ability-cooldown-fill');
                            const text = ability2.querySelector('.ability-cooldown-text');

                            // Initialize keystone cooldown tracking if needed
                            if (member.keystoneCooldown === undefined) member.keystoneCooldown = 0;
                            if (member.keystoneMaxCooldown === undefined || member.keystoneMaxCooldown !== equippedKeystone.ability.cooldown) {
                                member.keystoneMaxCooldown = equippedKeystone.ability.cooldown;
                                console.log(`[UI INIT] ${member.name} keystoneMaxCooldown set to ${member.keystoneMaxCooldown}s`);
                            }

                            const cooldownPercent = member.keystoneMaxCooldown > 0 ? ((member.keystoneMaxCooldown - member.keystoneCooldown) / member.keystoneMaxCooldown) * 100 : 100;

                            // ALWAYS log state on first run, then once per second
                            const now = Date.now();
                            const shouldLog = !member._lastUILog || now - member._lastUILog > 1000;

                            if (member.keystoneCooldown > 0 && shouldLog) {
                                console.log(`[UI STATE] ${member.name} keystone: CD=${member.keystoneCooldown.toFixed(2)}s / ${member.keystoneMaxCooldown}s (${cooldownPercent.toFixed(1)}% complete), fill exists=${!!fill}, current className="${ability2.className}"`);
                                member._lastUILog = now;
                            }

                            if (fill) {
                                const oldDashArray = fill.getAttribute('stroke-dasharray');
                                fill.setAttribute('stroke-dasharray', `${cooldownPercent}, 100`);
                                const newDashArray = fill.getAttribute('stroke-dasharray');

                                if (member.keystoneCooldown > 0 && shouldLog) {
                                    console.log(`[UI RENDER] ${member.name} keystone fill: "${oldDashArray}" -> "${newDashArray}"`);
                                }
                            } else {
                                if (member.keystoneCooldown > 0 && shouldLog) {
                                    console.log(`[UI ERROR] ${member.name} keystone: SVG fill element NOT FOUND!`);
                                }
                            }

                            // Debug logging for cooldown state
                            if (member.keystoneCooldown > 0 && member.keystoneCooldown === member.keystoneMaxCooldown) {
                                console.log(`[UI ALERT] ${member.name} keystone JUST ACTIVATED!`);
                            }

                            const newClassName = member.keystoneCooldown > 0 ? 'ability-indicator on-cooldown' : 'ability-indicator ready';

                            // Always log class state when on cooldown (for debugging)
                            if (member.keystoneCooldown > 0 && shouldLog) {
                                console.log(`[UI CLASS] ${member.name} current className="${ability2.className}", should be="${newClassName}", match=${ability2.className === newClassName}`);
                            }

                            if (ability2.className !== newClassName) {
                                console.log(`[UI CHANGE] ${member.name} keystone class: "${ability2.className}" -> "${newClassName}"`);
                                ability2.className = newClassName;
                            }

                            // Track if we were on cooldown for next frame
                            member._wasOnCooldown = member.keystoneCooldown > 0;
                        } else {
                            ability2.className = 'ability-indicator no-rune';
                        }
                    }
                });
            }

            updateUI() {
                // Check if battle just ended - force update even if throttled
                const forceUpdate = !this.inBattle && this._wasInBattle;
                this._wasInBattle = this.inBattle;

    // Prevent excessive UI updates (unless forced)
    if (!forceUpdate && this._lastUIUpdate && Date.now() - this._lastUIUpdate < 100) {
        return; // Skip if updated less than 100ms ago
    }
    this._lastUIUpdate = Date.now();

    // Update enemy health bars
    this.updateEnemyHealthBars();

    const container = document.getElementById('party-container');

    // If party container is empty, do full rebuild
    if (container.children.length === 0) {
        this.rebuildUI();
        return;
    }

    // Otherwise, just update the dynamic values (bars, stats) without rebuilding
    this.party.forEach((member, index) => {
        const card = container.children[index];
        if (!card) return;

        // Update HP bar
const hpBar = card.querySelector('.hp-bar .bar-fill');
const hpText = card.querySelector('.hp-bar .bar-text');
if (hpBar && hpText) {
    hpBar.style.width = `${(member.hp / member.getTotalMaxHp()) * 100}%`;
    // Show shield in HP text if present
    if (member.shieldAmount && member.shieldAmount > 0) {
        hpText.textContent = `${Math.round(member.hp + member.shieldAmount)}/${Math.round(member.getTotalMaxHp())} HP (üõ°Ô∏è${Math.round(member.shieldAmount)})`;
    } else {
        hpText.textContent = `${Math.round(member.hp)}/${Math.round(member.getTotalMaxHp())} HP`;
    }
}

        // Update Mana bar
const manaBar = card.querySelector('.mana-bar .bar-fill');
const manaText = card.querySelector('.mana-bar .bar-text');
if (manaBar && manaText) {
    manaBar.style.width = `${(member.mana / member.getTotalMaxMana()) * 100}%`;
    manaText.textContent = `${Math.round(member.mana)}/${Math.round(member.getTotalMaxMana())} MANA`;
}

        // Update XP bar
        const xpBar = card.querySelector('.xp-bar .bar-fill');
        const xpText = card.querySelector('.xp-bar .bar-text');
        if (xpBar && xpText) {
            xpBar.style.width = `${(member.xp / member.maxXp) * 100}%`;
            xpText.textContent = `${member.xp}/${member.maxXp} XP`;
        }

        // Update level
        const levelDisplay = card.querySelector('.member-level');
        if (levelDisplay) {
            levelDisplay.textContent = `Lvl ${member.level}`;
        }
    });

    // Update gold display
    const goldDisplay = document.getElementById('gold-display');
    if (goldDisplay) goldDisplay.textContent = this.gold;

    const topGoldDisplay = document.getElementById('gold-display-top');
    if (topGoldDisplay) topGoldDisplay.textContent = this.gold.toLocaleString() + 'g';

    // Update blessing currency display
    const blessingDisplay = document.getElementById('blessing-display-top');
    if (blessingDisplay) {
        if (this.currentDungeon === 'endlessblessings' || (this.blessingCurrency && this.blessingCurrency > 0)) {
            blessingDisplay.style.display = 'flex';
            blessingDisplay.textContent = (this.blessingCurrency || 0).toLocaleString() + ' ‚ú®';
        } else {
            blessingDisplay.style.display = 'none';
        }
    }

    // Update blessing currency in bless tab if open
    const blessCurrencyDisplay = document.getElementById('blessing-currency-display');
    if (blessCurrencyDisplay) {
        blessCurrencyDisplay.textContent = this.blessingCurrency || 0;
    }

    // Update global stats displays
    const farthestFloorDisplay = document.getElementById('farthest-floor-display');
    if (farthestFloorDisplay) farthestFloorDisplay.textContent = this.globalStats.farthestFloor;

    const fastestFloorDisplay = document.getElementById('fastest-floor-display');
    if (fastestFloorDisplay) {
        if (this.globalStats.fastestFloorTime === null) {
            fastestFloorDisplay.textContent = '--';
        } else {
            const minutes = Math.floor(this.globalStats.fastestFloorTime / 60);
            const seconds = this.globalStats.fastestFloorTime % 60;
            fastestFloorDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
    }

    const legendariesDisplay = document.getElementById('legendaries-display');
    if (legendariesDisplay) legendariesDisplay.textContent = this.globalStats.legendariesFound;

    const chestsDisplay = document.getElementById('chests-display');
    if (chestsDisplay) chestsDisplay.textContent = this.globalStats.chestsFound;

    const mythicChestsDisplay = document.getElementById('mythic-chests-display');
    if (mythicChestsDisplay) mythicChestsDisplay.textContent = this.globalStats.mythicChestsFound;

    const floorsClearedDisplay = document.getElementById('floors-cleared-display');
    if (floorsClearedDisplay) floorsClearedDisplay.textContent = this.globalStats.totalFloorsCleared;

    const totalGoldDisplay = document.getElementById('total-gold-display');
    if (totalGoldDisplay) totalGoldDisplay.textContent = this.globalStats.totalGoldEarned + 'g';

    const deathsDisplay = document.getElementById('deaths-display');
    if (deathsDisplay) deathsDisplay.textContent = this.globalStats.totalDeaths;
}

updateEnemyHealthBars() {
                const container = document.getElementById('enemy-health-bars');
                if (!container) return;

                // Clear existing bars
                container.innerHTML = '';

                // Get alive enemies
                const aliveEnemies = this.enemies.filter(e => e.isAlive);

                // Only show during battle and when there are alive enemies
                if (!this.inBattle || aliveEnemies.length === 0) {
                    return;
                }

                // Create health bar for each alive enemy
                aliveEnemies.forEach(enemy => {
                    const barDiv = document.createElement('div');
                    const hpPercent = (enemy.hp / enemy.maxHp) * 100;

                    // Determine elite tier
                    let eliteTier = 'normal';
                    let borderColor = 'rgba(239, 68, 68, 0.5)';
                    let bgGradient = 'linear-gradient(135deg, rgba(15, 23, 42, 0.95) 0%, rgba(30, 41, 59, 0.95) 100%)';
                    let hpBarGradient = 'linear-gradient(90deg, #dc2626, #ef4444)';
                    let glowEffect = '';
                    let prefix = '';
                    let borderWidth = '1px';

                    // TIER 1: Treasure Guardians & Regular Floor Bosses
                    if (enemy.isTreasureGuardian || enemy.isBoss) {
                        eliteTier = 'elite';
                        borderColor = 'rgba(234, 179, 8, 0.8)';
                        bgGradient = 'linear-gradient(135deg, rgba(20, 20, 30, 0.98) 0%, rgba(40, 35, 20, 0.98) 100%)';
                        hpBarGradient = 'linear-gradient(90deg, #854d0e, #ca8a04, #fbbf24)';
                        glowEffect = 'box-shadow: 0 0 20px rgba(234, 179, 8, 0.4), inset 0 0 20px rgba(234, 179, 8, 0.1);';
                        prefix = enemy.isTreasureGuardian ? '‚öúÔ∏è ELITE: ' : 'üëë BOSS: ';
                        borderWidth = '2px';
                    }

                    // TIER 2: Vault Bosses (Keystone Wardens)
                    if (this.currentDungeon === 'vault' && enemy.isBoss) {
                        eliteTier = 'legendary';
                        borderColor = 'rgba(255, 215, 0, 1)';
                        bgGradient = 'linear-gradient(135deg, rgba(40, 30, 10, 0.98) 0%, rgba(60, 45, 15, 0.98) 100%)';
                        hpBarGradient = 'linear-gradient(90deg, #b45309, #f59e0b, #fbbf24, #fde047)';
                        glowEffect = 'box-shadow: 0 0 40px rgba(255, 215, 0, 0.8), inset 0 0 30px rgba(255, 215, 0, 0.3);';
                        prefix = 'üíé BOSS: ';
                        borderWidth = '3px';
                    }

                    // TIER 3: Rune Trial Bosses (HIGHEST TIER)
                    if (this.currentDungeon === 'runetrial' && enemy.isBoss) {
                        eliteTier = 'mythic';
                        borderColor = 'rgba(168, 85, 247, 0.9)';
                        bgGradient = 'linear-gradient(135deg, rgba(30, 20, 40, 0.98) 0%, rgba(50, 30, 60, 0.98) 100%)';
                        hpBarGradient = 'linear-gradient(90deg, #6b21a8, #a855f7, #c084fc)';
                        glowEffect = 'box-shadow: 0 0 50px rgba(168, 85, 247, 0.7), inset 0 0 40px rgba(168, 85, 247, 0.3);';
                        prefix = '‚ú® BOSS: ';
                        borderWidth = '4px';
                    }

                    barDiv.style.cssText = `background: ${bgGradient}; border: ${borderWidth} solid ${borderColor}; border-radius: 12px; padding: ${eliteTier === 'normal' ? '8px 12px' : '12px 16px'}; min-width: ${eliteTier === 'normal' ? '250px' : '320px'}; backdrop-filter: blur(10px); ${glowEffect}`;

                    barDiv.innerHTML = `
                        <div style="font-size: ${eliteTier === 'normal' ? '11px' : '13px'}; font-weight: ${eliteTier === 'normal' ? '600' : '700'}; color: ${eliteTier === 'mythic' ? '#e9d5ff' : (eliteTier === 'normal' ? '#f87171' : enemy.color)}; margin-bottom: 6px; font-family: 'Orbitron', sans-serif; text-shadow: 0 0 10px ${eliteTier === 'mythic' ? '#e9d5ff' : (eliteTier === 'normal' ? '#f87171' : enemy.color)}, 0 2px 8px rgba(0,0,0,0.9);">${prefix}${enemy.name}</div>
                        <div style="display: flex; gap: 12px; font-size: ${eliteTier === 'normal' ? '10px' : '11px'}; color: #94a3b8; margin-bottom: 8px; font-weight: 600;">
                            <span>‚öîÔ∏è ${enemy.getTotalAttack ? enemy.getTotalAttack() : enemy.attack}</span>
                            <span>üõ°Ô∏è ${enemy.getTotalDefense ? enemy.getTotalDefense() : enemy.defense}</span>
                            ${eliteTier !== 'normal' ? `<span style="color: ${borderColor};">üíÄ ELITE</span>` : ''}
                        </div>
                        <div style="height: ${eliteTier === 'normal' ? '14px' : '18px'}; background: rgba(15, 23, 42, 0.8); border: 1px solid ${borderColor}; border-radius: 9px; overflow: hidden; position: relative;">
                            <div style="height: 100%; width: ${hpPercent}%; background: ${hpBarGradient}; transition: width 0.3s ease; ${eliteTier !== 'normal' ? 'box-shadow: 0 0 15px currentColor;' : ''}"></div>
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: ${eliteTier === 'normal' ? '9px' : '11px'}; font-weight: 700; color: white; text-shadow: 0 2px 4px rgba(0,0,0,0.9);">${Math.floor(enemy.hp).toLocaleString()}/${enemy.maxHp.toLocaleString()}</div>
                        </div>
                    `;

                    container.appendChild(barDiv);
                });
            }


			rebuildUI() {
    console.log('rebuildUI called - current HP:', this.party.map(m => ({name: m.name, hp: m.hp, maxHp: m.maxHp})));

    // ... rest of rebuildUI code
                const container = document.getElementById('party-container');

    // Store current view states before clearing
    const viewStates = {};
    container.querySelectorAll('.party-member').forEach((card, index) => {
                    const activeView = card.querySelector('.view-btn.active');
                    if (activeView) {
                        viewStates[index] = activeView.getAttribute('data-view');
                    }
                });

                // Proper cleanup of old elements and listeners
                while (container.firstChild) {
                    container.removeChild(container.firstChild);
                }

// Update gold display
const goldDisplay = document.getElementById('gold-display');
if (goldDisplay) goldDisplay.textContent = this.gold;

// Update global stats displays
const farthestFloorDisplay = document.getElementById('farthest-floor-display');
if (farthestFloorDisplay) farthestFloorDisplay.textContent = this.globalStats.farthestFloor;

// Update dungeon progress displays with selectors
// Read farthest floor directly from the stats display

const dungeonProgressEverfallDisplay = document.getElementById('everfall-progress-display');
if (dungeonProgressEverfallDisplay) {
    // Read current start floor
    const everfallStartFloor = this.dungeonProgress.everfall.startFloor;

    dungeonProgressEverfallDisplay.innerHTML = `
        <div style="display: flex; gap: 10px; align-items: center;">
            <span style="color: #94a3b8; font-size: 11px;">Start Floor:</span>
            <select id="everfall-start-selector" style="padding: 4px 8px; background: rgba(30, 41, 59, 0.9); color: #e2e8f0; border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 4px; font-family: 'Rajdhani', sans-serif; font-size: 11px; cursor: pointer;">
                ${Array.from({length: 50}, (_, i) => i + 1).map(floor =>
                    `<option value="${floor}" ${floor === everfallStartFloor ? 'selected' : ''}>${floor}</option>`
                ).join('')}
            </select>
        </div>
    `;

    document.getElementById('everfall-start-selector').addEventListener('change', (e) => {
        this.dungeonProgress.everfall.startFloor = parseInt(e.target.value);
        this.addLog(`Everfall start floor set to ${e.target.value}`, 'room');
    });
}

const dungeonProgressStoneforgeDisplay = document.getElementById('stoneforge-progress-display');
if (dungeonProgressStoneforgeDisplay) {
    // Read current start floor
    const stoneforgeStartFloor = this.dungeonProgress.stoneforge.startFloor;

    dungeonProgressStoneforgeDisplay.innerHTML = `
        <div style="display: flex; gap: 10px; align-items: center;">
            <span style="color: #94a3b8; font-size: 11px;">Start Floor:</span>
            <select id="stoneforge-start-selector" style="padding: 4px 8px; background: rgba(30, 41, 59, 0.9); color: #e2e8f0; border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 4px; font-family: 'Rajdhani', sans-serif; font-size: 11px; cursor: pointer;">
                ${Array.from({length: 50}, (_, i) => i + 1).map(floor =>
                    `<option value="${floor}" ${floor === stoneforgeStartFloor ? 'selected' : ''}>${floor}</option>`
                ).join('')}
            </select>
        </div>
    `;

    document.getElementById('stoneforge-start-selector').addEventListener('change', (e) => {
        this.dungeonProgress.stoneforge.startFloor = parseInt(e.target.value);
        this.addLog(`Stoneforge start floor set to ${e.target.value}`, 'room');
    });
}
const dungeonProgressUmbralDisplay = document.getElementById('umbral-progress-display');
if (dungeonProgressUmbralDisplay) {
    // Read current start floor
    const umbralStartFloor = this.dungeonProgress.umbral.startFloor;

    dungeonProgressUmbralDisplay.innerHTML = `
        <div style="display: flex; gap: 10px; align-items: center;">
            <span style="color: #94a3b8; font-size: 11px;">Start Floor:</span>
            <select id="umbral-start-selector" style="padding: 4px 8px; background: rgba(30, 41, 59, 0.9); color: #e2e8f0; border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 4px; font-family: 'Rajdhani', sans-serif; font-size: 11px; cursor: pointer;">
                ${Array.from({length: 50}, (_, i) => i + 1).map(floor =>
                    `<option value="${floor}" ${floor === umbralStartFloor ? 'selected' : ''}>${floor}</option>`
                ).join('')}
            </select>
        </div>
    `;

    document.getElementById('umbral-start-selector').addEventListener('change', (e) => {
        this.dungeonProgress.umbral.startFloor = parseInt(e.target.value);
        this.addLog(`Umbral Depths start floor set to ${e.target.value}`, 'room');
    });
}



this.party.forEach((member, index) => {
        const currentView = viewStates[index] || 'stats';

        const div = document.createElement('div');
        div.className = 'party-member';
                    div.className = 'party-member';
                    // Calculate gear score
                    let gearScore = 0;
                    const rarityPoints = { common: 2, uncommon: 4, rare: 6, epic: 8, legendary: 12, mythic: 16 };
                    Object.values(member.equipment).forEach(item => {
                        if (item) {
                            let basePoints = rarityPoints[item.rarity] || 0;
                            // Perfect mythics get 25 points instead of 16
                            if (item.rarity === 'mythic' && item.mythicStats && item.mythicStats.length === 4) {
                                basePoints = 25;
                            }
                            const multiplier = 1 + (item.level - 1) * 0.1;
                            gearScore += basePoints * multiplier;
                        }
                    });

                    // Add equipped keystone to gear score
                    const keystoneType = member.className.toLowerCase();
                    const equippedKeystone = this.equippedKeystones[keystoneType];
                    if (equippedKeystone) {
                        const basePoints = rarityPoints[equippedKeystone.rarity] || 0;
                        const multiplier = 1 + (equippedKeystone.level - 1) * 0.1;
                        gearScore += basePoints * multiplier;
                    }

                    gearScore = Math.round(gearScore);

                    div.innerHTML = `
    <div class="member-header">
        <span class="member-name">${member.name}</span>
        <div class="ability-status" data-member-index="${index}">
            <div class="ability-indicator" data-ability="1">
                <div class="ability-icon">1</div>
                <svg class="ability-cooldown-ring" viewBox="0 0 36 36">
                    <path class="ability-cooldown-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
                    <path class="ability-cooldown-fill" stroke-dasharray="0, 100" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
                </svg>
            </div>
            <div class="ability-indicator" data-ability="2">
                <div class="ability-icon">2</div>
                <svg class="ability-cooldown-ring" viewBox="0 0 36 36">
                    <path class="ability-cooldown-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
                    <path class="ability-cooldown-fill" stroke-dasharray="0, 100" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
                </svg>
            </div>
        </div>
        <div style="display: flex; gap: 8px; align-items: center; flex-shrink: 0;">
            <span style="font-size: 11px; color: #f59e0b; font-weight: 600; font-family: 'Orbitron', sans-serif; white-space: nowrap;">GS: ${gearScore}</span>
            <span class="member-level" style="cursor: pointer; background: rgba(99, 102, 241, 0.2); padding: 2px 8px; border-radius: 6px;" onclick="window.game.openSkillTree(${index})" title="Open Skill Tree (K)">Lvl ${member.level} ${member.skillPoints > 0 ? '(+' + member.skillPoints + ')' : ''}</span>
        </div>
    </div>
<div class="view-toggle">
                            <button class="view-btn active" data-view="stats">STATS</button>
                            <button class="view-btn" data-view="abilities">ABILITIES</button>
                            <button class="view-btn" data-view="equipment">GEAR</button>
                            <button class="view-btn" data-view="pet">PET</button>
                        </div>
                        <div class="stat-bars">
    <div class="stat-bar hp-bar">
    <div class="bar-fill" style="width: ${Math.min(100, Math.max(0, (member.hp / member.getTotalMaxHp()) * 100))}%"></div>
    <div class="bar-text">${member.shieldAmount && member.shieldAmount > 0 ? `${Math.round(member.hp + member.shieldAmount)}/${Math.round(member.getTotalMaxHp())} HP (üõ°Ô∏è${Math.round(member.shieldAmount)})` : `${Math.round(member.hp)}/${Math.round(member.getTotalMaxHp())} HP`}</div>
</div>
    <div class="stat-bar mana-bar">
    <div class="bar-fill" style="width: ${Math.min(100, Math.max(0, (member.mana / member.getTotalMaxMana()) * 100))}%"></div>
    <div class="bar-text">${Math.round(member.mana)}/${Math.round(member.getTotalMaxMana())} MANA</div>
</div>
   <div class="stat-bar xp-bar">
    <div class="bar-fill" style="width: ${(member.xp / member.maxXp) * 100}%"></div>
    <div class="bar-text">${member.xp}/${member.maxXp} XP</div>
</div>
</div>
                        <div class="view-content">
    <div class="member-stats-view ${currentView === 'stats' ? 'active' : ''}">
                                <div class="member-stats">
    <div class="stat" title="Damage Per Second - Your total damage output per second (ATK √ó ATK SPD)">
        <span class="stat-label" data-stat="dps">DPS:</span>
        <span class="stat-value" style="color: #f59e0b;">${Math.round(member.getTotalAttack() * (member.getTotalAttackSpeed ? member.getTotalAttackSpeed() : member.attackSpeed) * 100) / 100}</span>
    </div>
    <div class="stat" title="Attack - Base damage dealt per hit before defense reduction">
        <span class="stat-label" data-stat="attack">ATK:</span>
        <span class="stat-value attack">${member.getTotalAttack()}</span>
    </div>
    <div class="stat" title="Attack Speed - Number of attacks per second (higher = faster attacks)">
        <span class="stat-label" data-stat="attackspeed">ATK SPD:</span>
        <span class="stat-value speed">${(member.getTotalAttackSpeed ? member.getTotalAttackSpeed() : member.attackSpeed).toFixed(2)}/s</span>
    </div>
    <div class="stat" title="Defense - Reduces incoming damage. Formula: Damage Taken = Attack √ó (100 / (100 + Defense))">
        <span class="stat-label" data-stat="defense">DEF:</span>
        <span class="stat-value defense">${member.getTotalDefense()}</span>
    </div>
    <div class="stat" title="Critical Hit Chance - Percentage chance for attacks to deal critical damage">
        <span class="stat-label" data-stat="crit">CRIT:</span>
        <span class="stat-value" style="color: #f59e0b;">${member.getTotalCritChance().toFixed(2)}%</span>
    </div>
    <div class="stat" title="Critical Hit Damage - Damage multiplier when landing a critical hit (e.g., 200% = 2√ó damage)">
        <span class="stat-label" data-stat="critdmg">CRIT DMG:</span>
        <span class="stat-value" style="color: #ef4444;">${member.getTotalCritDamage().toFixed(2)}%</span>
    </div>
    <div class="stat" title="Dodge Chance - Percentage chance to completely avoid incoming attacks">
        <span class="stat-label" data-stat="dodge">DODGE:</span>
        <span class="stat-value" style="color: #10b981;">${member.getTotalDodgeChance().toFixed(2)}%</span>
    </div>
    <div class="stat" title="Lifesteal - Percentage of damage dealt that is restored as HP (e.g., 10% lifesteal on 100 damage = 10 HP healed)">
        <span class="stat-label" data-stat="lifesteal">LIFESTEAL:</span>
        <span class="stat-value" style="color: #a1a1aa;">${member.getTotalLifesteal()}%</span>
    </div>
    <div class="stat" title="Cooldown Reduction - Reduces ability cooldowns (e.g., 20% CDR makes 10s cooldown ‚Üí 8s)">
        <span class="stat-label" data-stat="cdr">CDR:</span>
        <span class="stat-value" style="color: #52525b;">${member.getTotalCDR().toFixed(2)}%</span>
    </div>
    <div class="stat" title="HP Regeneration - Restores stat √∑ 2 HP every 3 seconds during combat">
    <span class="stat-label" data-stat="hpregen">HP REGEN:</span>
    <span class="stat-value" style="color: #a1a1aa;">${member.getTotalHpRegen()}</span>
</div>
<div class="stat" title="Mana Regeneration - Restores stat √∑ 2 mana every 3 seconds during combat">
    <span class="stat-label" data-stat="manaregen">MANA REGEN:</span>
    <span class="stat-value" style="color: #3b82f6;">${member.getTotalManaRegen()}</span>
</div>
</div>
                            </div>
<div class="abilities-view ${currentView === 'abilities' ? 'active' : ''}">
    <div style="padding: 10px; background: rgba(15, 23, 42, 0.5); border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.1);">
        ${(() => {
            const charKey = member.className.toLowerCase();

            // Check for equipped ability rune
            let abilityRune = null;
            for (let i = 0; i < 5; i++) {
                const rune = this.equippedRunes[charKey][i];
                if (rune && rune.isAbilityRune) {
                    // Check if this rune matches the character's ability
                    const abilityMatch = {
                        'Tank': 'taunt',
                        'Healer': 'heal',
                        'Mage': 'fireball',
                        'Rogue': 'doublestrike'
                    };
                    if (rune.runeType === abilityMatch[member.className]) {
                        abilityRune = rune;
                        break;
                    }
                }
            }

            const abilityName = abilityRune ? abilityRune.name : member.skillName;
const abilityDescription = abilityRune ? abilityRune.description :
    (member.className === 'Tank' ? 'Taunts all enemies for <span style="color: #f59e0b; font-weight: 600;">5 seconds</span>, forcing them to attack the Tank. Grants <span style="color: #3b82f6; font-weight: 600;">+10 flat defense + 2% of total defense</span> during taunt (scales <span style="color: #a855f7; font-weight: 600;">+4% per rune tier</span>).' :
    member.className === 'Rogue' ? 'Strikes twice, dealing <span style="color: #ef4444; font-weight: 600;">150%</span> total attack damage (scales <span style="color: #a855f7; font-weight: 600;">+50% per rune tier</span>).' :
    member.className === 'Mage' ? 'Blasts all enemies for <span style="color: #ef4444; font-weight: 600;">80%</span> attack damage each (AOE) (scales <span style="color: #a855f7; font-weight: 600;">+20% per rune tier</span>).' :
    member.className === 'Healer' ? 'Heals an injured ally for <span style="color: #10b981; font-weight: 600;">5% of target max HP + (Bonus Mana √ó 0.4) + 10 flat</span> HP (scales <span style="color: #a855f7; font-weight: 600;">+2% max HP per rune tier</span>).' :
    member.className === 'Archer' ? 'Fires <span style="color: #f59e0b; font-weight: 600;">3 arrows</span> at enemies, each dealing <span style="color: #ef4444; font-weight: 600;">70%</span> attack damage (scales <span style="color: #a855f7; font-weight: 600;">+15% per rune tier</span>).' :
    member.className === 'Paladin' ? 'Grants all allies a shield equal to <span style="color: #3b82f6; font-weight: 600;">15% of their max HP</span> for <span style="color: #f59e0b; font-weight: 600;">4 seconds</span> (scales <span style="color: #a855f7; font-weight: 600;">+5% per rune tier</span>).' : '');

            return `
                <div style="margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid rgba(99, 102, 241, 0.2);">
                    <div style="font-weight: 700; color: ${abilityRune ? '#a855f7' : '#71717a'}; font-size: 14px; margin-bottom: 4px; font-family: 'Orbitron', sans-serif;">
                        1. ${abilityName}${abilityRune ? ' ' + abilityRune.emoji : ''}
                    </div>
                    <div style="font-size: 11px; color: #94a3b8; margin-bottom: 4px;">Mana Cost: <span style="color: #3b82f6; font-weight: 600;">${member.skillCost}</span></div>
                    <div style="font-size: 11px; color: #94a3b8;">Cooldown: <span style="color: #52525b; font-weight: 600;">${member.maxCooldown}s</span></div>
                </div>
                <div style="font-size: 11px; color: #e2e8f0; line-height: 1.4; margin-bottom: 10px;">
                    ${abilityDescription}
                </div>
            `;
        })()}
        ${(() => {
            const keystoneType = member.className.toLowerCase();
            const equippedKeystone = this.equippedKeystones[keystoneType];

            if (equippedKeystone) {
                return `
                    <div style="border-top: 1px solid rgba(99, 102, 241, 0.2); padding-top: 15px;">
                        <div style="font-weight: 700; color: #f59e0b; font-size: 14px; margin-bottom: 5px; font-family: 'Orbitron', sans-serif;">2. ${equippedKeystone.ability.name}</div>
                        <div style="font-size: 11px; color: #94a3b8; margin-bottom: 8px;">
                            Cooldown: <span style="color: #52525b; font-weight: 600;">${equippedKeystone.ability.cooldown}s</span> |
                            Mana Cost: <span style="color: ${equippedKeystone.ability.manaCost === 0 ? '#10b981' : '#52525b'}; font-weight: 600;">${equippedKeystone.ability.manaCost === 0 ? 'Free' : equippedKeystone.ability.manaCost}</span>
                        </div>
                        <div style="font-size: 12px; color: #e2e8f0; line-height: 1.5;">
                            ${equippedKeystone.ability.description}
                        </div>
                    </div>
                `;
            } else {
                return `
                    <div style="border-top: 1px solid rgba(99, 102, 241, 0.2); padding-top: 15px;">
                        <div style="font-weight: 700; color: #64748b; font-size: 14px; margin-bottom: 5px; font-family: 'Orbitron', sans-serif;">2. No Keystone Equipped</div>
                        <div style="font-size: 11px; color: #64748b; font-style: italic; line-height: 1.5;">
                            Equip a ${member.className} Keystone from the Keystones tab to unlock a powerful second ability!
                        </div>
                    </div>
                `;
            }
        })()}
    </div>
</div>
<div class="pet-view ${currentView === 'pet' ? 'active' : ''}">
    <div style="padding: 15px; background: rgba(15, 23, 42, 0.5); border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.1); height: 100%; display: flex; flex-direction: column;">
        ${(() => {
            const charKey = member.className.toLowerCase();
            const pet = this.equippedPets[charKey];
            const rarityColors = {
                common: '#94a3b8',
                uncommon: '#10b981',
                rare: '#3b82f6',
                epic: '#a855f7',
                legendary: '#f59e0b'
            };

            if (pet) {
                const bonus = pet.getCurrentBonus();
                // Format stat name properly
                const statName = pet.bonusType === 'attackSpeed' ? 'Attack Speed' :
                                pet.bonusType === 'critChance' ? 'Crit Chance' :
                                pet.bonusType === 'critDamage' ? 'Crit Damage' :
                                pet.bonusType.charAt(0).toUpperCase() + pet.bonusType.slice(1);

                const bonusDisplay = ['attackSpeed', 'critChance', 'dodge', 'critDamage'].includes(pet.bonusType)
                    ? `+${bonus}%`
                    : `+${bonus}`;

                return `
                    <div style="text-align: center; margin-bottom: 20px; flex-shrink: 0;">
                        <img src="${pet.image}"
                            style="width: 140px; height: 140px; border-radius: 16px; border: 4px solid ${rarityColors[pet.rarity]}; display: block; margin: 0 auto;">
                    </div>
                    <div style="text-align: center; margin-bottom: 15px; flex-shrink: 0;">
                        <div style="font-weight: 700; color: ${rarityColors[pet.rarity]}; font-size: 20px; margin-bottom: 6px;">
                            ${pet.name}
                        </div>
                        <div style="font-size: 13px; color: #94a3b8;">
                            ${pet.rarity.charAt(0).toUpperCase() + pet.rarity.slice(1)} ‚Ä¢ Level ${pet.level}
                        </div>
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.3); padding: 14px; border-radius: 8px; margin-bottom: auto; flex-shrink: 0;">
                        <div style="color: #10b981; font-size: 15px; text-align: center; font-weight: 600;">
                            ${pet.bonusType === 'attackSpeed' ? 'Attack Speed' :
                              pet.bonusType === 'critChance' ? 'Crit Chance' :
                              pet.bonusType === 'critDamage' ? 'Crit Damage' :
                              pet.bonusType === 'lifesteal' ? 'Lifesteal' :
                              pet.bonusType === 'manaRegen' ? 'Mana Regen' :
                              pet.bonusType === 'hpRegen' ? 'HP Regen' :
                              pet.bonusType === 'cdr' ? 'CDR' :
                              statName}: ${bonusDisplay}
                        </div>
                    </div>
                    <button onclick="window.game.unequipPet('${charKey}')"
                        style="width: 100%; padding: 14px; background: rgba(239, 68, 68, 0.2);
                        color: #ef4444; border: 2px solid #ef4444; border-radius: 8px; cursor: pointer;
                        font-size: 14px; font-weight: 700; font-family: 'Orbitron', sans-serif; transition: all 0.2s ease; margin-top: 15px; flex-shrink: 0;">
                        UNEQUIP PET
                    </button>
                `;
            } else {
                return `
                    <div style="text-align: center; padding: 40px;">
                        <div style="font-size: 64px; color: #475569; margin-bottom: 15px;">üêæ</div>
                        <div style="color: #64748b; font-style: italic; font-size: 14px;">
                            No pet equipped
                        </div>
                        <div style="font-size: 11px; color: #52525b; margin-top: 8px;">
                            Visit the Pet Collection tab to equip a pet
                        </div>
                    </div>
                `;
            }
        })()}
    </div>
</div>
<div class="equipment-view ${currentView === 'equipment' ? 'active' : ''}">
    <div class="equipment">
                                    <div class="equipment-slot" data-member-index="${index}" data-slot="weapon">
                                        <span>Weapon:</span>
                                        <span class="equipment-name ${member.equipment.weapon?.rarity || ''}">${member.equipment.weapon?.blessed ? '‚ú® ' : ''}${member.equipment.weapon?.name || 'None'}</span>
                                    </div>
                                    <div class="equipment-slot" data-member-index="${index}" data-slot="chest">
                                        <span>Chest:</span>
                                        <span class="equipment-name ${member.equipment.chest?.rarity || ''}">${member.equipment.chest?.blessed ? '‚ú® ' : ''}${member.equipment.chest?.name || 'None'}</span>
                                    </div>
                                    <div class="equipment-slot" data-member-index="${index}" data-slot="helmet">
                                        <span>Helmet:</span>
                                        <span class="equipment-name ${member.equipment.helmet?.rarity || ''}">${member.equipment.helmet?.blessed ? '‚ú® ' : ''}${member.equipment.helmet?.name || 'None'}</span>
                                    </div>
                                    <div class="equipment-slot" data-member-index="${index}" data-slot="gloves">
                                        <span>Gloves:</span>
                                        <span class="equipment-name ${member.equipment.gloves?.rarity || ''}">${member.equipment.gloves?.blessed ? '‚ú® ' : ''}${member.equipment.gloves?.name || 'None'}</span>
                                    </div>
                                    <div class="equipment-slot" data-member-index="${index}" data-slot="boots">
                                        <span>Boots:</span>
                                        <span class="equipment-name ${member.equipment.boots?.rarity || ''}">${member.equipment.boots?.blessed ? '‚ú® ' : ''}${member.equipment.boots?.name || 'None'}</span>
                                    </div>
                                    <div class="equipment-slot" data-member-index="${index}" data-slot="amulet">
                                        <span>Amulet:</span>
                                        <span class="equipment-name ${member.equipment.amulet?.rarity || ''}">${member.equipment.amulet?.blessed ? '‚ú® ' : ''}${member.equipment.amulet?.name || 'None'}</span>
                                    </div>
                                    <div class="equipment-slot" data-member-index="${index}" data-slot="belt">
                                        <span>Belt:</span>
                                        <span class="equipment-name ${member.equipment.belt?.rarity || ''}">${member.equipment.belt?.blessed ? '‚ú® ' : ''}${member.equipment.belt?.name || 'None'}</span>
                                    </div>
                                    <div class="equipment-slot" data-member-index="${index}" data-slot="ring1">
                                        <span>Ring 1:</span>
                                        <span class="equipment-name ${member.equipment.ring1?.rarity || ''}">${member.equipment.ring1?.blessed ? '‚ú® ' : ''}${member.equipment.ring1?.name || 'None'}</span>
                                    </div>
<div class="equipment-slot" data-member-index="${index}" data-slot="ring2">
                                        <span>Ring 2:</span>
                                        <span class="equipment-name ${member.equipment.ring2?.rarity || ''}">${member.equipment.ring2?.blessed ? '‚ú® ' : ''}${member.equipment.ring2?.name || 'None'}</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                    container.appendChild(div);
                });

                // Add view toggle functionality with immediate response
                document.querySelectorAll('.view-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();

                        const memberIndex = btn.getAttribute('data-member');
                        const view = btn.getAttribute('data-view');
                        const memberCard = btn.closest('.party-member');

                        // Check if mirror mode is enabled
                        const mirrorEnabled = document.getElementById('mirror-toggle')?.checked;

                        if (mirrorEnabled) {
                            // Mirror mode: switch all characters to the same view
                            document.querySelectorAll('.party-member').forEach(card => {
                                // Toggle buttons
                                card.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
                                const targetBtn = card.querySelector(`.view-btn[data-view="${view}"]`);
                                if (targetBtn) targetBtn.classList.add('active');

                                // Toggle views
                                card.querySelectorAll('.member-stats-view, .abilities-view, .equipment-view, .pet-view').forEach(v => v.classList.remove('active'));
                                if (view === 'stats') {
                                    card.querySelector('.member-stats-view')?.classList.add('active');
                                } else if (view === 'abilities') {
                                    card.querySelector('.abilities-view')?.classList.add('active');
                                } else if (view === 'equipment') {
                                    card.querySelector('.equipment-view')?.classList.add('active');
                                } else if (view === 'pet') {
                                    card.querySelector('.pet-view')?.classList.add('active');
                                }
                            });
                        } else {
                            // Normal mode: only switch the clicked character's view
                            // Toggle buttons
                            memberCard.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
                            btn.classList.add('active');

                            // Toggle views
                            memberCard.querySelectorAll('.member-stats-view, .abilities-view, .equipment-view, .pet-view').forEach(v => v.classList.remove('active'));
                            if (view === 'stats') {
                                memberCard.querySelector('.member-stats-view').classList.add('active');
                            } else if (view === 'abilities') {
                                memberCard.querySelector('.abilities-view').classList.add('active');
                            } else if (view === 'equipment') {
                                memberCard.querySelector('.equipment-view').classList.add('active');
                            } else if (view === 'pet') {
                                memberCard.querySelector('.pet-view').classList.add('active');
                            }
                        }
                    }, { capture: true });
                });

                // Add synchronized scrolling when mirror mode is enabled
                const partyMembers = document.querySelectorAll('.party-member');
                partyMembers.forEach((card, index) => {
                    card.addEventListener('scroll', (e) => {
                        const mirrorEnabled = document.getElementById('mirror-toggle')?.checked;
                        if (mirrorEnabled) {
                            const scrollTop = card.scrollTop;
                            // Sync scroll position to all other party member cards
                            partyMembers.forEach((otherCard, otherIndex) => {
                                if (otherIndex !== index) {
                                    otherCard.scrollTop = scrollTop;
                                }
                            });
                        }
                    });
                });

                // Add loot filter checkbox event listeners
                document.querySelectorAll('.filter-checkbox').forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => {
                        const rarity = checkbox.getAttribute('data-rarity');
                        this.lootFilter[rarity] = checkbox.checked;

                        // Log the change
                        if (checkbox.checked) {
                            this.addLog(`Loot filter: ${rarity} items will be collected`, 'room');
                        } else {
                            this.addLog(`Loot filter: ${rarity} items will auto-sell`, 'room');
                        }
                    });
                });

                // Add tooltip event listeners to equipment slots
                this.addEquipmentTooltips();
            }

            handleCanvasMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const tooltip = document.getElementById('enemy-tooltip');
                let hoveredEnemy = null;

                // Check if mouse is over any enemy
                this.enemies.forEach(enemy => {
                    if (!enemy.isAlive || !enemy.sprite || enemy.sprite.screenDrawX === undefined) return;

                    const dx = mouseX - enemy.sprite.screenDrawX;
                    const dy = mouseY - enemy.sprite.screenDrawY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 25) { // Hit radius
                        hoveredEnemy = enemy;
                    }
                });

if (hoveredEnemy) {
    // Show enemy tooltip
    const attack = hoveredEnemy.getTotalAttack ? hoveredEnemy.getTotalAttack() : hoveredEnemy.attack;
    const defense = hoveredEnemy.getTotalDefense ? hoveredEnemy.getTotalDefense() : hoveredEnemy.defense;

    // Calculate drop chance and rarity odds based on actual game code
    let dropChance = '5%';
    let rarityOdds = '';

    // Check if we're in Divine Arena dungeon
    if (this.currentDungeon === 'endlessblessings' && this.endlessKillCount !== undefined) {
        const kills = this.endlessKillCount;
        dropChance = 'No individual drops';

        // Show detailed loot system breakdown
        rarityOdds = `
            <div style="color: #a855f7; font-weight: 700; font-size: 12px; margin-top: 4px; margin-bottom: 6px; border-top: 1px solid rgba(168, 85, 247, 0.3); padding-top: 6px;">
                üìä Endless Arena Loot System
            </div>
            <div style="font-size: 10px; line-height: 1.6;">
                <div style="color: ${kills < 10 ? '#ef4444' : '#94a3b8'}; ${kills < 10 ? 'font-weight: 600;' : ''}">
                    üîí Kills 1-9: No loot (Survive to 10!)
                </div>
                <div style="color: ${kills >= 10 && kills <= 20 ? '#10b981' : '#94a3b8'}; ${kills >= 10 && kills <= 20 ? 'font-weight: 600;' : ''}">
                    ‚úì Kills 10-20: Item Lvl ~60-80 | 50% <span style="color: #3b82f6;">Rare</span>, 35% <span style="color: #a855f7;">Epic</span>, 15% <span style="color: #f59e0b;">Legendary</span>
                </div>
                <div style="color: ${kills >= 21 && kills < 40 ? '#10b981' : '#94a3b8'}; ${kills >= 21 && kills < 40 ? 'font-weight: 600;' : ''}">
                    ‚úì Kills 21-39: Item Lvl ~80-100 | 35% <span style="color: #3b82f6;">Rare</span>, 45% <span style="color: #a855f7;">Epic</span>, 20% <span style="color: #f59e0b;">Legendary</span>, 0.1% <span style="color: #ec4899;">Mythic</span>
                </div>
                <div style="color: ${kills >= 40 && kills < 60 ? '#10b981' : '#94a3b8'}; ${kills >= 40 && kills < 60 ? 'font-weight: 600;' : ''}">
                    ‚úì Kills 40-59: Item Lvl ~100-120 | 20% <span style="color: #3b82f6;">Rare</span>, 50% <span style="color: #a855f7;">Epic</span>, 30% <span style="color: #f59e0b;">Legendary</span>, 0.2% <span style="color: #ec4899;">Mythic</span>
                </div>
                <div style="color: ${kills >= 60 && kills < 80 ? '#10b981' : '#94a3b8'}; ${kills >= 60 && kills < 80 ? 'font-weight: 600;' : ''}">
                    ‚úì Kills 60-79: Item Lvl ~120-140 | 10% <span style="color: #3b82f6;">Rare</span>, 50% <span style="color: #a855f7;">Epic</span>, 40% <span style="color: #f59e0b;">Legendary</span>, 0.3% <span style="color: #ec4899;">Mythic</span>
                </div>
                <div style="color: ${kills >= 80 && kills < 100 ? '#10b981' : '#94a3b8'}; ${kills >= 80 && kills < 100 ? 'font-weight: 600;' : ''}">
                    ‚úì Kills 80-99: Item Lvl ~140-160 | 5% <span style="color: #3b82f6;">Rare</span>, 45% <span style="color: #a855f7;">Epic</span>, 50% <span style="color: #f59e0b;">Legendary</span>, 0.5% <span style="color: #ec4899;">Mythic</span>
                </div>
                <div style="color: ${kills >= 100 && kills < 120 ? '#10b981' : '#94a3b8'}; ${kills >= 100 && kills < 120 ? 'font-weight: 600;' : ''}">
                    ‚úì Kills 100-119: Item Lvl ~160-180 | 34% <span style="color: #a855f7;">Epic</span>, 65% <span style="color: #f59e0b;">Legendary</span>, 1% <span style="color: #ec4899;">Mythic</span>
                </div>
                <div style="color: ${kills >= 120 && kills < 140 ? '#10b981' : '#94a3b8'}; ${kills >= 120 && kills < 140 ? 'font-weight: 600;' : ''}">
                    ‚úì Kills 120-139: Item Lvl ~180-200 | 23% <span style="color: #a855f7;">Epic</span>, 75% <span style="color: #f59e0b;">Legendary</span>, 2% <span style="color: #ec4899;">Mythic</span>
                </div>
                <div style="color: ${kills >= 140 && kills < 160 ? '#10b981' : '#94a3b8'}; ${kills >= 140 && kills < 160 ? 'font-weight: 600;' : ''}">
                    ‚úì Kills 140-159: Item Lvl ~200-220 | 12% <span style="color: #a855f7;">Epic</span>, 85% <span style="color: #f59e0b;">Legendary</span>, 3% <span style="color: #ec4899;">Mythic</span>
                </div>
                <div style="color: ${kills >= 160 && kills < 180 ? '#10b981' : '#94a3b8'}; ${kills >= 160 && kills < 180 ? 'font-weight: 600;' : ''}">
                    ‚úì Kills 160-179: Item Lvl ~220-240 | 5% <span style="color: #a855f7;">Epic</span>, 90% <span style="color: #f59e0b;">Legendary</span>, 5% <span style="color: #ec4899;">Mythic</span>
                </div>
                <div style="color: ${kills >= 180 && kills < 200 ? '#10b981' : '#94a3b8'}; ${kills >= 180 && kills < 200 ? 'font-weight: 600;' : ''}">
                    ‚úì Kills 180-199: Item Lvl ~240-260 | 3% <span style="color: #a855f7;">Epic</span>, 90% <span style="color: #f59e0b;">Legendary</span>, 7% <span style="color: #ec4899;">Mythic</span>
                </div>
                <div style="color: ${kills >= 200 ? '#10b981' : '#94a3b8'}; ${kills >= 200 ? 'font-weight: 600;' : ''}">
                    ‚≠ê Kills 200+: Item Lvl ~260+ | 2% <span style="color: #a855f7;">Epic</span>, 88% <span style="color: #f59e0b;">Legendary</span>, 10% <span style="color: #ec4899;">Mythic</span>
                </div>
            </div>
            <div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(168, 85, 247, 0.3); color: #fbbf24; font-weight: 700; font-size: 11px;">
                üíÄ Current Progress: ${kills} kills
            </div>
        `;
    } else if (hoveredEnemy.isBoss) {
        dropChance = '100% (Boss Loot)';
        rarityOdds = '<span style="color: #94a3b8;">Common: 30%</span>, <span style="color: #10b981;">Uncommon: 30%</span>, <span style="color: #3b82f6;">Rare: 30%</span>, <span style="color: #a855f7;">Epic: 9%</span>, <span style="color: #f59e0b;">Legendary: 1%</span>';
    } else if (hoveredEnemy.name === 'Treasure Guardian') {
        dropChance = '100%';
        rarityOdds = '<span style="color: #94a3b8;">Common: ~50-70%</span>, <span style="color: #10b981;">Uncommon: 20%</span>, <span style="color: #3b82f6;">Rare: 8%</span>, <span style="color: #a855f7;">Epic: 2%</span>, <span style="color: #f59e0b;">Legendary: 0.1%</span>, <span style="color: #ef4444;">Mythic: 0.1%</span>';
    } else {
        // Regular enemies - 5% drop chance with floor scaling
        const floorBonus = Math.min(this.dungeonFloor * 0.2, 20);
        const commonChance = Math.max(0, 69.9 - floorBonus);
        rarityOdds = `<span style="color: #94a3b8;">Common: ${commonChance.toFixed(1)}%</span>, <span style="color: #10b981;">Uncommon: 20%</span>, <span style="color: #3b82f6;">Rare: 8%</span>, <span style="color: #a855f7;">Epic: 2%</span>, <span style="color: #f59e0b;">Legendary: 0.1%</span>`;
    }

    let tooltipHTML = `
        <div class="tooltip-header" style="color: ${hoveredEnemy.color}">${hoveredEnemy.name}</div>
        <div class="tooltip-stats">
            <div class="tooltip-stat">HP: ${Math.floor(hoveredEnemy.hp)}/${hoveredEnemy.maxHp}</div>
            <div class="tooltip-stat">Attack: ${attack}</div>
            <div class="tooltip-stat">Defense: ${defense}</div>
            <div class="tooltip-stat">Attack Speed: ${hoveredEnemy.attackSpeed.toFixed(1)}/s</div>
            <div class="tooltip-stat" style="border-top: 1px solid rgba(99, 102, 241, 0.2); margin-top: 8px; padding-top: 8px; color: #f59e0b;">Loot Drop: ${dropChance}</div>
            <div class="tooltip-stat" style="font-size: 11px; color: #94a3b8; line-height: 1.4;">${rarityOdds}</div>
        </div>
    `;

                    tooltip.innerHTML = tooltipHTML;
                    tooltip.classList.add('show');
                    tooltip.style.left = `${e.clientX + 10}px`;
                    tooltip.style.top = `${e.clientY + 10}px`;
                } else {
                    tooltip.classList.remove('show');
                }
            }

addEquipmentTooltips() {
    const tooltip = document.getElementById('equipment-tooltip');

    // Get all equipment slots and replace them with clones (removes old listeners)
    const slots = Array.from(document.querySelectorAll('.equipment-slot'));
    const newSlots = [];

    slots.forEach(slot => {
        const newSlot = slot.cloneNode(true);
        slot.parentNode.replaceChild(newSlot, slot);
        newSlots.push(newSlot);
    });

    // Now add fresh listeners to the new slots
    newSlots.forEach(slot => {
        slot.addEventListener('mouseenter', (e) => {
            const memberIndex = parseInt(slot.getAttribute('data-member-index'));
            const slotName = slot.getAttribute('data-slot');

            if (memberIndex === undefined || !slotName) return;

            const member = this.party[memberIndex];
            if (!member) return;

            const item = member.equipment[slotName];
            if (!item || !item.name) return;

            let tooltipHTML = `
                <div class="tooltip-header ${item.rarity}">${item.name}</div>
                <div class="tooltip-stats">
            `;

            // Add mythic stat indicator if mythic item
if (item.rarity === 'mythic' && (item.mythicStat || item.mythicStats)) {
    const mythicStatNames = item.mythicStats ? item.mythicStats.map(s => s.toUpperCase()).join(', ') : item.mythicStat.toUpperCase();
    const isPerfect = item.mythicStats && item.mythicStats.length === 4;
    const statWord = (item.mythicStats && item.mythicStats.length > 1) ? 'STATS' : 'STAT';
    const prefix = isPerfect ? '‚ú® PERFECT MYTHIC' : '‚ö° MYTHIC';
    const bgColor = isPerfect ? 'rgba(255, 215, 0, 0.15)' : 'rgba(201, 16, 167, 0.1)';
    const borderColor = isPerfect ? '#ffd700' : '#c910a7';

    tooltipHTML += `<div style="color: ${isPerfect ? '#ffd700' : '#c910a7'}; font-size: 11px; font-weight: 700; margin-bottom: 8px; text-align: center; border: 1px solid ${borderColor}; border-radius: 4px; padding: 4px; background: ${bgColor}; ${isPerfect ? 'animation: legendary-pulse 2s ease-in-out infinite;' : ''}">${prefix} ${statWord}: ${mythicStatNames} ‚ú®</div>`;
}

            if (item.attack) tooltipHTML += `<div class="tooltip-stat">+${item.attack} Attack ${this.getStatRollPercent(item, 'attack')}</div>`;
            if (item.attackSpeed) tooltipHTML += `<div class="tooltip-stat">+${item.attackSpeed} Attack Speed ${this.getStatRollPercent(item, 'attackSpeed')}</div>`;
            if (item.hp) tooltipHTML += `<div class="tooltip-stat">+${item.hp} HP ${this.getStatRollPercent(item, 'hp')}</div>`;
            if (item.mana) tooltipHTML += `<div class="tooltip-stat">+${item.mana} Mana ${this.getStatRollPercent(item, 'mana')}</div>`;
            if (item.defense) tooltipHTML += `<div class="tooltip-stat">+${item.defense} Defense ${this.getStatRollPercent(item, 'defense')}</div>`;
            if (item.critChance) tooltipHTML += `<div class="tooltip-stat">+${item.critChance}% Crit Chance ${this.getStatRollPercent(item, 'critChance')}</div>`;
            if (item.critDamage) tooltipHTML += `<div class="tooltip-stat">+${item.critDamage}% Crit Damage ${this.getStatRollPercent(item, 'critDamage')}</div>`;
            if (item.dodgeChance) tooltipHTML += `<div class="tooltip-stat">+${item.dodgeChance}% Dodge Chance ${this.getStatRollPercent(item, 'dodgeChance')}</div>`;
            if (item.lifesteal) tooltipHTML += `<div class="tooltip-stat">+${item.lifesteal}% Lifesteal ${this.getStatRollPercent(item, 'lifesteal')}</div>`;
            if (item.hpRegen) tooltipHTML += `<div class="tooltip-stat">+${item.hpRegen} HP Regen ${this.getStatRollPercent(item, 'hpRegen')}</div>`;
if (item.manaRegen) tooltipHTML += `<div class="tooltip-stat">+${item.manaRegen} Mana Regen ${this.getStatRollPercent(item, 'manaRegen')}</div>`;
            if (item.cdr) tooltipHTML += `<div class="tooltip-stat">+${item.cdr}% CDR ${this.getStatRollPercent(item, 'cdr')}</div>`;

            // Add blessed status indicator
            if (item.blessed) {
                tooltipHTML += `<div style="color: #a855f7; font-size: 11px; font-weight: 700; margin-top: 8px; text-align: center; border: 1px solid #a855f7; border-radius: 4px; padding: 4px; background: rgba(168, 85, 247, 0.1);">‚ú® BLESSED - One stat increased by 50%</div>`;
            }

            tooltipHTML += `</div>`;

            tooltip.innerHTML = tooltipHTML;
            tooltip.classList.add('show');

            const rect = slot.getBoundingClientRect();
            const tooltipWidth = 250;
            const tooltipHeight = 200;
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;

            if (rect.right + tooltipWidth + 10 > screenWidth) {
                tooltip.style.left = `${rect.left - tooltipWidth - 10}px`;
            } else {
                tooltip.style.left = `${rect.right + 10}px`;
            }

            if (rect.bottom + tooltipHeight + 10 > screenHeight) {
                tooltip.style.top = `${rect.top - tooltipHeight - 10}px`;
            } else {
                tooltip.style.top = `${rect.top}px`;
            }
        });

        slot.addEventListener('mouseleave', () => {
            tooltip.classList.remove('show');
        });

        // Add click handler for gear context menu
        slot.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();

            const memberIndex = parseInt(slot.getAttribute('data-member-index'));
            const slotName = slot.getAttribute('data-slot');

            if (memberIndex === undefined || !slotName) return;

            const member = this.party[memberIndex];
            if (!member) return;

            const item = member.equipment[slotName];
            if (!item || !item.name) return;

            // Hide tooltip when clicking
            tooltip.classList.remove('show');

            // Show context menu
            this.showGearContextMenu(e, memberIndex, slotName, item);
        });
    });
}


showGearContextMenu(e, memberIndex, slotName, item) {
    e.preventDefault();
    e.stopPropagation();

    const contextMenu = document.getElementById('gear-context-menu');
    const game = this; // Capture this reference

    // Calculate blessing cost based on item level
    const blessingCost = item.level || 25;

    contextMenu.innerHTML = `
        <div class="gear-context-menu-item unequip" data-action="unequip">
            Unequip
        </div>
        <div class="gear-context-menu-item bless" data-action="bless">
            ‚≠ê Bless Item (${blessingCost})
        </div>
    `;

    // Position the context menu
    const screenWidth = window.innerWidth;
    const screenHeight = window.innerHeight;
    const menuWidth = 200;
    const menuHeight = 100;

    let left = e.clientX;
    let top = e.clientY;

    if (left + menuWidth > screenWidth) {
        left = screenWidth - menuWidth - 10;
    }

    if (top + menuHeight > screenHeight) {
        top = screenHeight - menuHeight - 10;
    }

    contextMenu.style.left = `${left}px`;
    contextMenu.style.top = `${top}px`;
    contextMenu.classList.add('show');

    // Add click handlers to menu items
    contextMenu.querySelectorAll('.gear-context-menu-item').forEach(menuItem => {
        menuItem.addEventListener('click', (clickEvent) => {
            clickEvent.preventDefault();
            clickEvent.stopPropagation();

            const action = menuItem.getAttribute('data-action');

            if (action === 'unequip') {
                game.unequipItem(memberIndex, slotName);
            } else if (action === 'bless') {
                game.openBlessTab(memberIndex, slotName, item);
            }

            contextMenu.classList.remove('show');
        });
    });

    // Close menu when clicking outside
    const closeMenu = (event) => {
        if (!contextMenu.contains(event.target)) {
            contextMenu.classList.remove('show');
            document.removeEventListener('click', closeMenu);
        }
    };

    setTimeout(() => {
        document.addEventListener('click', closeMenu);
    }, 10);
}

unequipItem(memberIndex, slotName) {
    const member = this.party[memberIndex];
    if (!member) return;

    const item = member.equipment[slotName];
    if (!item) return;

    // Hide context menu
    const contextMenu = document.getElementById('gear-context-menu');
    if (contextMenu) contextMenu.classList.remove('show');

    // Add to inventory
    this.inventory.push(item);

    // Remove from equipment
    member.equipment[slotName] = null;

    // Recalculate stats for ALL party members to ensure everything updates
    this.party.forEach(m => {
        if (m.updateStats) {
            m.updateStats();
        }
    });

    this.addLog(`Unequipped ${item.name} from ${member.name}`, 'loot');
    this.rebuildUI(); // Force full UI rebuild to update equipment display

    // Refresh inventory display if user is viewing it
    const inventorySection = document.getElementById('loot-inventory-section');
    if (inventorySection && inventorySection.style.display !== 'none') {
        this.showInventory();
    }

    saveGame();
}

openBlessTab(memberIndex, slotName, item) {
    // Switch to bless tab
    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
    document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));

    document.querySelector('[data-tab="bless"]').classList.add('active');
    document.getElementById('bless-tab').classList.add('active');

    // Show the selected item in the bless tab
    const blessItemSelected = document.getElementById('bless-item-selected');
    const blessCurrencyDisplay = document.getElementById('blessing-currency-display');

    blessCurrencyDisplay.textContent = this.blessingCurrency || 0;

    // Calculate blessing cost based on item level
    const blessingCost = item.level || 25;

    blessItemSelected.style.display = 'block';
    blessItemSelected.innerHTML = `
        <div style="display: flex; gap: 20px; align-items: center; margin-bottom: 20px;">
            <div style="flex: 1;">
                <div style="font-size: 20px; font-weight: 700; color: ${this.getRarityColor(item.rarity)}; margin-bottom: 10px; font-family: 'Orbitron', sans-serif;">${item.name}</div>
                <div style="font-size: 12px; color: #94a3b8; margin-bottom: 15px;">Equipped on ${this.party[memberIndex].name} ‚Ä¢ ${slotName}</div>
                <div style="font-size: 13px; color: #e2e8f0; line-height: 1.8; max-height: 200px; overflow-y: auto;">
                    ${item.attack ? `<div>‚öîÔ∏è +${item.attack} Attack</div>` : ''}
                    ${item.hp ? `<div>‚ù§Ô∏è +${item.hp} HP</div>` : ''}
                    ${item.mana ? `<div>üíô +${item.mana} Mana</div>` : ''}
                    ${item.defense ? `<div>üõ°Ô∏è +${item.defense} Defense</div>` : ''}
                    ${item.attackSpeed ? `<div>‚ö° +${item.attackSpeed} Attack Speed</div>` : ''}
                    ${item.critChance ? `<div>üí• +${item.critChance}% Crit Chance</div>` : ''}
                    ${item.critDamage ? `<div>üí¢ +${item.critDamage}% Crit Damage</div>` : ''}
                    ${item.dodgeChance ? `<div>üåÄ +${item.dodgeChance}% Dodge</div>` : ''}
                    ${item.lifesteal ? `<div>ü©∏ +${item.lifesteal}% Lifesteal</div>` : ''}
                    ${item.hpRegen ? `<div>üíö +${item.hpRegen} HP Regen</div>` : ''}
                    ${item.manaRegen ? `<div>üíú +${item.manaRegen} Mana Regen</div>` : ''}
                    ${item.cdr ? `<div>‚è±Ô∏è +${item.cdr}% CDR</div>` : ''}
                </div>
            </div>
        </div>

        <button id="bless-button-${memberIndex}-${slotName}" onclick="window.game.blessItem(${memberIndex}, '${slotName}')"
            style="width: 100%; padding: 16px; background: linear-gradient(135deg, #a855f7, #8b5cf6);
            color: white; border: none; border-radius: 10px; cursor: pointer;
            font-size: 16px; font-weight: 700; font-family: 'Orbitron', sans-serif;
            box-shadow: 0 4px 20px rgba(168, 85, 247, 0.4); transition: all 0.3s ease;">
            ‚ú® Bless (${blessingCost} üíé)
        </button>

        <div style="margin-top: 15px; padding: 15px; background: rgba(168, 85, 247, 0.1); border-radius: 8px; border: 1px solid rgba(168, 85, 247, 0.3);">
            <div style="font-size: 12px; color: #c4b5fd; line-height: 1.6;">
                <strong>Blessing Effects:</strong><br>
                ‚Ä¢ +50% to ONE random stat on this item<br>
                ‚Ä¢ Adds a purple blessing glow<br>
                ‚Ä¢ Permanent upgrade (cannot be removed)<br>
                ‚Ä¢ Works on all rarities, including Mythic!<br>
                ${item.rarity === 'mythic' ? '<br><strong style="color: #c910a7;">‚ö° MYTHIC BONUS:</strong><br>‚Ä¢ Can boost a 200% stat to 250%!' : ''}
            </div>
        </div>
    `;
}

blessItem(memberIndex, slotName) {
    const member = this.party[memberIndex];
    if (!member) return;

    const item = member.equipment[slotName];
    if (!item) return;

    // Calculate blessing cost based on item level
    const blessingCost = item.level || 25;

    // Check if player has enough currency
    if ((this.blessingCurrency || 0) < blessingCost) {
        this.addLog(`Not enough Blessing Currency! Need ${blessingCost}.`, 'loot');
        return;
    }

    // Check if already blessed
    if (item.blessed) {
        this.addLog(`${item.name} is already blessed!`, 'loot');
        return;
    }

    // Trigger blessing animation
    const buttonId = `bless-button-${memberIndex}-${slotName}`;
    const button = document.getElementById(buttonId);
    if (button) {
        button.classList.add('blessing-animation');
        button.style.pointerEvents = 'none';

        // Create particle effect
        const buttonRect = button.getBoundingClientRect();
        for (let i = 0; i < 20; i++) {
            setTimeout(() => {
                this.createBlessingParticle(buttonRect.left + buttonRect.width / 2, buttonRect.top + buttonRect.height / 2);
            }, i * 30);
        }
    }

    // Deduct currency
    this.blessingCurrency -= blessingCost;

    // Capture stats BEFORE blessing
    const statsBefore = {
        attack: item.attack || 0,
        hp: item.hp || 0,
        mana: item.mana || 0,
        defense: item.defense || 0,
        attackSpeed: item.attackSpeed || 0,
        critChance: item.critChance || 0,
        critDamage: item.critDamage || 0,
        dodgeChance: item.dodgeChance || 0,
        lifesteal: item.lifesteal || 0,
        hpRegen: item.hpRegen || 0,
        manaRegen: item.manaRegen || 0,
        cdr: item.cdr || 0,
        rarity: item.rarity
    };

    // Apply blessing
    item.blessed = true;

    // Collect all non-zero stats from the item
    const possibleStats = [];
    const statList = ['attack', 'hp', 'mana', 'defense', 'attackSpeed', 'critChance',
                      'critDamage', 'dodgeChance', 'lifesteal', 'hpRegen', 'manaRegen', 'cdr'];

    statList.forEach(stat => {
        if (item[stat] && item[stat] > 0) {
            possibleStats.push(stat);
        }
    });

    // Pick one random stat to bless
    let blessedStat = null;
    let blessedStatIncrease = 0;

    if (possibleStats.length > 0) {
        blessedStat = possibleStats[Math.floor(Math.random() * possibleStats.length)];
        const oldValue = item[blessedStat];
        const newValue = Math.round(oldValue * 1.5); // 50% increase
        blessedStatIncrease = newValue - oldValue;
        item[blessedStat] = newValue;

        // Store which stat was blessed on the item
        item.blessedStat = blessedStat;

        this.addLog(`‚ú® Blessed ${item.name}! ${blessedStat.toUpperCase()} increased by 50%!`, 'loot');
    }

    // Recalculate stats for ALL party members to ensure everything updates
    this.party.forEach(m => {
        if (m.updateStats) {
            m.updateStats();
        }
    });

    // Delay UI update to allow animation to play
    setTimeout(() => {
        // Capture stats AFTER blessing
        const statsAfter = {
            attack: item.attack || 0,
            hp: item.hp || 0,
            mana: item.mana || 0,
            defense: item.defense || 0,
            attackSpeed: item.attackSpeed || 0,
            critChance: item.critChance || 0,
            critDamage: item.critDamage || 0,
            dodgeChance: item.dodgeChance || 0,
            lifesteal: item.lifesteal || 0,
            hpRegen: item.hpRegen || 0,
            manaRegen: item.manaRegen || 0,
            cdr: item.cdr || 0,
            rarity: item.rarity
        };

        // Show blessing results popup with blessed stat info
        this.showBlessingResultsPopup(item.name, item.rarity, statsBefore, statsAfter, blessedStat);

        // Full UI rebuild to update equipment display immediately
        this.rebuildUI();
        document.getElementById('blessing-currency-display').textContent = this.blessingCurrency;
        document.getElementById('bless-item-selected').style.display = 'none';

        // Switch back to loot/inventory tab so user can see their updated character
        document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));
        document.querySelector('[data-tab="loot"]').classList.add('active');
        document.getElementById('loot-tab').classList.add('active');

        // Switch to inventory sub-tab
        document.querySelectorAll('.loot-sub-tab').forEach(tab => tab.classList.remove('active'));
        document.querySelectorAll('.loot-section').forEach(section => section.style.display = 'none');
        document.querySelector('[data-loot-tab="inventory"]').classList.add('active');
        document.getElementById('loot-inventory-section').style.display = 'block';
        this.showInventory();

        // Re-enable button for future blessings
        if (button) {
            button.classList.remove('blessing-animation');
            button.style.pointerEvents = '';
        }

        saveGame();
    }, 800); // Wait for animation to complete
}

showBlessingResultsPopup(itemName, itemRarity, statsBefore, statsAfter, blessedStat) {
    // Create overlay
    const overlay = document.createElement('div');
    overlay.style.position = 'fixed';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.background = 'rgba(0, 0, 0, 0.8)';
    overlay.style.zIndex = '10000';
    overlay.style.display = 'flex';
    overlay.style.alignItems = 'center';
    overlay.style.justifyContent = 'center';
    overlay.style.backdropFilter = 'blur(5px)';
    overlay.style.animation = 'fadeIn 0.3s ease';

    // Create popup
    const popup = document.createElement('div');
    popup.style.background = 'linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.98) 100%)';
    popup.style.border = '3px solid rgba(168, 85, 247, 0.8)';
    popup.style.borderRadius = '16px';
    popup.style.padding = '30px';
    popup.style.maxWidth = '500px';
    popup.style.width = '90%';
    popup.style.maxHeight = '80vh';
    popup.style.overflowY = 'auto';
    popup.style.boxShadow = '0 0 40px rgba(168, 85, 247, 0.4), 0 20px 60px rgba(0, 0, 0, 0.8)';
    popup.style.fontFamily = 'Rajdhani, sans-serif';
    popup.style.animation = 'blessing-burst 0.5s ease-out';

    // Rarity colors
    const rarityColors = {
        common: '#94a3b8',
        uncommon: '#10b981',
        rare: '#3b82f6',
        epic: '#a855f7',
        legendary: '#f59e0b',
        mythic: '#ec4899'
    };

    const itemColor = rarityColors[itemRarity] || '#e2e8f0';

    // Helper to format stat names
    const statNames = {
        attack: '‚öîÔ∏è Attack',
        hp: '‚ù§Ô∏è HP',
        mana: 'üíô Mana',
        defense: 'üõ°Ô∏è Defense',
        attackSpeed: '‚ö° Attack Speed',
        critChance: 'üí• Crit Chance',
        critDamage: 'üí¢ Crit Damage',
        dodgeChance: 'üåÄ Dodge',
        lifesteal: 'ü©∏ Lifesteal',
        hpRegen: 'üíö HP Regen',
        manaRegen: 'üíú Mana Regen',
        cdr: '‚è±Ô∏è CDR'
    };

    // Calculate the blessed stat change
    let blessedStatInfo = '';
    if (blessedStat && statsBefore[blessedStat] !== undefined) {
        const before = statsBefore[blessedStat];
        const after = statsAfter[blessedStat];
        const increase = after - before;
        const percentIncrease = before > 0 ? Math.round((increase / before) * 100) : 0;

        blessedStatInfo = `
            <div style="background: linear-gradient(135deg, rgba(168, 85, 247, 0.2) 0%, rgba(139, 92, 246, 0.2) 100%); border-radius: 12px; padding: 20px; border: 2px solid #a855f7; margin-bottom: 20px; text-align: center;">
                <div style="font-size: 16px; font-weight: 700; color: #e9d5ff; margin-bottom: 12px; font-family: 'Orbitron', sans-serif;">‚ú® BLESSED STAT ‚ú®</div>
                <div style="font-size: 32px; font-weight: 800; color: #a855f7; margin-bottom: 8px; font-family: 'Orbitron', sans-serif;">${statNames[blessedStat]}</div>
                <div style="display: flex; justify-content: center; align-items: center; gap: 12px; font-size: 24px; font-weight: 700;">
                    <span style="color: #94a3b8;">${before}</span>
                    <span style="color: #a855f7;">‚Üí</span>
                    <span style="color: #22c55e;">${after}</span>
                </div>
                <div style="font-size: 18px; font-weight: 700; color: #22c55e; margin-top: 8px;">
                    +${increase} (+${percentIncrease}%)
                </div>
            </div>
        `;
    }

    // Build content
    let content = `
        <div style="text-align: center; margin-bottom: 25px;">
            <div style="font-size: 32px; margin-bottom: 10px;">‚ú® BLESSED! ‚ú®</div>
            <div style="font-size: 24px; font-weight: 700; color: ${itemColor}; font-family: 'Orbitron', sans-serif;">${itemName}</div>
            <div style="font-size: 16px; color: #22c55e; margin-top: 8px; font-weight: 700;">+50% ${blessedStat ? statNames[blessedStat] : 'to random stat'}!</div>
        </div>

        ${blessedStatInfo}

        <div style="background: rgba(168, 85, 247, 0.1); border-radius: 10px; padding: 20px; border: 1px solid rgba(168, 85, 247, 0.3);">
            <div style="font-size: 16px; font-weight: 700; color: #e9d5ff; margin-bottom: 15px; font-family: 'Orbitron', sans-serif;">ALL STATS</div>
    `;

    // Show all stats
    let hasStats = false;
    for (const stat in statsAfter) {
        if (stat === 'rarity') continue;

        const value = statsAfter[stat];

        if (value > 0) {
            hasStats = true;
            const isBlessedStat = stat === blessedStat;
            content += `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid rgba(168, 85, 247, 0.2); ${isBlessedStat ? 'background: rgba(168, 85, 247, 0.15); padding-left: 8px; padding-right: 8px; border-radius: 4px;' : ''}">
                    <div style="color: ${isBlessedStat ? '#a855f7' : '#e2e8f0'}; font-size: 14px; ${isBlessedStat ? 'font-weight: 700;' : ''}">${statNames[stat] || stat} ${isBlessedStat ? '‚ú®' : ''}</div>
                    <div style="color: ${isBlessedStat ? '#22c55e' : '#e2e8f0'}; font-size: 14px; font-weight: ${isBlessedStat ? '700' : '500'};">${value}</div>
                </div>
            `;
        }
    }

    if (!hasStats) {
        content += '<div style="color: #94a3b8; text-align: center; padding: 10px;">No stats</div>';
    }

    content += `
        </div>

        <button onclick="this.parentElement.parentElement.remove()"
            style="width: 100%; margin-top: 20px; padding: 14px; background: linear-gradient(135deg, #a855f7, #8b5cf6);
            color: white; border: none; border-radius: 10px; cursor: pointer;
            font-size: 16px; font-weight: 700; font-family: 'Orbitron', sans-serif;
            box-shadow: 0 4px 20px rgba(168, 85, 247, 0.4); transition: all 0.3s ease;">
            AWESOME!
        </button>
    `;

    popup.innerHTML = content;
    overlay.appendChild(popup);
    document.body.appendChild(overlay);

    // Close on overlay click
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            overlay.remove();
        }
    });
}

gameLoop() {
                // Calculate delta time for real-time combat
                const currentTime = performance.now();
                this.deltaTime = (currentTime - this.lastFrameTime) / 1000; // Convert to seconds
                this.lastFrameTime = currentTime;
                this.deltaTime = Math.min(this.deltaTime, 0.1); // Cap at 100ms to prevent huge jumps

                // Add frame skipping - run at 30 FPS instead of 60
if (!this._frameSkip) this._frameSkip = 0;
this._frameSkip = (this._frameSkip + 1) % 1000; // Keep counter small

// Periodic cleanup every 10 seconds (600 frames at 60fps)
if (this._frameSkip % 600 === 0) {
    this.floatingTextPool = this.floatingTextPool.slice(0, 10);
    // Clean up old visual effects - more aggressive to prevent 8hr+ memory leak
if (this.visualEffects && this.visualEffects.length > 10) {
    this.visualEffects = this.visualEffects.filter(e => e.life > 0).slice(-10);
}

    // Clean up dead enemies from memory
    this.enemies = this.enemies.filter(e => e.isAlive);
    // Clean up any orphaned fountain overlays
    const fountainOverlay = document.getElementById('fountain-overlay');
    if (fountainOverlay && fountainOverlay.style.display === 'none') {
        fountainOverlay.remove();
    }
}

                // Only draw every other frame (30 FPS rendering)
                if (this._frameSkip % 2 === 0) {
                    // Clear canvas (transparent so background shows through)
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                    // Draw adjacent rooms (darkened, in background)
                if (this.adjacentRooms) {
                    this.adjacentRooms.forEach(adjRoom => {
                        const adjOffsetX = this.offsetX + adjRoom.offsetX * ISO.tileWidth/2 - adjRoom.offsetY * ISO.tileWidth/2;
                        const adjOffsetY = this.offsetY + adjRoom.offsetX * ISO.tileHeight/2 + adjRoom.offsetY * ISO.tileHeight/2;

                        // Save context and apply transparency
                        this.ctx.save();
                        this.ctx.globalAlpha = adjRoom.alpha;
                        adjRoom.room.draw(this.ctx, adjOffsetX, adjOffsetY, true);
                        this.ctx.restore();
                    });
                }

                // Draw hallways (on top of adjacent rooms but below main room)
                if (this.hallways) {
                    this.hallways.forEach(hallway => {
                        const hallwayOffsetX = this.offsetX + hallway.offsetX * ISO.tileWidth/2 - hallway.offsetY * ISO.tileWidth/2;
                        const hallwayOffsetY = this.offsetY + hallway.offsetX * ISO.tileHeight/2 + hallway.offsetY * ISO.tileHeight/2;
                        hallway.room.draw(this.ctx, hallwayOffsetX, hallwayOffsetY, false);
                    });
                }

                // Draw main room (on top)
                if (this.room) {
                    this.room.draw(this.ctx, this.offsetX, this.offsetY);
                }

                // Update and draw sprites - ALWAYS update positions before drawing
                const allUnits = [...this.party, ...this.enemies]
                    .filter(u => u.sprite && u.isAlive)
                    .sort((a, b) => {
                        const aY = a.sprite.gridX + a.sprite.gridY;
                        const bY = b.sprite.gridX + b.sprite.gridY;
                        return aY - bY;
                    });

                allUnits.forEach(unit => {
                    if (unit.sprite) {
                        unit.sprite.update(); // This MUST run before draw
                        unit.sprite.draw(this.ctx, this.offsetX, this.offsetY);
                    }
                });

                // Update and draw visual effects
                this.updateVisualEffects();
                this.drawVisualEffects(this.ctx);
				this.drawRuneTrialPillar(this.ctx);
                } // Close the if statement for frame skipping

                // Battle tick - continuous real-time combat (runs every frame regardless)
// Also run during Rune Trial pillar charging phase
// Only run during Rune Trial pillar charging phase
const shouldRunBattleTick = !this.paused && (this.inBattle || (this.currentDungeon === 'runetrial' && this.runeTrialPillarCharging));

if (shouldRunBattleTick) {
    if (!this.battleTimer) this.battleTimer = 0;
    this.battleTimer++;
    // Battle ticks every frame now for smooth real-time combat
    for (let i = 0; i < this.speed; i++) {
        this.battleTick();
    }

    // Update endless dungeon if active (throttled to once per second for performance)
    if (this.currentDungeon === 'endlessblessings' && !this.paused) {
        if (!this._endlessUpdateCounter) this._endlessUpdateCounter = 0;
        this._endlessUpdateCounter++;
        if (this._endlessUpdateCounter >= 60) { // Run once per second (60 frames)
            this.updateEndlessDungeon();
            this._endlessUpdateCounter = 0;
        }
    }

    // Update character stats display for all dungeons during battle (throttled to every 30 frames for performance - ~0.5s at 60fps)
    if (this.inBattle && this.characterStats && !this.paused) {
        if (!this._statsUpdateCounter) this._statsUpdateCounter = 0;
        this._statsUpdateCounter++;
        if (this._statsUpdateCounter >= 30) {
            this.updateCharacterStatsDisplay();
            this._statsUpdateCounter = 0;
        }
    }
}

                if (!this.destroyed) {
                    this.gameLoopFrameId = this.animationManager.request(() => this.gameLoop());
                }
            }

            cleanup() {
                if (this.destroyed) return;
                console.log('üßπ Cleaning up game resources...');

                this.destroyed = true;
                this.paused = true;

                // Stop animations
                if (this.gameLoopFrameId) {
                    this.animationManager.cancel(this.gameLoopFrameId);
                    this.gameLoopFrameId = null;
                }

                if (this.animationManager) {
                    this.animationManager.cancelAll();
                }

                // Clear timers
                if (this.timerManager) {
                    this.timerManager.clearAll();
                }

                // Remove event listeners
                if (this.eventManager) {
                    this.eventManager.removeAll();
                }

                // Clear arrays to free memory
                if (this.visualEffects) this.visualEffects.length = 0;
                if (this.loot) this.loot.length = 0;

                console.log('‚úÖ Game cleanup complete');
            }

            getRarityColor(rarity) {
    const colors = {
        common: '#94a3b8',
        uncommon: '#10b981',
        rare: '#3b82f6',
        epic: '#a855f7',
        legendary: '#f59e0b',
        mythic: '#c910a7'
    };
    return colors[rarity] || '#94a3b8';
}

            getStatRollPercent(item, statName) {
    if (!item || !item[statName]) return '';

    // Check if this stat was blessed
    const isBlessedStat = item.blessed && item.blessedStat === statName;

    // Mythic items show 200% for mythic stat(s), 100% for others
if (item.rarity === 'mythic') {
    // Check if this stat is mythic (handle both single and multiple)
    const isMythicStat = item.mythicStat === statName || (item.mythicStats && item.mythicStats.includes(statName));

    if (isMythicStat && isBlessedStat) {
        // Blessed mythic stat: 200% * 1.5 = 300% (showing as 250% because it's 2.5x base)
        return '<span style="color: #c910a7;">(250%)</span>';
    } else if (isMythicStat) {
        return '<span style="color: #c910a7;">(200%)</span>';
    } else if (isBlessedStat) {
        // Blessed non-mythic stat on mythic item: 100% * 1.5 = 150%
        return '<span style="color: #a855f7;">(150%)</span>';
    } else {
        return '<span style="color: #f59e0b;">(100%)</span>';
    }
}

    // Legendary items always show 100% (or 150% if blessed)
    if (item.rarity === 'legendary') {
        if (isBlessedStat) {
            return '<span style="color: #a855f7;">(150%)</span>';
        }
        return '<span style="color: #f59e0b;">(100%)</span>';
    }

                // For other rarities, check if blessed
                if (isBlessedStat) {
                    return '<span style="color: #a855f7;">(150%)</span>';
                }

                // Stat ranges from Item class (with weapon-specific overrides)
                const statRanges = {
                    attack: { min: 0.5, max: 3 },
                    hp: { min: 4, max: 12.5 },
                    mana: { min: 2.5, max: 7.5 },
                    defense: { min: 1, max: 4 },
                    attackSpeed: { min: 0.025, max: 0.09 },
                    critChance: { min: 0.5, max: 3 },
                    critDamage: { min: 2, max: 8 },
                    dodgeChance: { min: 1, max: 3 },
                    lifesteal: { min: 0.5, max: 2 },
                    cdr: { min: 0.5, max: 3 },
                    hpRegen: { min: 2.5, max: 15 },
                    manaRegen: { min: 5, max: 25 }
                };

                // Apply weapon-specific stat range overrides
                if (item.type === 'dagger' && statName === 'attack') {
                    statRanges.attack = { min: 1, max: 9 };
                }
                if (item.type === 'greatsword' && statName === 'attack') {
                    statRanges.attack = { min: 1, max: 7 };
                }
                if (item.type === 'greatsword' && statName === 'hp') {
                    statRanges.hp = { min: 8, max: 40 };
                }
                if (item.type === 'bow' && statName === 'attack') {
                    statRanges.attack = { min: 1, max: 8.5 };
                }
                if (item.type === 'wand' && statName === 'attack') {
                    statRanges.attack = { min: 1, max: 8 };
                }
                if (item.type === 'staff' && statName === 'attack') {
                    statRanges.attack = { min: 1, max: 7 };
                }
                if (item.type === 'staff' && statName === 'mana') {
                    statRanges.mana = { min: 5, max: 25 };
                }
                if (item.type === 'warhammer' && statName === 'attack') {
                    statRanges.attack = { min: 1, max: 7.5 };
                }
                if (item.type === 'warhammer' && statName === 'hp') {
                    statRanges.hp = { min: 7, max: 35 };
                }
                if (item.type === 'warhammer' && statName === 'mana') {
                    statRanges.mana = { min: 3.5, max: 12.5 };
                }
                if ((item.type === 'staff' || item.type === 'wand' || item.type === 'amulet') && statName === 'manaRegen') {
                    statRanges.manaRegen = { min: 4, max: 20 };
                }

                const range = statRanges[statName];
                if (!range) return '';

                // Calculate the scaled range for this item's level
                // MUST match the scaling in Item constructor!
                const levelScaling = Math.pow(1.018, item.level);
                const scaledMin = range.min * levelScaling;
                const scaledMax = range.max * levelScaling;

                // Calculate roll percentage
                const rollPercent = Math.round(((item[statName] - scaledMin) / (scaledMax - scaledMin)) * 100);

                // Color based on roll quality
                let color = '#64748b'; // Gray for low rolls
                if (rollPercent >= 90) color = '#f59e0b'; // Gold for 90%+
                else if (rollPercent >= 75) color = '#a855f7'; // Purple for 75%+
                else if (rollPercent >= 50) color = '#3b82f6'; // Blue for 50%+

                return `<span style="color: ${color};">(${Math.max(0, Math.min(100, rollPercent))}%)</span>`;
            }
        }

        // ========================================
        // CHARACTER SELECT SYSTEM - 4 CHARACTER PARTY
        // ========================================
        let selectedParty = [null, null, null, null]; // Array of 4 character classes

        // Character icon mapping
        const charIcons = {
            'tank': '<img src="tank.png" alt="Tank">',
            'healer': '<img src="healer.png" alt="Healer">',
            'mage': '<img src="mage.png" alt="Mage">',
            'rogue': '<img src="rogue.png" alt="Rogue">',
            'archer': '<img src="archer.png" alt="Archer">',
            'paladin': '<img src="paladin.png" alt="Paladin">'
        };

        const charNames = {
            'tank': 'Tank',
            'healer': 'Healer',
            'mage': 'Mage',
            'rogue': 'Rogue',
            'archer': 'Archer',
            'paladin': 'Paladin'
        };

        // Check if there's a saved party selection
        const savedParty = localStorage.getItem('selectedParty');
        if (savedParty) {
            try {
                selectedParty = JSON.parse(savedParty);
                // Validate that we have 4 characters
                if (selectedParty.length === 4 && selectedParty.every(c => c !== null)) {
                    // Hide character select and show game
                    document.getElementById('character-select-overlay').classList.add('hidden');
                    // Initialize game immediately
                    window.game = new Game();
                    // Load saved game data after initialization
                    setTimeout(() => {
                        if (window.loadGame) {
                            window.loadGame();
                        }
                    }, 200);
                } else {
                    // Invalid save, start fresh
                    selectedParty = [null, null, null, null];
                    setupCharacterSelect();
                }
            } catch (e) {
                selectedParty = [null, null, null, null];
                setupCharacterSelect();
            }
        } else {
            // Show character select screen
            setupCharacterSelect();
        }

        function updatePartySlots() {
            const slots = document.querySelectorAll('.party-slot');
            slots.forEach((slot, index) => {
                const charClass = selectedParty[index];
                if (charClass) {
                    slot.classList.add('filled');
                    slot.querySelector('.slot-icon').innerHTML = charIcons[charClass];
                    slot.querySelector('.slot-name').textContent = charNames[charClass];
                } else {
                    slot.classList.remove('filled');
                    slot.querySelector('.slot-icon').textContent = '?';
                    slot.querySelector('.slot-name').textContent = 'Empty';
                }
            });

            // Update character cards to show which are used
            const cards = document.querySelectorAll('.char-select-card');
            cards.forEach(card => {
                const charClass = card.dataset.charClass;
                if (selectedParty.includes(charClass)) {
                    card.classList.add('used');
                } else {
                    card.classList.remove('used');
                }
            });

            // Update start button
            const startBtn = document.getElementById('start-adventure-btn');
            const filledCount = selectedParty.filter(c => c !== null).length;
            if (filledCount === 4) {
                startBtn.disabled = false;
                startBtn.textContent = `START ADVENTURE`;
            } else {
                startBtn.disabled = true;
                startBtn.textContent = `SELECT ${4 - filledCount} MORE HERO${4 - filledCount === 1 ? '' : 'ES'}`;
            }
        }

        function setupCharacterSelect() {
            const cards = document.querySelectorAll('.char-select-card');
            const startBtn = document.getElementById('start-adventure-btn');
            const slots = document.querySelectorAll('.party-slot');

            // Make slots clickable to change selection
            slots.forEach((slot, index) => {
                slot.addEventListener('click', function() {
                    // If slot is filled, clear it
                    if (selectedParty[index]) {
                        selectedParty[index] = null;
                        updatePartySlots();
                    }
                });
            });

            cards.forEach(card => {
                card.addEventListener('click', function() {
                    const charClass = this.dataset.charClass;

                    // Check if this character is already in party
                    if (selectedParty.includes(charClass)) {
                        return; // Can't select same character twice
                    }

                    // Find first empty slot
                    const emptySlot = selectedParty.findIndex(c => c === null);
                    if (emptySlot !== -1) {
                        selectedParty[emptySlot] = charClass;
                        updatePartySlots();
                    }
                });
            });

            startBtn.addEventListener('click', function() {
                // Check if all 4 slots are filled
                if (selectedParty.every(c => c !== null)) {
                    // Save selection
                    localStorage.setItem('selectedParty', JSON.stringify(selectedParty));

                    // Hide character select
                    document.getElementById('character-select-overlay').classList.add('hidden');

                    // Initialize game
                    window.game = new Game();
                }
            });

            // Initial update
            updatePartySlots();
        }

        // Start the game immediately if character was already selected
        if (savedParty && selectedParty.every(c => c !== null)) {
            // Game already initialized above
        }

        // Reference game for backwards compatibility
        const game = window.game || null;

// Save notification element
        const saveNotification = document.createElement('div');
        saveNotification.id = 'save-notification';
        saveNotification.style.cssText = 'position: fixed; top: 10px; left: 10px; color: white; font-size: 10px; opacity: 0; transition: opacity 0.3s; z-index: 9999; pointer-events: none;';
        saveNotification.textContent = 'Game saved';
        document.body.appendChild(saveNotification);

        // Save system - complete version
        window.saveGame = () => {
            // Don't save if game hasn't been initialized yet
            if (!window.game) {
                return;
            }

            try {
                const saveData = {
                    version: '2.0.0', // Updated version - old saves won't load
                    timestamp: Date.now(),
                    gold: window.game.gold,
                    dungeonFloor: window.game.dungeonFloor,
                    currentDungeon: window.game.currentDungeon,
                    successfulRuns: window.game.successfulRuns,
                    party: window.game.party.map(m => ({
                        name: m.name,
                        className: m.className,
                        level: m.level,
                        xp: m.xp,
                        maxXp: m.maxXp,
                        hp: m.hp,
                        maxHp: m.maxHp,
                        mana: m.mana,
                        maxMana: m.maxMana,
                        attack: m.attack,
                        defense: m.defense,
                        attackSpeed: m.attackSpeed,
                        critChance: m.critChance,
                        critDamage: m.critDamage,
                        dodgeChance: m.dodgeChance,
                        lifesteal: m.lifesteal,
                        hpRegen: m.hpRegen,
                        manaRegen: m.manaRegen,
                        cdr: m.cdr,
                        isAlive: m.isAlive,
                        skillPoints: m.skillPoints,
                        skillTree: m.skillTree,
                        equipment: m.equipment,
                        runePercentBonuses: m.runePercentBonuses
                    })),
                    loot: window.game.loot,
                    inventory: window.game.inventory,
                    playerChests: window.game.playerChests,
                    vaultKeys: window.game.vaultKeys,
                    runeTrialKeys: window.game.runeTrialKeys,
                    keystones: window.game.keystones.filter(ks => {
                        // Only save keystones that are NOT equipped
                        for (const type of ['tank', 'healer', 'mage', 'rogue', 'archer', 'paladin']) {
                            if (window.game.equippedKeystones[type] && window.game.equippedKeystones[type] === ks) {
                                return false; // This keystone is equipped, don't include it
                            }
                        }
                        return true; // This keystone is not equipped, include it
                    }),
                    equippedKeystones: window.game.equippedKeystones,
                    equippedKeystoneIds: Object.keys(window.game.equippedKeystones).reduce((acc, type) => {
                        if (window.game.equippedKeystones[type]) {
                            acc[type] = window.game.keystones.indexOf(window.game.equippedKeystones[type]);
                        }
                        return acc;
                    }, {}),
                    runeSlots: window.game.runeSlots,
                    equippedRunes: window.game.equippedRunes,
                    runes: window.game.runes,
                    pets: window.game.pets.filter(pet => {
                        // Only save pets that are NOT equipped
                        for (const charType of ['tank', 'healer', 'mage', 'rogue', 'archer', 'paladin']) {
                            if (window.game.equippedPets[charType] && window.game.equippedPets[charType] === pet) {
                                return false; // This pet is equipped, don't include it
                            }
                        }
                        return true; // This pet is not equipped, include it
                    }),
                    equippedPets: window.game.equippedPets,
                    dungeonProgress: window.game.dungeonProgress,
                    globalStats: window.game.globalStats,
                    lootFilter: window.game.lootFilter,
                    nextChestId: window.game.nextChestId,
                    nextVaultKeyId: window.game.nextVaultKeyId,
                    nextRuneTrialKeyId: window.game.nextRuneTrialKeyId
                };

                const saveString = JSON.stringify(saveData);
                localStorage.setItem('rpg_dungeon_save', saveString);

                // Show save notification
                saveNotification.style.opacity = '1';
                setTimeout(() => {
                    saveNotification.style.opacity = '0';
                }, 2000);

                console.log('Game saved');
                return true;
            } catch (e) {
                console.error('Save error:', e);
                return false;
            }
        };

        window.loadGame = () => {
            // Don't load if game hasn't been initialized yet
            if (!window.game) {
                console.log('Game not initialized yet, skipping load');
                return false;
            }

            try {
                const saveString = localStorage.getItem('rpg_dungeon_save');
                if (!saveString) {
                    console.log('No save found');
                    return false;
                }

                const data = JSON.parse(saveString);

                // Version check - reject old saves
                const CURRENT_VERSION = '2.0.0';
                if (!data.version || data.version !== CURRENT_VERSION) {
                    console.log(`Old save version detected (${data.version || 'unknown'}). Clearing incompatible save.`);
                    localStorage.removeItem('rpg_dungeon_save');
                    localStorage.removeItem('skillTreeData');
                    localStorage.removeItem('gameSkillTreeData');
                    localStorage.removeItem('runeSlotLockInfo');
                    localStorage.removeItem('currentCharacterIndex');
                    alert('Your save file is from an old version and is not compatible. Starting fresh!');
                    return false;
                }

                console.log('Loading save from:', new Date(data.timestamp));

                // Restore all basic properties
                window.game.gold = data.gold || 0;
                window.game.dungeonFloor = data.dungeonFloor || 1;
                window.game.currentDungeon = data.currentDungeon || null;
                window.game.successfulRuns = data.successfulRuns || 0;

                // Restore ID counters
                window.game.nextChestId = data.nextChestId || 1;
                window.game.nextVaultKeyId = data.nextVaultKeyId || 1;
                window.game.nextRuneTrialKeyId = data.nextRuneTrialKeyId || 1;

                // Restore party with all properties
                if (data.party && Array.isArray(data.party)) {
                    data.party.forEach((saved, i) => {
                        const member = window.game.party[i];
                        if (!member || !saved) return;

                        // Copy all basic stats
                        member.level = saved.level;
                        member.xp = saved.xp;
                        member.maxXp = saved.maxXp;
                        member.hp = saved.hp;
                        member.maxHp = saved.maxHp;
                        member.mana = saved.mana;
                        member.maxMana = saved.maxMana;
                        member.attack = saved.attack;
                        member.defense = saved.defense;
                        member.attackSpeed = saved.attackSpeed;
                        member.critChance = saved.critChance;
                        member.critDamage = saved.critDamage;
                        member.dodgeChance = saved.dodgeChance;
                        member.lifesteal = saved.lifesteal;
                        member.hpRegen = saved.hpRegen;
                        member.manaRegen = saved.manaRegen;
                        member.cdr = saved.cdr;
                        member.isAlive = saved.isAlive;
                        member.skillPoints = saved.skillPoints;

                        // Restore skill tree
                        if (saved.skillTree) {
                            member.skillTree = saved.skillTree;
                        }

                        // Restore equipment - recreate Item instances
                        if (saved.equipment) {
                            member.equipment = {};
                            Object.keys(saved.equipment).forEach(slot => {
                                const itemData = saved.equipment[slot];
                                if (itemData && itemData.name) {
                                    const item = {};
item.type = itemData.type;
item.weaponType = itemData.weaponType;
item.rarity = itemData.rarity;
item.level = itemData.level;
item.name = itemData.name;
// Add getStatsDisplay method
item.getStatsDisplay = function() {
    let display = [];
    if (this.attack) display.push(`+${this.attack} Attack`);
    if (this.attackSpeed) display.push(`+${this.attackSpeed} Attack Speed`);
    if (this.hp) display.push(`+${this.hp} HP`);
    if (this.mana) display.push(`+${this.mana} Mana`);
    if (this.defense) display.push(`+${this.defense} Defense`);
    if (this.critChance) display.push(`+${this.critChance}% Crit Chance`);
    if (this.critDamage) display.push(`+${this.critDamage}% Crit Damage`);
    if (this.dodgeChance) display.push(`+${this.dodgeChance}% Dodge`);
    if (this.lifesteal) display.push(`+${this.lifesteal}% Lifesteal`);
    if (this.hpRegen) display.push(`+${this.hpRegen} HP Regen`);
    if (this.manaRegen) display.push(`+${this.manaRegen} Mana Regen`);
    if (this.cdr) display.push(`+${this.cdr}% CDR`);
    return display.join(', ');
};
                                    // Only copy the exact properties that should exist
                                    item.name = itemData.name;
                                    item.type = itemData.type;
                                    item.weaponType = itemData.weaponType;
                                    item.rarity = itemData.rarity;
                                    item.level = itemData.level;
                                    // Only copy stats that aren't zero/null
                                    if (itemData.attack) item.attack = itemData.attack;
                                    if (itemData.defense) item.defense = itemData.defense;
                                    if (itemData.hp) item.hp = itemData.hp;
                                    if (itemData.mana) item.mana = itemData.mana;
                                    if (itemData.attackSpeed) item.attackSpeed = itemData.attackSpeed;
                                    if (itemData.critChance) item.critChance = itemData.critChance;
                                    if (itemData.critDamage) item.critDamage = itemData.critDamage;
                                    if (itemData.dodgeChance) item.dodgeChance = itemData.dodgeChance;
                                    if (itemData.lifesteal) item.lifesteal = itemData.lifesteal;
                                    if (itemData.hpRegen) item.hpRegen = itemData.hpRegen;
                                    if (itemData.manaRegen) item.manaRegen = itemData.manaRegen;
                                    if (itemData.cdr) item.cdr = itemData.cdr;
                                    if (itemData.mythicStat) item.mythicStat = itemData.mythicStat;
                                    if (itemData.mythicStats) item.mythicStats = itemData.mythicStats;
                                    if (itemData.blessed) item.blessed = itemData.blessed;
                                    if (itemData.blessedStat) item.blessedStat = itemData.blessedStat;
                                    member.equipment[slot] = item;
                                } else {
                                    member.equipment[slot] = null;
                                }
                            });
                        }

                        // Restore rune bonuses
                        if (saved.runePercentBonuses) {
                            member.runePercentBonuses = saved.runePercentBonuses;
                        }
                    });

                    // Apply skill tree stats to recalculate perEpic bonuses based on loaded equipment
                    window.game.party.forEach(member => {
                        if (member) {
                            window.game.applySkillTreeStats(member);
                        }
                    });
                }

                // Restore inventory and loot - recreate Item instances
                if (data.loot) {
                    window.game.loot = data.loot.map(itemData => {
                        if (!itemData) return null;
                        const item = {};
item.type = itemData.type;
item.weaponType = itemData.weaponType;
item.rarity = itemData.rarity;
item.level = itemData.level;
item.name = itemData.name;
// Add getStatsDisplay method
item.getStatsDisplay = function() {
    let display = [];
    if (this.attack) display.push(`+${this.attack} Attack`);
    if (this.attackSpeed) display.push(`+${this.attackSpeed} Attack Speed`);
    if (this.hp) display.push(`+${this.hp} HP`);
    if (this.mana) display.push(`+${this.mana} Mana`);
    if (this.defense) display.push(`+${this.defense} Defense`);
    if (this.critChance) display.push(`+${this.critChance}% Crit Chance`);
    if (this.critDamage) display.push(`+${this.critDamage}% Crit Damage`);
    if (this.dodgeChance) display.push(`+${this.dodgeChance}% Dodge`);
    if (this.lifesteal) display.push(`+${this.lifesteal}% Lifesteal`);
    if (this.hpRegen) display.push(`+${this.hpRegen} HP Regen`);
    if (this.manaRegen) display.push(`+${this.manaRegen} Mana Regen`);
    if (this.cdr) display.push(`+${this.cdr}% CDR`);
    return display.join(', ');
};
                        // Only copy exact properties
                        item.name = itemData.name;
                        item.type = itemData.type;
                        item.weaponType = itemData.weaponType;
                        item.rarity = itemData.rarity;
                        item.level = itemData.level;
                        if (itemData.attack) item.attack = itemData.attack;
                        if (itemData.defense) item.defense = itemData.defense;
                        if (itemData.hp) item.hp = itemData.hp;
                        if (itemData.mana) item.mana = itemData.mana;
                        if (itemData.attackSpeed) item.attackSpeed = itemData.attackSpeed;
                        if (itemData.critChance) item.critChance = itemData.critChance;
                        if (itemData.critDamage) item.critDamage = itemData.critDamage;
                        if (itemData.dodgeChance) item.dodgeChance = itemData.dodgeChance;
                        if (itemData.lifesteal) item.lifesteal = itemData.lifesteal;
                        if (itemData.hpRegen) item.hpRegen = itemData.hpRegen;
                        if (itemData.manaRegen) item.manaRegen = itemData.manaRegen;
                        if (itemData.cdr) item.cdr = itemData.cdr;
                        if (itemData.mythicStat) item.mythicStat = itemData.mythicStat;
                        if (itemData.mythicStats) item.mythicStats = itemData.mythicStats;
                        if (itemData.blessed) item.blessed = itemData.blessed;
                        if (itemData.blessedStat) item.blessedStat = itemData.blessedStat;
                        return item;
                    }).filter(x => x);
                }

                if (data.inventory) {
                    window.game.inventory = data.inventory.map(itemData => {
                        if (!itemData) return null;
                        const item = {};
item.type = itemData.type;
item.weaponType = itemData.weaponType;
item.rarity = itemData.rarity;
item.level = itemData.level;
item.name = itemData.name;
// Add getStatsDisplay method
item.getStatsDisplay = function() {
    let display = [];
    if (this.attack) display.push(`+${this.attack} Attack`);
    if (this.attackSpeed) display.push(`+${this.attackSpeed} Attack Speed`);
    if (this.hp) display.push(`+${this.hp} HP`);
    if (this.mana) display.push(`+${this.mana} Mana`);
    if (this.defense) display.push(`+${this.defense} Defense`);
    if (this.critChance) display.push(`+${this.critChance}% Crit Chance`);
    if (this.critDamage) display.push(`+${this.critDamage}% Crit Damage`);
    if (this.dodgeChance) display.push(`+${this.dodgeChance}% Dodge`);
    if (this.lifesteal) display.push(`+${this.lifesteal}% Lifesteal`);
    if (this.hpRegen) display.push(`+${this.hpRegen} HP Regen`);
    if (this.manaRegen) display.push(`+${this.manaRegen} Mana Regen`);
    if (this.cdr) display.push(`+${this.cdr}% CDR`);
    return display.join(', ');
};
                        Object.assign(item, itemData);
                        return item;
                    }).filter(x => x);
                }

                // Restore keystones (unequipped) - recreate Keystone instances
                if (data.keystones) {
                    window.game.keystones = data.keystones.map((ksData, index) => {
                        if (!ksData) return null;
                        // Skip if this was an equipped keystone
                        if (data.equippedKeystoneIds) {
                            for (let type in data.equippedKeystoneIds) {
                                if (data.equippedKeystoneIds[type] === index) {
                                    return null; // This keystone is equipped, don't add to unequipped list
                                }
                            }
                        }
                        const keystone = window.game.rollKeystoneFromVault ? window.game.rollKeystoneFromVault(ksData.level) : new Keystone(ksData.level);
                        Object.assign(keystone, ksData);
                        return keystone;
                    }).filter(x => x);
                }

                // Restore equipped keystones - recreate Keystone instances
                window.game.equippedKeystones = {};
                if (data.equippedKeystones) {
                    Object.keys(data.equippedKeystones).forEach(type => {
                        const ksData = data.equippedKeystones[type];
                        if (ksData && ksData.level) {
                            const keystone = window.game.rollKeystoneFromVault ? window.game.rollKeystoneFromVault(ksData.level) : new Keystone(ksData.level);
                            Object.assign(keystone, ksData);
                            window.game.equippedKeystones[type] = keystone;
                        }
                    });
                }

                // Remove duplicate keystones - always keep equipped ones, remove inventory duplicates
                const equippedKeys = new Set();

                // First, catalog all equipped keystones
                Object.values(window.game.equippedKeystones).forEach(equipped => {
                    if (equipped) {
                        const key = `${equipped.name}-${equipped.level}-${equipped.rarity}-${JSON.stringify(equipped.stats)}-${JSON.stringify(equipped.ability)}`;
                        equippedKeys.add(key);
                    }
                });

                // Remove any unequipped keystones that match equipped ones
                game.keystones = game.keystones.filter(ks => {
                    const ksKey = `${ks.name}-${ks.level}-${ks.rarity}-${JSON.stringify(ks.stats)}-${JSON.stringify(ks.ability)}`;
                    if (equippedKeys.has(ksKey)) {
                        console.log('Removed duplicate unequipped keystone:', ks.name);
                        return false; // Remove from inventory
                    }
                    return true; // Keep in inventory
                });

                // Also remove any duplicates within the unequipped list itself
                const seenUnequipped = new Set();
                game.keystones = game.keystones.filter(ks => {
                    const key = `${ks.name}-${ks.level}-${ks.rarity}-${JSON.stringify(ks.stats)}-${JSON.stringify(ks.ability)}`;
                    if (seenUnequipped.has(key)) {
                        console.log('Removed duplicate in inventory:', ks.name);
                        return false;
                    }
                    seenUnequipped.add(key);
                    return true;
                });

                // Remove duplicate runes (safety check)
                if (data.runes) {
                    game.runes = data.runes.map(runeData => {
                        if (!runeData) return null;
                        const rune = game.rollRuneFromTrial ? game.rollRuneFromTrial(runeData.tier) : new Rune(runeData.tier);
                        Object.assign(rune, runeData);
                        return rune;
                    }).filter(x => x);
                }
                // Remove duplicate runes - always keep equipped ones, remove inventory duplicates
                const equippedRuneKeys = new Set();

                // First, catalog all equipped runes
                Object.values(game.equippedRunes).forEach(charRunes => {
                    if (charRunes && Array.isArray(charRunes)) {
                        charRunes.forEach(rune => {
                            if (rune) {
                                const key = `${rune.name}-${rune.tier}-${rune.emoji}-${JSON.stringify(rune.statType)}-${JSON.stringify(rune.percentBonus)}`;
                                equippedRuneKeys.add(key);
                            }
                        });
                    }
                });

                // Remove any unequipped runes that match equipped ones
                game.runes = game.runes.filter(rune => {
                    const runeKey = `${rune.name}-${rune.tier}-${rune.emoji}-${JSON.stringify(rune.statType)}-${JSON.stringify(rune.percentBonus)}`;
                    if (equippedRuneKeys.has(runeKey)) {
                        console.log('Removed duplicate unequipped rune:', rune.name);
                        return false; // Remove from inventory
                    }
                    return true; // Keep in inventory
                });

                // Also remove any duplicates within the unequipped list itself
                const seenUnequippedRunes = new Set();
                game.runes = game.runes.filter(rune => {
                    const key = `${rune.name}-${rune.tier}-${rune.emoji}-${JSON.stringify(rune.statType)}-${JSON.stringify(rune.percentBonus)}`;
                    if (seenUnequippedRunes.has(key)) {
                        console.log('Removed duplicate rune in inventory:', rune.name);
                        return false;
                    }
                    seenUnequippedRunes.add(key);
                    return true;
                });
                // Restore equipped runes - recreate Rune instances
                game.equippedRunes = { tank: [null,null,null,null,null], healer: [null,null,null,null,null], mage: [null,null,null,null,null], rogue: [null,null,null,null,null] };
                if (data.equippedRunes) {
                    Object.keys(data.equippedRunes).forEach(charType => {
                        if (data.equippedRunes[charType]) {
                            game.equippedRunes[charType] = data.equippedRunes[charType].map(runeData => {
                                if (!runeData || !runeData.tier) return null;
                                const rune = game.rollRuneFromTrial ? game.rollRuneFromTrial(runeData.tier) : new Rune(runeData.tier);
                                Object.assign(rune, runeData);
                                return rune;
                            });
                        }
                    });
                }

                // Restore rune slots
                if (data.runeSlots) {
                    game.runeSlots = data.runeSlots;
                }

                // Restore pets (unequipped) - recreate Pet instances
                // Restore pets (unequipped) - recreate Pet instances
                if (data.pets) {
                    game.pets = data.pets.map((petData, index) => {
                        if (!petData) return null;
                        const pet = new Pet(petData.rarity, petData.level, petData.dungeonType);
                        Object.assign(pet, petData);
                        return pet;
                    }).filter(x => x);
                }

                // Restore equipped pets - recreate Pet instances
                game.equippedPets = {};
                if (data.equippedPets) {
                    // FIX: Use member.className.toLowerCase() instead of hardcoded party order
                    Object.keys(data.equippedPets).forEach(charType => {
                        const petData = data.equippedPets[charType];
                        if (petData && petData.rarity) {
                            const pet = new Pet(petData.rarity, petData.level, petData.dungeonType);
                            Object.assign(pet, petData);
                            game.equippedPets[charType] = pet;

                            // CRITICAL FIX: Apply pet bonuses after loading
                            const member = game.party.find(m => m.className.toLowerCase() === charType);
                            if (member) {
                                game.applyPetBonus(pet, member);
                            }
                        }
                    });
                }

                // Remove duplicate pets - always keep equipped ones, remove inventory duplicates
                const equippedPetKeys = new Set();

                // First, catalog all equipped pets (using id for uniqueness)
                Object.values(game.equippedPets).forEach(equipped => {
                    if (equipped) {
                        equippedPetKeys.add(equipped.id);
                    }
                });

                // Remove any unequipped pets that match equipped ones by ID
                game.pets = game.pets.filter(pet => {
                    if (equippedPetKeys.has(pet.id)) {
                        console.log('Removed duplicate unequipped pet:', pet.name);
                        return false; // Remove from inventory
                    }
                    return true; // Keep in inventory
                });

                // Also remove any duplicates within the unequipped list itself using ID
                const seenUnequippedPetIds = new Set();
                game.pets = game.pets.filter(pet => {
                    if (seenUnequippedPetIds.has(pet.id)) {
                        console.log('Removed duplicate pet in inventory:', pet.name);
                        return false;
                    }
                    seenUnequippedPetIds.add(pet.id);
                    return true;
                });

                // Restore other collections
                if (data.playerChests) game.playerChests = data.playerChests;
                if (data.vaultKeys) game.vaultKeys = data.vaultKeys;
                if (data.runeTrialKeys) game.runeTrialKeys = data.runeTrialKeys;
                if (data.dungeonProgress) game.dungeonProgress = data.dungeonProgress;
                if (data.globalStats) game.globalStats = data.globalStats;
                if (data.lootFilter) game.lootFilter = data.lootFilter;

                // Update displays
                document.getElementById('current-floor-display').textContent = game.dungeonFloor;
                game.rebuildUI();
                game.updateUI();

                console.log('Game loaded');
                return true;
            } catch (e) {
                console.error('Load error:', e);
                return false;
            }
        };

        // Auto-save every 30 seconds
        if (window.game && window.game.timerManager) {
            window.game.autoSaveInterval = window.game.timerManager.setInterval(() => saveGame(), 30000);
        } else {
            setInterval(saveGame, 30000);
        }

        // ========================================
        // FIREBASE LEADERBOARD SYSTEM
        // ========================================

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCkFY_gTrV3238YoYrdslWUdNuP9iyeyO9NYw",
            authDomain: "everfall-59970.fir33ebaseapp.com",
            projectId: "everfall-59970",
            storageBucket: "everfall-59970.fireb33asestorage.app",
            messagingSenderId: "71136255333851",
            appId: "1:71136252253851:web:2e83315fd99263e4ff414d5e"
        };

        // Initialize Firebase
        let db = null;
        try {
            firebase.initializeApp(firebaseConfig);
            db = firebase.firestore();
            console.log('‚úÖ Firebase leaderboard connected');
        } catch (error) {
            console.error('‚ùå Firebase error:', error);
        }

        // GAME VERSION - Change this to reset leaderboards
        const GAME_VERSION = 'v3';
        const LEADERBOARD_COLLECTION = `leaderboard_${GAME_VERSION}`;
        console.log(`üéÆ Game Version: ${GAME_VERSION}`);
        console.log(`üìä Leaderboard Collection: ${LEADERBOARD_COLLECTION}`);

        // Calculate total gear score using game's existing method
        window.calculateGearScore = function() {
            let totalGearScore = 0;

            game.party.forEach(member => {
                if (!member.equipment) return;

                Object.values(member.equipment).forEach(item => {
                    if (!item) return;

                    // Use the game's existing gear score calculation
                    totalGearScore += game.calculateGearScore(item);
                });
            });

            return Math.floor(totalGearScore);
        };

        // Submit score to leaderboard
        window.submitToLeaderboard = async function() {
            if (!db) {
                console.log('Firebase not initialized');
                return;
            }

            // Get player name with uniqueness check
            // let playerName = localStorage.getItem('playerName');
            let playerName = "Gityx" + Math.floor(Math.random() * 10000) + 1;
            if (!playerName) {
                let nameExists = true;
                while (nameExists) {
                    // playerName = prompt('ËØ∑ËæìÂÖ•‰∏Ä‰∏™Áã¨ÁâπÂêçÂ≠ó‰ª•ÊòæÁ§∫Âú®ÊéíË°åÊ¶ú‰∏ä:');
                    if (!playerName || playerName.trim() === '') {
                        playerName = 'Anonymous_' + Math.floor(Math.random() * 10000);
                        nameExists = false;
                    } else {
                        // Check if name already exists
                        const nameCheck = await db.collection(LEADERBOARD_COLLECTION).doc(playerName).get();
                        if (nameCheck.exists) {
                            alert('Ëøô‰∏™ÂêçÂ≠óÂ∑≤ÁªèÊúâ‰∫∫Áî®‰∫Ü„ÄÇËØ∑ÈÄâÊã©Âè¶‰∏Ä‰∏™.');
                        } else {
                            nameExists = false;
                        }
                    }
                }
                localStorage.setItem('playerName', playerName);
            }

            // Track all-time highest stats (never go down)
            let highestFloor = parseInt(localStorage.getItem('highestFloorEver')) || 1;
            if (game.dungeonFloor > highestFloor) {
                highestFloor = game.dungeonFloor;
                localStorage.setItem('highestFloorEver', highestFloor);
            }

            let highestGearScore = parseInt(localStorage.getItem('highestGearScoreEver')) || 0;
            const currentGearScore = calculateGearScore();
            if (currentGearScore > highestGearScore) {
                highestGearScore = currentGearScore;
                localStorage.setItem('highestGearScoreEver', highestGearScore);
            }

            // Count pets (inventory + equipped) - filter out null/undefined
            const inventoryPets = game.pets ? game.pets.filter(p => p && p.type).length : 0;
            const equippedPets = game.equippedPets ? Object.values(game.equippedPets).filter(p => p && p.type).length : 0;
            const currentPets = inventoryPets + equippedPets;
            let highestPets = parseInt(localStorage.getItem('highestPetsEver')) || 0;
            if (currentPets > highestPets) {
                highestPets = currentPets;
                localStorage.setItem('highestPetsEver', highestPets);
            }

            // Count mythics (inventory + all equipped on party members)
            let currentMythics = 0;
            game.party.forEach(member => {
                if (member.equipment) {
                    Object.values(member.equipment).forEach(item => {
                        if (item && item.rarity === 'mythic') currentMythics++;
                    });
                }
            });
            game.inventory.forEach(item => {
                if (item && item.rarity === 'mythic') currentMythics++;
            });
            game.loot.forEach(item => {
                if (item && item.rarity === 'mythic') currentMythics++;
            });

            let highestMythics = parseInt(localStorage.getItem('highestMythicsEver')) || 0;
            if (currentMythics > highestMythics) {
                highestMythics = currentMythics;
                localStorage.setItem('highestMythicsEver', highestMythics);
            }

            // Get dungeon progress for boss kills (these already track totals and never go down)
            const vaultKills = game.dungeonProgress && game.dungeonProgress.vault ? game.dungeonProgress.vault.bossKills || 0 : 0;
            const runeTrialKills = game.dungeonProgress && game.dungeonProgress.runetrial ? game.dungeonProgress.runetrial.bossKills || 0 : 0;

            // Track highest endless dungeon kill count
            let highestEndlessKills = parseInt(localStorage.getItem('highestEndlessKills')) || 0;
            const currentEndlessKills = parseInt(localStorage.getItem('currentEndlessKills')) || 0;
            if (currentEndlessKills > highestEndlessKills) {
                highestEndlessKills = currentEndlessKills;
                localStorage.setItem('highestEndlessKills', highestEndlessKills);
            }

            const floor = highestFloor;
            const gearScore = highestGearScore;

            try {
                // Update or create leaderboard entry
                await db.collection(LEADERBOARD_COLLECTION).doc(playerName).set({
                    name: playerName,
                    highestFloor: floor,
                    gearScore: gearScore,
                    petsFound: highestPets,
                    mythicsFound: highestMythics,
                    vaultKills: vaultKills,
                    runeTrialKills: runeTrialKills,
                    endlessKills: highestEndlessKills,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });

                console.log('‚úÖ Score submitted to leaderboard!');
                game.addLog(`Score submitted! Floor ${floor}, Gear Score ${gearScore}`, 'gold');
            } catch (error) {
                console.error('Error submitting score:', error);
            }
        };

        // View leaderboard with tabs
        window.viewLeaderboard = async function(category = 'gearScore') {
            if (!db) {
                alert('Leaderboard not available - Firebase not initialized');
                return;
            }

            try {
                let categoryDisplay = '';
                let categoryIcon = '';
                let orderByField = '';

                switch(category) {
                    case 'gearScore':
                        categoryDisplay = 'TOP GEAR SCORES';
                        categoryIcon = '‚öîÔ∏è';
                        orderByField = 'gearScore';
                        break;
                    case 'highestFloor':
                        categoryDisplay = 'HIGHEST FLOORS';
                        categoryIcon = 'üèÜ';
                        orderByField = 'highestFloor';
                        break;
                    case 'petsFound':
                        categoryDisplay = 'MOST PETS FOUND';
                        categoryIcon = 'üêæ';
                        orderByField = 'petsFound';
                        break;
                    case 'mythicsFound':
                        categoryDisplay = 'MOST MYTHICS FOUND';
                        categoryIcon = '‚ú®';
                        orderByField = 'mythicsFound';
                        break;
                    case 'runeTrialKills':
                        categoryDisplay = 'RUNE TRIAL BOSS KILLS';
                        categoryIcon = 'üîÆ';
                        orderByField = 'runeTrialKills';
                        break;
                    case 'vaultKills':
                        categoryDisplay = 'VAULT BOSS KILLS';
                        categoryIcon = 'üîí';
                        orderByField = 'vaultKills';
                        break;
                    case 'endlessKills':
                        categoryDisplay = 'DIVINE ARENA KILLS';
                        categoryIcon = '‚öîÔ∏è';
                        orderByField = 'endlessKills';
                        break;
                }

                const snapshot = await db.collection(LEADERBOARD_COLLECTION)
                    .orderBy(orderByField, 'desc')
                    .limit(10)
                    .get();

                let html = `
                <div style="color: white; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); padding: 40px; border-radius: 20px; max-width: 950px; box-shadow: 0 20px 60px rgba(0,0,0,0.5); font-family: 'Rajdhani', sans-serif;">

                    <!-- Category title -->
                    <h2 style="background: linear-gradient(90deg, #f59e0b 0%, #fbbf24 50%, #f59e0b 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; margin-bottom: 10px; text-align: center; font-size: 28px; font-weight: 900; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 2px 10px rgba(245,158,11,0.3);">${categoryIcon} ${categoryDisplay} ${categoryIcon}</h2>
                    <div style="text-align: center; font-size: 14px; color: #64748b; margin-bottom: 5px; font-weight: 600; letter-spacing: 1px;">TOP 10 PLAYERS</div>
                    <div style="text-align: center; font-size: 11px; color: #475569; margin-bottom: 8px; font-weight: 500;">Updates every 30 minutes</div>
                    <div style="text-align: center; font-size: 12px; color: #a855f7; margin-bottom: 25px; font-weight: 700; text-shadow: 0 0 10px rgba(168, 85, 247, 0.5);">üéÆ Version: ${GAME_VERSION}</div>

                    <!-- Main content wrapper with sidebar -->
                    <div style="display: flex; gap: 20px;">
                        <!-- Left sidebar with vertical categories -->
                        <div style="display: flex; flex-direction: column; gap: 10px; min-width: 80px;">
                            <button onclick="viewLeaderboard('gearScore')" style="padding: 15px; background: ${category === 'gearScore' ? 'linear-gradient(135deg, rgba(168,85,247,0.3), rgba(139,92,246,0.2))' : 'rgba(45,50,80,0.6)'}; border: 2px solid ${category === 'gearScore' ? '#a855f7' : 'rgba(75,85,99,0.5)'}; border-radius: 12px; color: white; cursor: pointer; font-size: 28px; transition: all 0.3s; box-shadow: ${category === 'gearScore' ? '0 0 20px rgba(168,85,247,0.4)' : 'none'}; min-height: 70px; display: flex; align-items: center; justify-content: center;">‚öîÔ∏è</button>
                            <button onclick="viewLeaderboard('highestFloor')" style="padding: 15px; background: ${category === 'highestFloor' ? 'linear-gradient(135deg, rgba(245,158,11,0.3), rgba(217,119,6,0.2))' : 'rgba(45,50,80,0.6)'}; border: 2px solid ${category === 'highestFloor' ? '#f59e0b' : 'rgba(75,85,99,0.5)'}; border-radius: 12px; color: white; cursor: pointer; font-size: 28px; transition: all 0.3s; box-shadow: ${category === 'highestFloor' ? '0 0 20px rgba(245,158,11,0.4)' : 'none'}; min-height: 70px; display: flex; align-items: center; justify-content: center;">üèÜ</button>
                            <button onclick="viewLeaderboard('petsFound')" style="padding: 15px; background: ${category === 'petsFound' ? 'linear-gradient(135deg, rgba(16,185,129,0.3), rgba(5,150,105,0.2))' : 'rgba(45,50,80,0.6)'}; border: 2px solid ${category === 'petsFound' ? '#10b981' : 'rgba(75,85,99,0.5)'}; border-radius: 12px; color: white; cursor: pointer; font-size: 28px; transition: all 0.3s; box-shadow: ${category === 'petsFound' ? '0 0 20px rgba(16,185,129,0.4)' : 'none'}; min-height: 70px; display: flex; align-items: center; justify-content: center;">üêæ</button>
                            <button onclick="viewLeaderboard('mythicsFound')" style="padding: 15px; background: ${category === 'mythicsFound' ? 'linear-gradient(135deg, rgba(201,16,167,0.3), rgba(160,23,141,0.2))' : 'rgba(45,50,80,0.6)'}; border: 2px solid ${category === 'mythicsFound' ? '#c910a7' : 'rgba(75,85,99,0.5)'}; border-radius: 12px; color: white; cursor: pointer; font-size: 28px; transition: all 0.3s; box-shadow: ${category === 'mythicsFound' ? '0 0 20px rgba(201,16,167,0.4)' : 'none'}; min-height: 70px; display: flex; align-items: center; justify-content: center;">‚ú®</button>
                            <button onclick="viewLeaderboard('runeTrialKills')" style="padding: 15px; background: ${category === 'runeTrialKills' ? 'linear-gradient(135deg, rgba(59,130,246,0.3), rgba(37,99,235,0.2))' : 'rgba(45,50,80,0.6)'}; border: 2px solid ${category === 'runeTrialKills' ? '#3b82f6' : 'rgba(75,85,99,0.5)'}; border-radius: 12px; color: white; cursor: pointer; font-size: 28px; transition: all 0.3s; box-shadow: ${category === 'runeTrialKills' ? '0 0 20px rgba(59,130,246,0.4)' : 'none'}; min-height: 70px; display: flex; align-items: center; justify-content: center;"><img src="blue_key_64_transparent.png" style="width: 40px; height: 40px;"></button>
                            <button onclick="viewLeaderboard('vaultKills')" style="padding: 15px; background: ${category === 'vaultKills' ? 'linear-gradient(135deg, rgba(239,68,68,0.3), rgba(220,38,38,0.2))' : 'rgba(45,50,80,0.6)'}; border: 2px solid ${category === 'vaultKills' ? '#ef4444' : 'rgba(75,85,99,0.5)'}; border-radius: 12px; color: white; cursor: pointer; font-size: 28px; transition: all 0.3s; box-shadow: ${category === 'vaultKills' ? '0 0 20px rgba(239,68,68,0.4)' : 'none'}; min-height: 70px; display: flex; align-items: center; justify-content: center;"><img src="gold_key_64_transparent.png" style="width: 40px; height: 40px;"></button>
                            <button onclick="viewLeaderboard('endlessKills')" style="padding: 15px; background: ${category === 'endlessKills' ? 'linear-gradient(135deg, rgba(251,191,36,0.3), rgba(245,158,11,0.2))' : 'rgba(45,50,80,0.6)'}; border: 2px solid ${category === 'endlessKills' ? '#fbbf24' : 'rgba(75,85,99,0.5)'}; border-radius: 12px; color: white; cursor: pointer; font-size: 28px; transition: all 0.3s; box-shadow: ${category === 'endlessKills' ? '0 0 20px rgba(251,191,36,0.4)' : 'none'}; min-height: 70px; display: flex; align-items: center; justify-content: center;">üíÄ</button>
                        </div>

                        <!-- Right content area -->
                        <div style="flex: 1;">
                `;

                // Show player's rank FIRST (cached for 30 minutes)
                const playerName = localStorage.getItem('playerName');
                if (playerName) {
                    const cacheKey = `rank_${category}_${playerName}`;
                    const cacheTimeKey = `rank_${category}_${playerName}_time`;
                    const cachedRank = localStorage.getItem(cacheKey);
                    const cachedTime = localStorage.getItem(cacheTimeKey);
                    const now = Date.now();

                    let playerRank = 0;
                    let playerScore = 0;

                    // Use cache if less than 30 minutes old
                    if (cachedRank && cachedTime && (now - parseInt(cachedTime)) < 1800000) {
                        const cached = JSON.parse(cachedRank);
                        playerRank = cached.rank;
                        playerScore = cached.score;
                    } else {
                        // Query and update cache
                        const allPlayers = await db.collection(LEADERBOARD_COLLECTION)
                            .orderBy(orderByField, 'desc')
                            .get();

                        allPlayers.forEach((doc, index) => {
                            if (doc.data().name === playerName) {
                                playerRank = index + 1;
                                playerScore = doc.data()[orderByField] || 0;
                            }
                        });

                        // Cache the result
                        localStorage.setItem(cacheKey, JSON.stringify({rank: playerRank, score: playerScore}));
                        localStorage.setItem(cacheTimeKey, now.toString());
                    }

                    // Always show your stats, even if rank is 0
                    html += `
                    <div style="margin-bottom: 25px; padding: 20px; background: linear-gradient(135deg, rgba(168,85,247,0.2) 0%, rgba(168,85,247,0.05) 100%); border: 2px solid rgba(168,85,247,0.5); border-radius: 15px; text-align: center; box-shadow: 0 5px 20px rgba(168,85,247,0.2);">
                        <div style="font-size: 12px; color: #a855f7; font-weight: 900; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 8px;">Your Stats</div>
                        ${playerRank > 0 ? `
                            <div style="font-size: 32px; font-weight: 900; background: linear-gradient(90deg, #a855f7 0%, #ec4899 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">#${playerRank.toLocaleString()}</div>
                        ` : `
                            <div style="font-size: 18px; color: #64748b; font-weight: 700;">Not Yet Ranked</div>
                        `}
                        <div style="font-size: 18px; color: #e2e8f0; margin-top: 5px; font-weight: 600;">${playerName}</div>
                        <div style="font-size: 22px; color: #f59e0b; margin-top: 8px; font-weight: 900;">${playerScore.toLocaleString()}</div>
                    </div>
                    `;
                }

                html += `
                    <!-- Leaderboard table -->
                    <div style="background: rgba(0,0,0,0.3); border-radius: 15px; overflow: hidden; box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="background: linear-gradient(90deg, rgba(245,158,11,0.2) 0%, rgba(245,158,11,0.05) 100%); border-bottom: 2px solid rgba(245,158,11,0.5);">
                                    <th style="padding: 15px 20px; text-align: left; font-size: 14px; font-weight: 700; color: #94a3b8; text-transform: uppercase; letter-spacing: 1px;">Rank</th>
                                    <th style="padding: 15px 20px; text-align: left; font-size: 14px; font-weight: 700; color: #94a3b8; text-transform: uppercase; letter-spacing: 1px;">Player</th>
                                    <th style="padding: 15px 20px; text-align: right; font-size: 14px; font-weight: 700; color: #94a3b8; text-transform: uppercase; letter-spacing: 1px;">Score</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                let rank = 0;
                snapshot.forEach((doc) => {
                    rank++;
                    const data = doc.data();
                    const emoji = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `#${rank}`;
                    const score = data[orderByField] || 0;

                    // Different styling for top 3
                    let rowBg = 'rgba(255,255,255,0.02)';
                    let rankColor = '#64748b';
                    let glowEffect = '';

                    if (rank === 1) {
                        rowBg = 'linear-gradient(90deg, rgba(251,191,36,0.15) 0%, rgba(251,191,36,0.05) 100%)';
                        rankColor = '#fbbf24';
                        glowEffect = 'box-shadow: inset 0 0 20px rgba(251,191,36,0.1);';
                    } else if (rank === 2) {
                        rowBg = 'linear-gradient(90deg, rgba(203,213,225,0.15) 0%, rgba(203,213,225,0.05) 100%)';
                        rankColor = '#cbd5e1';
                        glowEffect = 'box-shadow: inset 0 0 20px rgba(203,213,225,0.1);';
                    } else if (rank === 3) {
                        rowBg = 'linear-gradient(90deg, rgba(205,127,50,0.15) 0%, rgba(205,127,50,0.05) 100%)';
                        rankColor = '#cd7f32';
                        glowEffect = 'box-shadow: inset 0 0 20px rgba(205,127,50,0.1);';
                    }

                    html += `
                        <tr style="background: ${rowBg}; border-bottom: 1px solid rgba(255,255,255,0.05); transition: all 0.3s; ${glowEffect}">
                            <td style="padding: 18px 20px; font-size: ${rank <= 3 ? '24px' : '16px'}; font-weight: bold; color: ${rankColor};">${emoji}</td>
                            <td style="padding: 18px 20px; font-size: 16px; font-weight: 600; color: #e2e8f0;">${data.name}</td>
                            <td style="padding: 18px 20px; text-align: right; font-size: 18px; font-weight: 900; color: #f59e0b; text-shadow: 0 2px 10px rgba(245,158,11,0.3);">${score.toLocaleString()}</td>
                        </tr>
                    `;
                });

                html += `
                            </tbody>
                        </table>
                    </div>
                `;
                if (playerName) {
                    const cacheKey = `rank_${category}_${playerName}`;
                    const cacheTimeKey = `rank_${category}_${playerName}_time`;
                    const cachedRank = localStorage.getItem(cacheKey);
                    const cachedTime = localStorage.getItem(cacheTimeKey);
                    const now = Date.now();

                    let playerRank = 0;
                    let playerScore = 0;

                    // Use cache if less than 30 minutes old
                    if (cachedRank && cachedTime && (now - parseInt(cachedTime)) < 1800000) {
                        const cached = JSON.parse(cachedRank);
                        playerRank = cached.rank;
                        playerScore = cached.score;
                    } else {
                        // Query and update cache
                        const allPlayers = await db.collection(LEADERBOARD_COLLECTION)
                            .orderBy(orderByField, 'desc')
                            .get();

                        allPlayers.forEach((doc, index) => {
                            if (doc.data().name === playerName) {
                                playerRank = index + 1;
                                playerScore = doc.data()[orderByField] || 0;
                            }
                        });

                        // Cache the result
                        localStorage.setItem(cacheKey, JSON.stringify({rank: playerRank, score: playerScore}));
                        localStorage.setItem(cacheTimeKey, now.toString());
                    }

                    if (playerRank > 0) {
                        html += `
                        <div style="margin-top: 25px; padding: 20px; background: linear-gradient(135deg, rgba(168,85,247,0.2) 0%, rgba(168,85,247,0.05) 100%); border: 2px solid rgba(168,85,247,0.5); border-radius: 15px; text-align: center; box-shadow: 0 5px 20px rgba(168,85,247,0.2);">
                            <div style="font-size: 12px; color: #a855f7; font-weight: 900; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 8px;">Your Rank</div>
                            <div style="font-size: 28px; font-weight: 900; background: linear-gradient(90deg, #a855f7 0%, #ec4899 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">#${playerRank.toLocaleString()}</div>
                            <div style="font-size: 18px; color: #e2e8f0; margin-top: 5px; font-weight: 600;">${playerName}</div>
                            <div style="font-size: 20px; color: #f59e0b; margin-top: 8px; font-weight: 900;">${playerScore.toLocaleString()}</div>
                        </div>
                        `;
                    }
                }

                html += `
                    <button onclick="document.getElementById('leaderboard-modal').style.display='none'" style="margin-top: 25px; padding: 18px 40px; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; border: none; border-radius: 12px; cursor: pointer; font-size: 16px; font-weight: 900; width: 100%; text-transform: uppercase; letter-spacing: 2px; box-shadow: 0 5px 20px rgba(245,158,11,0.3); transition: all 0.3s;">Close</button>
                </div>
                `;

                // Create modal
                let modal = document.getElementById('leaderboard-modal');
                if (!modal) {
                    modal = document.createElement('div');
                    modal.id = 'leaderboard-modal';
                    modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); backdrop-filter: blur(10px); display: flex; justify-content: center; align-items: center; z-index: 10001; overflow-y: auto; padding: 20px;';
                    document.body.appendChild(modal);
                }

                modal.innerHTML = html;
                modal.style.display = 'flex';

            } catch (error) {
                console.error('Error loading leaderboard:', error);
                alert('Error loading leaderboard: ' + error.message);
            }
        };


        // Auto-submit when floor increases
        let lastSubmittedFloor = 0;

        // Ask for player name after 2 minutes, then auto-submit every 30 minutes
        setTimeout(() => {
            submitToLeaderboard(); // First submit at 2 minutes
            if (window.game && window.game.timerManager) {
            window.game.leaderboardInterval = window.game.timerManager.setInterval(() => submitToLeaderboard(), 1800000);
        } else {
            setInterval(() => submitToLeaderboard(), 1800000);
        } // Then every 30 minutes
        }, 120000);

        // Save on unload
        window.addEventListener('beforeunload', saveGame);

        // Load on start (only if game exists)
        setTimeout(() => {
            if (window.game) {
                loadGame();
            }
        }, 100);

        window.addEventListener('resize', () => {
            if (window.game && window.game.canvas) {
                window.game.canvas.width = window.game.canvas.offsetWidth;
                window.game.canvas.height = window.game.canvas.offsetHeight;
                window.game.offsetX = window.game.canvas.width / 2;
                window.game.offsetY = window.game.canvas.height / 3;
            }
        });
    </script>

<script>
// Exit dialog code - NEW VERSION
const exitDialog = document.createElement('div');
exitDialog.id = 'exit-dialog';
exitDialog.style.display = 'none';

exitDialog.innerHTML = `
    <div class="dialog-content">
        <div class="icon-container">
            <svg viewBox="0 0 24 24">
                <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" stroke-linecap="round" stroke-linejoin="round"/>
                <polyline points="16 17 21 12 16 7" stroke-linecap="round" stroke-linejoin="round"/>
                <line x1="21" y1="12" x2="9" y2="12" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </div>

        <h2>Exit Game?</h2>
        <p class="subtitle">Your progress has been saved. Are you sure you want to leave?</p>

        <div class="option-container">
            <div class="fullscreen-toggle" id="fullscreen-toggle-btn">
                <div class="toggle-label">
                    <svg viewBox="0 0 24 24">
                        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Fullscreen Mode
                </div>
                <div class="switch active" id="fullscreen-switch">
                    <div class="switch-handle"></div>
                </div>
            </div>
        </div>

        <button id="reset-account-btn" style="width: 100%; padding: 12px; margin: 20px 0; background: linear-gradient(135deg, #dc2626, #991b1b); color: white; border: 2px solid #ef4444; border-radius: 10px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 14px; font-weight: 700; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 1px;">
            üîÑ Reset Account & Start Fresh
        </button>

        <div class="button-container">
            <button id="exit-yes">
                <img src="exit%20game.png" alt="Exit Game">
            </button>
            <button id="exit-no">
                <img src="keep%20playing3.png" alt="Keep Playing">
            </button>
        </div>

        <div class="community-buttons">
            <button class="community-btn" id="discord-btn" title="Join our Discord">
                <img src="discord.png" alt="Discord">
            </button>
            <button class="community-btn" id="youtube-btn" title="Subscribe on YouTube">
                <img src="youtube%20button.png" alt="YouTube">
            </button>
            <button class="community-btn" id="x-btn" title="Follow on X">
                <img src="x.png" alt="X">
            </button>
            <button class="community-btn" id="wiki-btn" title="Visit Wiki">
                <img src="wiki%204.png" alt="Wiki">
            </button>
        </div>
    </div>
`;

document.body.appendChild(exitDialog);

function showExitDialog() {
    document.getElementById('exit-dialog').style.display = 'flex';
}

function closeExitDialog() {
    document.getElementById('exit-dialog').style.display = 'none';
}

function openDiscord() {
    window.open('https://discord.gg/nnMYsPyWfV', '_blank');
}

function openYouTube() {
    window.open('https://www.youtube.com/channel/UCmIPFTLZdm1S-2U_e8ujnTA', '_blank');
}

function openX() {
    window.open('https://x.com/GameDevJoeyYT', '_blank');
}

function openWiki() {
    window.open('https://graphic37.github.io/Everfall-Wiki/', '_blank');
}

function toggleFullscreen() {
    const switchElement = document.getElementById('fullscreen-switch');
    switchElement.classList.toggle('active');

    const isActive = switchElement.classList.contains('active');

    if (window.electronAPI) {
        window.electronAPI.toggleFullscreen(isActive);
    } else {
        if (isActive) {
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen();
            }
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    }
}

function exitGame() {
    if (window.electronAPI) {
        window.electronAPI.exitApp();
    } else {
        window.close();
        setTimeout(() => {
            window.location.href = 'about:blank';
        }, 100);
    }
}

function resetAccount() {
        if (window.game && window.game.cleanup) {
            window.game.cleanup();
        }

    // Create confirmation dialog
    const confirmOverlay = document.createElement('div');
    confirmOverlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.95); display: flex; justify-content: center; align-items: center; z-index: 200000;';

    const confirmPanel = document.createElement('div');
    confirmPanel.style.cssText = 'background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(6, 9, 23, 0.98) 100%); border: 3px solid #ef4444; border-radius: 20px; padding: 40px; text-align: center; box-shadow: 0 30px 80px rgba(0,0,0,0.9); max-width: 500px;';

    confirmPanel.innerHTML = `
        <div style="font-size: 56px; margin-bottom: 20px;">‚ö†Ô∏è</div>
        <div style="font-family: 'Orbitron', sans-serif; font-size: 28px; font-weight: 800; color: #ef4444; margin-bottom: 20px;">RESET ACCOUNT?</div>
        <div style="font-size: 16px; color: #e2e8f0; margin-bottom: 15px; line-height: 1.6;">
            This will <strong style="color: #ef4444;">permanently delete</strong> ALL of your progress:
        </div>
        <div style="text-align: left; margin: 20px 0; padding: 20px; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 10px;">
            <div style="font-size: 14px; color: #fca5a5; margin-bottom: 8px;">‚Ä¢ All characters and their levels</div>
            <div style="font-size: 14px; color: #fca5a5; margin-bottom: 8px;">‚Ä¢ All equipment, keystones, and runes</div>
            <div style="font-size: 14px; color: #fca5a5; margin-bottom: 8px;">‚Ä¢ All gold, pets, and collected items</div>
            <div style="font-size: 14px; color: #fca5a5; margin-bottom: 8px;">‚Ä¢ Skill tree allocations</div>
            <div style="font-size: 14px; color: #fca5a5;">‚Ä¢ Leaderboard position and stats</div>
        </div>
        <div style="font-size: 14px; color: #94a3b8; margin-bottom: 30px; font-style: italic;">
            This action cannot be undone!
        </div>
        <div style="display: flex; gap: 15px;">
            <button id="reset-cancel-btn" style="flex: 1; padding: 15px; background: linear-gradient(135deg, #6366f1, #4f46e5); color: white; border: none; border-radius: 10px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 16px; font-weight: 700;">Cancel</button>
            <button id="reset-confirm-btn" style="flex: 1; padding: 15px; background: linear-gradient(135deg, #ef4444, #dc2626); color: white; border: none; border-radius: 10px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 16px; font-weight: 700;">DELETE ALL</button>
        </div>
    `;

    confirmOverlay.appendChild(confirmPanel);
    document.body.appendChild(confirmOverlay);

    // Cancel button
    document.getElementById('reset-cancel-btn').addEventListener('click', () => {
        confirmOverlay.remove();
    });

    // Confirm button - actually reset
    document.getElementById('reset-confirm-btn').addEventListener('click', () => {
        // Clear ALL localStorage data
        localStorage.clear();

        // Show brief "Resetting..." message
        confirmPanel.innerHTML = `
            <div style="font-size: 56px; margin-bottom: 20px;">üîÑ</div>
            <div style="font-family: 'Orbitron', sans-serif; font-size: 24px; font-weight: 800; color: #10b981; margin-bottom: 20px;">Resetting Account...</div>
            <div style="font-size: 14px; color: #94a3b8;">Please wait</div>
        `;

        // Reload page after brief delay
        setTimeout(() => {
            window.location.reload();
        }, 1500);
    });
}

document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        const dialog = document.getElementById('exit-dialog');
        if (dialog.style.display === 'none' || !dialog.style.display) {
            showExitDialog();
        } else {
            closeExitDialog();
        }
    }
});

document.getElementById('exit-yes').addEventListener('click', exitGame);
document.getElementById('exit-no').addEventListener('click', closeExitDialog);
document.getElementById('reset-account-btn').addEventListener('click', resetAccount);
document.getElementById('discord-btn').addEventListener('click', openDiscord);
document.getElementById('youtube-btn').addEventListener('click', openYouTube);
document.getElementById('x-btn').addEventListener('click', openX);
document.getElementById('wiki-btn').addEventListener('click', openWiki);
document.getElementById('fullscreen-toggle-btn').addEventListener('click', toggleFullscreen);

window.addEventListener('load', function() {
    const switchElement = document.getElementById('fullscreen-switch');
    if (document.fullscreenElement) {
        switchElement.classList.add('active');
    }
});

document.addEventListener('fullscreenchange', function() {
    const switchElement = document.getElementById('fullscreen-switch');
    if (document.fullscreenElement) {
        switchElement.classList.add('active');
    } else {
        switchElement.classList.remove('active');
    }
});

// Bottom UI Resize Handler
(function() {
    const resizeHandle = document.getElementById('resize-handle');
    const bottomUI = document.getElementById('bottom-ui');
    let isResizing = false;
    let startY = 0;
    let startHeight = 0;

    // Load saved height from localStorage
    const savedHeight = localStorage.getItem('bottomUIHeight');
    if (savedHeight) {
        bottomUI.style.height = savedHeight + 'px';
    }

    resizeHandle.addEventListener('mousedown', function(e) {
        isResizing = true;
        startY = e.clientY;
        startHeight = bottomUI.offsetHeight;
        resizeHandle.classList.add('dragging');
        document.body.style.cursor = 'ns-resize';
        document.body.style.userSelect = 'none';
        e.preventDefault();
    });

    document.addEventListener('mousemove', function(e) {
        if (!isResizing) return;

        const deltaY = startY - e.clientY; // Inverted because moving up increases height
        let newHeight = startHeight + deltaY;

        // Constrain height between 200px and 800px
        newHeight = Math.max(200, Math.min(800, newHeight));

        bottomUI.style.height = newHeight + 'px';
    });

    document.addEventListener('mouseup', function() {
        if (isResizing) {
            isResizing = false;
            resizeHandle.classList.remove('dragging');
            document.body.style.cursor = '';
            document.body.style.userSelect = '';

            // Save the new height to localStorage
            clearTimeout(window._bottomUIHeightSaveTimer);
                window._bottomUIHeightSaveTimer = setTimeout(() => {
                    localStorage.setItem('bottomUIHeight', bottomUI.offsetHeight);
                }, 150);
        }
    });
})();


// Helper function to debug keystone cooldowns - accessible from console
window.checkKeystones = function() {
    if (!window.game || !window.game.party) {
        console.log('Game not loaded yet');
        return;
    }

    console.log('=== KEYSTONE STATUS ===');
    console.log(`In Battle: ${window.game.inBattle}`);
    console.log(`Enemies: ${window.game.enemies ? window.game.enemies.length : 0}`);
    console.log('');

    window.game.party.forEach((member, i) => {
        const keystoneType = member.className.toLowerCase();
        const equipped = window.game.equippedKeystones[keystoneType];

        console.log(`[${i}] ${member.name} (${member.className})`);
        console.log(`   Keystone: ${equipped ? equipped.internalName : 'NONE'}`);
        console.log(`   Cooldown: ${member.keystoneCooldown !== undefined ? member.keystoneCooldown.toFixed(2) : 'undefined'}s`);
        console.log(`   Max CD: ${member.keystoneMaxCooldown !== undefined ? member.keystoneMaxCooldown : 'undefined'}s`);
        console.log(`   Last CD Time: ${member.lastKeystoneCooldownTime ? 'set' : 'not set'}`);
        console.log('');
    });
};

console.log('üí° Type checkKeystones() in console to see keystone status');



// Helper to open inventory tab
window.openInventory = function() {
    // Switch to loot tab
    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
    document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));
    document.querySelector('[data-tab="loot"]').classList.add('active');
    document.getElementById('loot-tab').classList.add('active');

    // Switch to inventory sub-tab
    document.querySelectorAll('.loot-sub-tab').forEach(tab => tab.classList.remove('active'));
    document.querySelectorAll('.loot-section').forEach(section => section.style.display = 'none');
    document.querySelector('[data-loot-tab="inventory"]').classList.add('active');
    document.getElementById('loot-inventory-section').style.display = 'block';

    if (window.game && window.game.showInventory) {
        window.game.showInventory();
    }

    console.log('üì¶ Switched to Inventory tab');
};

console.log('üì¶ Type openInventory() to view your items');

// Show detailed drop table for Divine Arena
window.showDropTable = function() {
    const dropTableHTML = `
        <div id="drop-table-modal" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.95); display: flex; justify-content: center; align-items: center; z-index: 10000; backdrop-filter: blur(10px); padding: 20px;">
            <div id="drop-table-content" style="background: linear-gradient(135deg, rgba(15, 23, 42, 0.98), rgba(30, 41, 59, 0.98)); border: 3px solid #d4a747; border-radius: 16px; max-width: 1000px; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 20px 80px rgba(0, 0, 0, 0.9), 0 0 40px rgba(212, 167, 71, 0.3); padding: 30px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px;">
                    <h2 style="font-family: 'Orbitron', sans-serif; font-size: 32px; font-weight: 800; color: #f5deb3; text-shadow: 0 0 10px rgba(200, 160, 50, 0.7); margin: 0;">‚ú® Divine Arena Drop Table ‚ú®</h2>
                    <button id="close-drop-table-btn" style="background: linear-gradient(135deg, #ef4444, #dc2626); border: none; color: white; font-size: 24px; width: 40px; height: 40px; border-radius: 50%; cursor: pointer; font-weight: 700; box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);">√ó</button>
                </div>

                <div style="background: rgba(0, 0, 0, 0.3); padding: 15px; border-radius: 12px; margin-bottom: 20px; border: 1px solid rgba(212, 167, 71, 0.3);">
                    <p style="color: #e8d5a8; font-size: 16px; margin: 0; line-height: 1.6;">
                        <strong style="color: #fbbf24;">üìä End of Run Rewards:</strong> 3 items awarded based on total kills<br>
                        <strong style="color: #fbbf24;">üéØ Item Level:</strong> Scales with enemy level (increases as you progress)<br>
                        <strong style="color: #fbbf24;">üíé Rarity:</strong> Determined by kill count brackets below<br>
                        <strong style="color: #f59e0b;">‚ö†Ô∏è Important:</strong> Need 10+ kills to earn any loot (Victory threshold)
                    </p>
                </div>

                <div style="display: grid; gap: 12px;">
                    <!-- 1-9 Kills -->
                    <div style="background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(220, 38, 38, 0.15)); border: 2px solid rgba(239, 68, 68, 0.5); border-radius: 10px; padding: 15px;">
                        <div style="font-family: 'Orbitron', sans-serif; font-size: 18px; font-weight: 700; color: #ef4444; margin-bottom: 8px;">üíÄ Kills 1-9: DEFEAT</div>
                        <div style="color: #fca5a5; font-size: 14px;">‚ùå No item rewards (Victory threshold not reached)</div>
                    </div>

                    <!-- 10-20 Kills -->
                    <div style="background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(22, 163, 74, 0.15)); border: 2px solid rgba(34, 197, 94, 0.5); border-radius: 10px; padding: 15px;">
                        <div style="font-family: 'Orbitron', sans-serif; font-size: 18px; font-weight: 700; color: #10b981; margin-bottom: 8px;">‚öîÔ∏è Kills 10-20: VICTORY (Basic Rewards)</div>
                        <div style="color: #d1d5db; font-size: 14px; line-height: 1.8;">
                            <span style="color: #3b82f6;">üîµ Rare:</span> 50% |
                            <span style="color: #a855f7;">üü£ Epic:</span> 35% |
                            <span style="color: #f59e0b;">üü† Legendary:</span> 15%
                        </div>
                    </div>

                    <!-- 21-39 Kills -->
                    <div style="background: linear-gradient(135deg, rgba(168, 85, 247, 0.2), rgba(139, 92, 246, 0.15)); border: 2px solid rgba(168, 85, 247, 0.5); border-radius: 10px; padding: 15px;">
                        <div style="font-family: 'Orbitron', sans-serif; font-size: 18px; font-weight: 700; color: #a855f7; margin-bottom: 8px;">‚ö° Kills 21-39: Enhanced Rewards</div>
                        <div style="color: #d1d5db; font-size: 14px; line-height: 1.8;">
                            <span style="color: #3b82f6;">üîµ Rare:</span> 35% |
                            <span style="color: #a855f7;">üü£ Epic:</span> 44.9% |
                            <span style="color: #f59e0b;">üü† Legendary:</span> 20% |
                            <span style="color: #ec4899;">üíé Mythic:</span> 0.1%
                        </div>
                    </div>

                    <!-- 40-59 Kills -->
                    <div style="background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(217, 119, 6, 0.15)); border: 2px solid rgba(245, 158, 11, 0.5); border-radius: 10px; padding: 15px;">
                        <div style="font-family: 'Orbitron', sans-serif; font-size: 18px; font-weight: 700; color: #f59e0b; margin-bottom: 8px;">üî• Kills 40-59: Superior Rewards</div>
                        <div style="color: #d1d5db; font-size: 14px; line-height: 1.8;">
                            <span style="color: #3b82f6;">üîµ Rare:</span> 20% |
                            <span style="color: #a855f7;">üü£ Epic:</span> 49.8% |
                            <span style="color: #f59e0b;">üü† Legendary:</span> 30% |
                            <span style="color: #ec4899;">üíé Mythic:</span> 0.2%
                        </div>
                    </div>

                    <!-- 60-79 Kills -->
                    <div style="background: linear-gradient(135deg, rgba(236, 72, 153, 0.2), rgba(219, 39, 119, 0.15)); border: 2px solid rgba(236, 72, 153, 0.5); border-radius: 10px; padding: 15px;">
                        <div style="font-family: 'Orbitron', sans-serif; font-size: 18px; font-weight: 700; color: #ec4899; margin-bottom: 8px;">üí´ Kills 60-79: Elite Rewards</div>
                        <div style="color: #d1d5db; font-size: 14px; line-height: 1.8;">
                            <span style="color: #3b82f6;">üîµ Rare:</span> 10% |
                            <span style="color: #a855f7;">üü£ Epic:</span> 49.7% |
                            <span style="color: #f59e0b;">üü† Legendary:</span> 40% |
                            <span style="color: #ec4899;">üíé Mythic:</span> 0.3%
                        </div>
                    </div>

                    <!-- 80-99 Kills -->
                    <div style="background: linear-gradient(135deg, rgba(251, 191, 36, 0.2), rgba(245, 158, 11, 0.15)); border: 2px solid rgba(251, 191, 36, 0.5); border-radius: 10px; padding: 15px;">
                        <div style="font-family: 'Orbitron', sans-serif; font-size: 18px; font-weight: 700; color: #fbbf24; margin-bottom: 8px;">‚≠ê Kills 80-99: Exceptional Rewards</div>
                        <div style="color: #d1d5db; font-size: 14px; line-height: 1.8;">
                            <span style="color: #3b82f6;">üîµ Rare:</span> 5% |
                            <span style="color: #a855f7;">üü£ Epic:</span> 44.5% |
                            <span style="color: #f59e0b;">üü† Legendary:</span> 50% |
                            <span style="color: #ec4899;">üíé Mythic:</span> 0.5%
                        </div>
                    </div>

                    <!-- 100-119 Kills -->
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(79, 70, 229, 0.15)); border: 2px solid rgba(99, 102, 241, 0.5); border-radius: 10px; padding: 15px;">
                        <div style="font-family: 'Orbitron', sans-serif; font-size: 18px; font-weight: 700; color: #6366f1; margin-bottom: 8px;">üåü Kills 100-119: Masterwork Rewards</div>
                        <div style="color: #d1d5db; font-size: 14px; line-height: 1.8;">
                            <span style="color: #a855f7;">üü£ Epic:</span> 34% |
                            <span style="color: #f59e0b;">üü† Legendary:</span> 65% |
                            <span style="color: #ec4899;">üíé Mythic:</span> 1%
                        </div>
                    </div>

                    <!-- 120-139 Kills -->
                    <div style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.25), rgba(124, 58, 237, 0.2)); border: 2px solid rgba(139, 92, 246, 0.6); border-radius: 10px; padding: 15px;">
                        <div style="font-family: 'Orbitron', sans-serif; font-size: 18px; font-weight: 700; color: #8b5cf6; margin-bottom: 8px;">üíé Kills 120-139: Legendary Rewards</div>
                        <div style="color: #d1d5db; font-size: 14px; line-height: 1.8;">
                            <span style="color: #a855f7;">üü£ Epic:</span> 23% |
                            <span style="color: #f59e0b;">üü† Legendary:</span> 75% |
                            <span style="color: #ec4899;">üíé Mythic:</span> 2%
                        </div>
                    </div>

                    <!-- 140-159 Kills -->
                    <div style="background: linear-gradient(135deg, rgba(236, 72, 153, 0.25), rgba(219, 39, 119, 0.2)); border: 2px solid rgba(236, 72, 153, 0.6); border-radius: 10px; padding: 15px;">
                        <div style="font-family: 'Orbitron', sans-serif; font-size: 18px; font-weight: 700; color: #ec4899; margin-bottom: 8px;">üîÆ Kills 140-159: Mythic Tier</div>
                        <div style="color: #d1d5db; font-size: 14px; line-height: 1.8;">
                            <span style="color: #a855f7;">üü£ Epic:</span> 12% |
                            <span style="color: #f59e0b;">üü† Legendary:</span> 85% |
                            <span style="color: #ec4899;">üíé Mythic:</span> 3%
                        </div>
                    </div>

                    <!-- 160-179 Kills -->
                    <div style="background: linear-gradient(135deg, rgba(244, 114, 182, 0.25), rgba(236, 72, 153, 0.2)); border: 2px solid rgba(244, 114, 182, 0.6); border-radius: 10px; padding: 15px;">
                        <div style="font-family: 'Orbitron', sans-serif; font-size: 18px; font-weight: 700; color: #f472b6; margin-bottom: 8px;">‚ú® Kills 160-179: Godly Rewards</div>
                        <div style="color: #d1d5db; font-size: 14px; line-height: 1.8;">
                            <span style="color: #a855f7;">üü£ Epic:</span> 5% |
                            <span style="color: #f59e0b;">üü† Legendary:</span> 90% |
                            <span style="color: #ec4899;">üíé Mythic:</span> 5%
                        </div>
                    </div>

                    <!-- 180-199 Kills -->
                    <div style="background: linear-gradient(135deg, rgba(251, 191, 36, 0.3), rgba(245, 158, 11, 0.25)); border: 2px solid rgba(251, 191, 36, 0.7); border-radius: 10px; padding: 15px;">
                        <div style="font-family: 'Orbitron', sans-serif; font-size: 18px; font-weight: 700; color: #fbbf24; margin-bottom: 8px;">üëë Kills 180-199: Ultimate Rewards</div>
                        <div style="color: #d1d5db; font-size: 14px; line-height: 1.8;">
                            <span style="color: #a855f7;">üü£ Epic:</span> 3% |
                            <span style="color: #f59e0b;">üü† Legendary:</span> 90% |
                            <span style="color: #ec4899;">üíé Mythic:</span> 7%
                        </div>
                    </div>

                    <!-- 200+ Kills -->
                    <div style="background: linear-gradient(135deg, rgba(168, 85, 247, 0.3), rgba(147, 51, 234, 0.25)); border: 3px solid rgba(168, 85, 247, 0.8); border-radius: 10px; padding: 15px; box-shadow: 0 0 30px rgba(168, 85, 247, 0.4);">
                        <div style="font-family: 'Rajdhani', sans-serif; font-size: 20px; font-weight: 700; color: #c084fc; margin-bottom: 8px; text-shadow: 0 0 8px rgba(168, 85, 247, 0.6); letter-spacing: 1px;">üåå Kills 200+: TRANSCENDENT</div>
                        <div style="color: #d1d5db; font-size: 14px; line-height: 1.8;">
                            <span style="color: #a855f7;">üü£ Epic:</span> 2% |
                            <span style="color: #f59e0b;">üü† Legendary:</span> 88% |
                            <span style="color: #ec4899;">üíé Mythic:</span> 10%
                        </div>
                    </div>
                </div>

                <div style="margin-top: 25px; padding: 15px; background: rgba(34, 197, 94, 0.15); border: 2px solid rgba(34, 197, 94, 0.5); border-radius: 10px;">
                    <p style="color: #6ee7b7; font-size: 14px; margin: 0; line-height: 1.6;">
                        <strong style="color: #10b981;">üí° Pro Tip:</strong> Item level scales with enemy level in Divine Arena. The deeper you push, the higher level items you'll receive! Mythic items also grant +5 item levels bonus.
                    </p>
                </div>
            </div>
        </div>
    `;

    const div = document.createElement('div');
    div.innerHTML = dropTableHTML;
    document.body.appendChild(div.firstElementChild);

    // Add escape key handler
    const closeModal = () => {
        const modal = document.getElementById('drop-table-modal');
        if (modal) {
            modal.remove();
            document.removeEventListener('keydown', escapeHandler);
        }
    };

    const escapeHandler = (e) => {
        if (e.key === 'Escape') {
            closeModal();
        }
    };

    document.addEventListener('keydown', escapeHandler);

    // Wire up close button
    document.getElementById('close-drop-table-btn').onclick = closeModal;

    // Click outside to close
    document.getElementById('drop-table-modal').onclick = (e) => {
        if (e.target.id === 'drop-table-modal') {
            closeModal();
        }
    };
};





window.addEventListener('beforeunload', function() {
    if (window.game && window.game.cleanup) {
        window.game.cleanup();
    }
});

// Cleanup on page visibility change
document.addEventListener('visibilitychange', function() {
    if (document.hidden && window.game) {
        if (!window.game.paused) {
            window.game._wasRunningBeforeHidden = true;
            window.game.paused = true;
        }
    } else if (!document.hidden && window.game && window.game._wasRunningBeforeHidden) {
        window.game.paused = false;
        window.game._wasRunningBeforeHidden = false;
    }
});

</script>
<!--ÂÆ¢Êúç ÂºÄÂßã-->
<script src="//g8hh.github.io/static/js/jquery.min.js"></script>
<link rel="stylesheet" href="//g8hh.github.io/static/css/kf.css" type="text/css" media="screen" charset="utf-8">
<script src="//g8hh.github.io/static/js/kf.js"></script>
<!-- ÂÆ¢Êúç ÁªìÊùü -->
<!--Á´ôÈïøÁªüËÆ°-->
   <div style="display: none"><script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f237591d5976f87ca2e06b38c3658d9c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

    </div>
</body>
</html>
